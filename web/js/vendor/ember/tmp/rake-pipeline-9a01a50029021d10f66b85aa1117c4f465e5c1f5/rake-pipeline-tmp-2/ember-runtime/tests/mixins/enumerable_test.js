minispade.register('ember-runtime/~tests/mixins/enumerable_test', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar indexOf = Ember.EnumerableUtils.indexOf;\n\n/*\n  Implement a basic fake enumerable.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestEnumerable = Ember.Object.extend(Ember.Enumerable, {\n\n  _content: null,\n\n  init: function(ary) {\n    this._content = ary || [];\n  },\n\n  addObject: function(obj) {\n    if (indexOf(this._content, obj)>=0) return this;\n    this._content.push(obj);\n    this.enumerableContentDidChange();\n  },\n\n  nextObject: function(idx) {\n    return idx >= Ember.get(this, 'length') ? undefined : this._content[idx];\n  },\n\n  length: Ember.computed(function() {\n    return this._content.length;\n  }).property().cacheable(),\n\n  slice: function() {\n    return this._content.slice();\n  }\n\n});\n\n\nEmber.EnumerableTests.extend({\n\n  name: 'Basic Enumerable',\n\n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestEnumerable(ary);\n  },\n\n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(obj._content.length+1);\n  },\n\n  toArray: function(obj) {\n    return obj.slice();\n  }\n\n}).run();\n\n// ..........................................................\n// CONTENT DID CHANGE\n//\n\nvar DummyEnum = Ember.Object.extend(Ember.Enumerable, {\n  nextObject: function() {},\n  length: 0\n});\n\nvar obj, observer;\n\n// ..........................................................\n// NOTIFY ENUMERABLE PROPERTY\n//\n\nmodule('mixins/enumerable/enumerableContentDidChange');\n\ntest('should notify observers of []', function() {\n\n  var obj = Ember.Object.create(Ember.Enumerable, {\n    nextObject: function() {}, // avoid exceptions\n\n    _count: 0,\n    enumerablePropertyDidChange: Ember.observer(function() {\n      this._count++;\n    }, '[]')\n  });\n\n  equal(obj._count, 0, 'should not have invoked yet');\n  obj.enumerableContentWillChange();\n  obj.enumerableContentDidChange();\n  equal(obj._count, 1, 'should have invoked');\n\n});\n\n// ..........................................................\n// NOTIFY CHANGES TO LENGTH\n//\n\nmodule('notify observers of length', {\n  setup: function() {\n    obj = DummyEnum.create({\n      _after: 0,\n      lengthDidChange: Ember.observer(function() {\n        this._after++;\n      }, 'length')\n\n    });\n\n    equal(obj._after, 0, 'should not have fired yet');\n  },\n\n  teardown: function() {\n    obj = null;\n  }\n});\n\ntest('should notify observers when call with no params', function() {\n  obj.enumerableContentWillChange();\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange();\n  equal(obj._after, 1);\n});\n\n// API variation that included items only\ntest('should not notify when passed arrays of same length', function() {\n  var added = ['foo'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange(removed, added);\n  equal(obj._after, 0);\n});\n\ntest('should notify when passed arrays of different length', function() {\n  var added = ['foo'], removed = ['bar', 'baz'];\n  obj.enumerableContentWillChange(removed, added);\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange(removed, added);\n  equal(obj._after, 1);\n});\n\n// API variation passes indexes only\ntest('should not notify when passed with indexes', function() {\n  obj.enumerableContentWillChange(1, 1);\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange(1, 1);\n  equal(obj._after, 0);\n});\n\ntest('should notify when passed old index API with delta', function() {\n  obj.enumerableContentWillChange(1, 2);\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange(1, 2);\n  equal(obj._after, 1);\n});\n\n\n// ..........................................................\n// NOTIFY ENUMERABLE OBSERVER\n//\n\nmodule('notify enumerable observers', {\n  setup: function() {\n    obj = DummyEnum.create();\n\n    observer = Ember.Object.create({\n      _before: null,\n      _after: null,\n\n      enumerableWillChange: function() {\n        equal(this._before, null); // should only call once\n        this._before = Array.prototype.slice.call(arguments);\n      },\n\n      enumerableDidChange: function() {\n        equal(this._after, null); // should only call once\n        this._after = Array.prototype.slice.call(arguments);\n      }\n    });\n\n    obj.addEnumerableObserver(observer);\n  },\n\n  teardown: function() {\n    obj = observer = null;\n  }\n});\n\ntest('should notify enumerable observers when called with no params', function() {\n  obj.enumerableContentWillChange();\n  deepEqual(observer._before, [obj, null, null]);\n\n  obj.enumerableContentDidChange();\n  deepEqual(observer._after, [obj, null, null]);\n});\n\n// API variation that included items only\ntest('should notify when called with same length items', function() {\n  var added = ['foo'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  deepEqual(observer._before, [obj, removed, added]);\n\n  obj.enumerableContentDidChange(removed, added);\n  deepEqual(observer._after, [obj, removed, added]);\n});\n\ntest('should notify when called with diff length items', function() {\n  var added = ['foo', 'baz'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  deepEqual(observer._before, [obj, removed, added]);\n\n  obj.enumerableContentDidChange(removed, added);\n  deepEqual(observer._after, [obj, removed, added]);\n});\n\ntest('should not notify when passed with indexes only', function() {\n  obj.enumerableContentWillChange(1, 2);\n  deepEqual(observer._before, [obj, 1, 2]);\n\n  obj.enumerableContentDidChange(1, 2);\n  deepEqual(observer._after, [obj, 1, 2]);\n});\n\ntest('removing enumerable observer should disable', function() {\n  obj.removeEnumerableObserver(observer);\n  obj.enumerableContentWillChange();\n  deepEqual(observer._before, null);\n\n  obj.enumerableContentDidChange();\n  deepEqual(observer._after, null);\n});\n\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/enumerable_test");