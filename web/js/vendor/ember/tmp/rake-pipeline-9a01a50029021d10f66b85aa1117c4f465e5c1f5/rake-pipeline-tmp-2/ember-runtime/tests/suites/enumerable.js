minispade.register('ember-runtime/~tests/suites/enumerable', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar ObserverClass = Ember.Object.extend({\n\n  _keysBefore: null,\n  _keys: null,\n  _values: null,\n  _before : null,\n  _after: null,\n\n  isEnabled: true,\n\n  init: function() {\n    this._super();\n    this.reset();\n  },\n\n\n  propertyWillChange: function(target, key) {\n    if (this._keysBefore[key] === undefined) { this._keysBefore[key] = 0; }\n    this._keysBefore[key]++;\n  },\n\n  /**\n    Invoked when the property changes.  Just records the parameters for\n    later analysis.\n  */\n  propertyDidChange: function(target, key, value) {\n    if (this._keys[key] === undefined) { this._keys[key] = 0; }\n    this._keys[key]++;\n    this._values[key] = value;\n  },\n\n  /**\n    Resets the recorded results for another run.\n\n    @returns {Object} receiver\n  */\n  reset: function() {\n    this._keysBefore = {};\n    this._keys = {};\n    this._values = {};\n    this._before = null;\n    this._after = null;\n    return this;\n  },\n\n\n  observeBefore: function(obj) {\n    if (obj.addBeforeObserver) {\n      var keys = Array.prototype.slice.call(arguments, 1),\n          loc  = keys.length;\n      while(--loc>=0) obj.addBeforeObserver(keys[loc], this, 'propertyWillChange');\n    }\n    return this;\n  },\n\n  /**\n    Begins observing the passed key names on the passed object.  Any changes\n    on the named properties will be recorded.\n\n    @param {Ember.Enumerable} obj\n      The enumerable to observe.\n\n    @returns {Object} receiver\n  */\n  observe: function(obj) {\n    if (obj.addObserver) {\n      var keys = Array.prototype.slice.call(arguments, 1),\n          loc  = keys.length;\n      while(--loc>=0) obj.addObserver(keys[loc], this, 'propertyDidChange');\n    } else {\n      this.isEnabled = false;\n    }\n    return this;\n  },\n\n  /**\n    Returns true if the passed key was invoked.  If you pass a value as\n    well then validates that the values match.\n\n    @param {String} key\n      Key to validate\n\n    @param {Object} value\n      (Optional) value\n\n    @returns {Boolean}\n  */\n  validate: function(key, value) {\n    if (!this.isEnabled) return true;\n    if (!this._keys[key]) return false;\n    if (arguments.length>1) return this._values[key] === value;\n    else return true;\n  },\n\n  /**\n    Returns times the before observer as invoked.\n\n    @param {String} key\n      Key to check\n  */\n  timesCalledBefore: function(key) {\n    return this._keysBefore[key] || 0;\n  },\n\n  /**\n    Returns times the observer as invoked.\n\n    @param {String} key\n      Key to check\n  */\n  timesCalled: function(key) {\n    return this._keys[key] || 0;\n  },\n\n  /**\n    begins acting as an enumerable observer.\n  */\n  observeEnumerable: function(obj) {\n    obj.addEnumerableObserver(this);\n    return this;\n  },\n\n  stopObserveEnumerable: function(obj) {\n    obj.removeEnumerableObserver(this);\n    return this;\n  },\n\n  enumerableWillChange: function() {\n    equal(this._before, null, 'should only call once');\n    this._before = Array.prototype.slice.call(arguments);\n  },\n\n  enumerableDidChange: function() {\n    equal(this._after, null, 'should only call once');\n    this._after = Array.prototype.slice.call(arguments);\n  }\n\n});\n\n\n/**\n  Defines a test suite that can be used to test any object for compliance\n  with any enumerable.  To use, extend this object and define the required\n  methods to generate new object instances for testing, etc.\n\n  You can also add your own tests by defining new methods beginning with the\n  word 'test'\n*/\nvar EnumerableTests = Ember.Object.extend({\n\n  /**\n    Define a name for these tests - all modules are prefixed w/ it.\n\n    @type String\n  */\n  name: Ember.required(String),\n\n  /**\n    Implement to return a new enumerable object for testing.  Should accept\n    either no parameters, a single number (indicating the desired length of\n    the collection) or an array of objects.\n\n    @param {Array} content\n      An array of items to include in the enumerable optionally.\n\n    @returns {Ember.Enumerable} a new enumerable\n  */\n  newObject: Ember.required(Function),\n\n  /**\n    Implement to return a set of new fixture objects that can be applied to\n    the enumerable.  This may be passed into the newObject method.\n\n    @param {Number} count\n      The number of items required.\n\n    @returns {Array} array of items\n  */\n  newFixture: function(cnt) {\n    var ret = [];\n    while(--cnt>=0) ret.push(Ember.generateGuid());\n    return ret;\n  },\n\n  /**\n    Implement accept an instance of the enumerable and return an array\n    containing the objects in the enumerable.  This is used only for testing\n    so performance is not important.\n\n    @param {Ember.Enumerable} enumerable\n      The enumerable to convert.\n\n    @returns {Array} array of items\n  */\n  toArray: Ember.required(Function),\n\n  /**\n    Implement this method if your object can mutate internally (even if it\n    does not support the MutableEnumerable API).  The method should accept\n    an object of your desired type and modify it somehow.  Suite tests will\n    use this to ensure that all appropriate caches, etc. clear when the\n    mutation occurs.\n\n    If you do not define this optional method, then mutation-related tests\n    will be skipped.\n\n    @param {Ember.Enumerable} enumerable\n      The enumerable to mutate\n\n    @returns {void}\n  */\n  mutate: function(){},\n\n  /**\n    Becomes true when you define a new mutate() method, indicating that\n    mutation tests should run.  This is calculated automatically.\n\n    @type Boolean\n  */\n  canTestMutation: Ember.computed(function() {\n    return this.mutate !== EnumerableTests.prototype.mutate;\n  }).property().cacheable(),\n\n  /**\n    Invoked to actually run the test - overridden by mixins\n  */\n  run: function() {},\n\n\n  /**\n    Creates a new observer object for testing.  You can add this object as an\n    observer on an array and it will record results anytime it is invoked.\n    After running the test, call the validate() method on the observer to\n    validate the results.\n  */\n  newObserver: function(obj) {\n    var ret = Ember.get(this, 'observerClass').create();\n    if (arguments.length>0) ret.observeBefore.apply(ret, arguments);\n    if (arguments.length>0) ret.observe.apply(ret, arguments);\n    return ret;\n  },\n\n  observerClass: ObserverClass\n\n});\n\nEnumerableTests.reopenClass({\n\n  plan: null,\n\n  run: function() {\n    var C = this;\n    return new C().run();\n  },\n\n  module: function(desc, opts) {\n    if (!opts) opts = {};\n    var setup = opts.setup, teardown = opts.teardown;\n    this.reopen({\n      run: function() {\n        this._super();\n        var title = Ember.get(this,'name')+': '+desc, ctx = this;\n        module(title, {\n          setup: function() {\n            if (setup) setup.call(ctx);\n          },\n\n          teardown: function() {\n            if (teardown) teardown.call(ctx);\n          }\n        });\n      }\n    });\n  },\n\n  test: function(name, func) {\n    this.reopen({\n      run: function() {\n        this._super();\n        var ctx = this;\n        if (!func) test(name); // output warning\n        else test(name, function() { func.call(ctx); });\n      }\n    });\n  },\n\n  // convert to guids to minimize logging.\n  same: function(actual, exp, message) {\n    actual = (actual && actual.map) ? actual.map(function(x) { return Ember.guidFor(x); }) : actual;\n    exp = (exp && exp.map) ? exp.map(function(x) { return Ember.guidFor(x); }) : exp;\n    return deepEqual(actual, exp, message);\n  },\n\n  // easy way to disable tests\n  notest: function() {}\n\n});\n\nEmber.EnumerableTests = EnumerableTests;\nEmber.EnumerableTests.ObserverClass = ObserverClass;\nminispade.require('ember-runtime/~tests/suites/enumerable/compact');\nminispade.require('ember-runtime/~tests/suites/enumerable/contains');\nminispade.require('ember-runtime/~tests/suites/enumerable/every');\nminispade.require('ember-runtime/~tests/suites/enumerable/filter');\nminispade.require('ember-runtime/~tests/suites/enumerable/find');\nminispade.require('ember-runtime/~tests/suites/enumerable/firstObject');\nminispade.require('ember-runtime/~tests/suites/enumerable/forEach');\nminispade.require('ember-runtime/~tests/suites/enumerable/mapProperty');\nminispade.require('ember-runtime/~tests/suites/enumerable/invoke');\nminispade.require('ember-runtime/~tests/suites/enumerable/lastObject');\nminispade.require('ember-runtime/~tests/suites/enumerable/map');\nminispade.require('ember-runtime/~tests/suites/enumerable/reduce');\nminispade.require('ember-runtime/~tests/suites/enumerable/some');\nminispade.require('ember-runtime/~tests/suites/enumerable/toArray');\nminispade.require('ember-runtime/~tests/suites/enumerable/uniq');\nminispade.require('ember-runtime/~tests/suites/enumerable/without');\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable");