minispade.register('ember-runtime/~tests/suites/suite', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/**\n  @class\n  A Suite can be used to define a reusable set of unit tests that can be\n  applied to any object.  Suites are most useful for defining tests that\n  work against a mixin or plugin API.  Developers implementing objects that\n  use the mixin or support the API can then run these tests against their\n  own code to verify compliance.\n\n  To define a suite, you need to define the tests themselves as well as a\n  callback API implementors can use to tie your tests to thier specific class.\n\n  ## Defining a Callback API\n\n  To define the callback API, just extend this class and add your properties\n  or methods that must be provided.  Use Ember.required() placeholders for\n  any properties that implementors must define themselves.\n\n  ## Defining Unit Tests\n\n  To add unit tests, use the suite.module() or suite.test() methods instead\n  of a regular module() or test() method when defining your tests.  This will\n  add the tests to the suite.\n\n  ## Using a Suite\n\n  To use a Suite to test your own objects, extend the suite subclass and\n  define any required methods.  Then call run() on the new subclass.  This\n  will create an instance of your class and then defining the unit tests.\n\n  @extends Ember.Object\n  @private\n*/\nEmber.Suite = Ember.Object.extend(\n  /** @scope Ember.Suite.prototype */ {\n\n  /**\n    Define a name for these tests - all modules are prefixed w/ it.\n\n    @type String\n  */\n  name: Ember.required(String),\n\n  /**\n    Invoked to actually run the test - overridden by mixins\n  */\n  run: function() {}\n\n});\n\nEmber.Suite.reopenClass({\n\n  plan: null,\n\n  run: function() {\n    var C = this;\n    return new C().run();\n  },\n\n  module: function(desc, opts) {\n    if (!opts) opts = {};\n    var setup = opts.setup, teardown = opts.teardown;\n    this.reopen({\n      run: function() {\n        this._super();\n        var title = Ember.get(this, 'name')+': '+desc, ctx = this;\n        module(title, {\n          setup: function() {\n            if (setup) setup.call(ctx);\n          },\n\n          teardown: function() {\n            if (teardown) teardown.call(ctx);\n          }\n        });\n      }\n    });\n  },\n\n  test: function(name, func) {\n    this.reopen({\n      run: function() {\n        this._super();\n        var ctx = this;\n        if (!func) test(name); // output warning\n        else test(name, function() { func.call(ctx); });\n      }\n    });\n  },\n\n  // convert to guids to minimize logging.\n  same: function(actual, exp, message) {\n    actual = (actual && actual.map) ? actual.map(function(x) { return Ember.guidFor(x); }) : actual;\n    exp = (exp && exp.map) ? exp.map(function(x) { return Ember.guidFor(x); }) : exp;\n    return deepEqual(actual, exp, message);\n  },\n\n  // easy way to disable tests\n  notest: function() {}\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/suite");