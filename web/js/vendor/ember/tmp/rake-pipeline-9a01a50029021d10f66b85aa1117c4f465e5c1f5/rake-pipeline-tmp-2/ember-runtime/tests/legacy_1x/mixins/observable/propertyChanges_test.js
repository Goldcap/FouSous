minispade.register('ember-runtime/~tests/legacy_1x/mixins/observable/propertyChanges_test', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * Create ObservableObject which includes Ember.Observable\n  * Remove test that tests internal _kvo_changeLevel property.  This is an\n    implementation detail.\n  * Remove test for allPropertiesDidChange\n  * Removed star observer test.  no longer supported\n  * Removed property revision test.  no longer supported\n*/\n\n// ========================================================================\n// Ember.Observable Tests\n// ========================================================================\n/*globals module test ok isObj equals expects */\n\nvar ObservableObject = Ember.Object.extend(Ember.Observable);\n\nvar revMatches = false , ObjectA;\n\nmodule(\"object.propertyChanges\", {\n  setup: function() {\n    ObjectA = ObservableObject.create({\n      foo  : 'fooValue',\n      prop : 'propValue',\n\n      action: Ember.observer(function() {\n        this.set('prop', 'changedPropValue');\n      }, 'foo'),\n\n      newFoo : 'newFooValue',\n      newProp: 'newPropValue',\n\n      notifyAction: Ember.observer(function() {\n        this.set('newProp', 'changedNewPropValue');\n      }, 'newFoo'),\n\n      notifyAllAction: Ember.observer(function() {\n        this.set('newFoo', 'changedNewFooValue');\n      }, 'prop'),\n\n      starProp: null,\n      starObserver: function(target, key, value, rev) {\n        revMatches = (rev === target.propertyRevision) ;\n        this.starProp = key;\n      }\n\n    });\n    }\n});\n\n\ntest(\"should observe the changes within the nested begin / end property changes\", function() {\n\n  //start the outer nest\n  ObjectA.beginPropertyChanges();\n    // Inner nest\n    ObjectA.beginPropertyChanges();\n        ObjectA.set('foo', 'changeFooValue');\n      equal(ObjectA.prop, \"propValue\") ;\n      ObjectA.endPropertyChanges();\n\n    //end inner nest\n    ObjectA.set('prop', 'changePropValue');\n    equal(ObjectA.newFoo, \"newFooValue\") ;\n  //close the outer nest\n  ObjectA.endPropertyChanges();\n\n  equal(ObjectA.prop, \"changedPropValue\") ;\n  equal(ObjectA.newFoo, \"changedNewFooValue\") ;\n\n});\n\ntest(\"should observe the changes within the begin and end property changes\", function() {\n\n  ObjectA.beginPropertyChanges();\n    ObjectA.set('foo', 'changeFooValue');\n\n  equal(ObjectA.prop, \"propValue\") ;\n    ObjectA.endPropertyChanges();\n\n  equal(ObjectA.prop, \"changedPropValue\") ;\n});\n\ntest(\"should indicate that the property of an object has just changed\", function() {\n  // inidicate that proprty of foo will change to its subscribers\n  ObjectA.propertyWillChange('foo') ;\n\n  //Value of the prop is unchanged yet as this will be changed when foo changes\n  equal(ObjectA.prop, 'propValue' ) ;\n\n  //change the value of foo.\n  ObjectA.set('foo', 'changeFooValue');\n\n  // Indicate the subscribers of foo that the value has just changed\n  ObjectA.propertyDidChange('foo', null) ;\n\n  // Values of prop has just changed\n  equal(ObjectA.prop,'changedPropValue') ;\n});\n\ntest(\"should notify that the property of an object has changed\", function() {\n  // Notify to its subscriber that the values of 'newFoo' will be changed. In this\n  // case the observer is \"newProp\". Therefore this will call the notifyAction function\n  // and value of \"newProp\" will be changed.\n  ObjectA.notifyPropertyChange('newFoo','fooValue');\n\n  //value of newProp changed.\n  equal(ObjectA.newProp,'changedNewPropValue') ;\n});\n\ntest(\"should invalidate function property cache when notifyPropertyChange is called\", function() {\n\n  var a = ObservableObject.create({\n    _b: null,\n    b: Ember.computed(function(key, value) {\n      if (value !== undefined) {\n        this._b = value;\n        return this;\n      }\n      return this._b;\n    }).volatile()\n  });\n\n  a.set('b', 'foo');\n  equal(a.get('b'), 'foo', 'should have set the correct value for property b');\n\n  a._b = 'bar';\n  a.notifyPropertyChange('b');\n  a.set('b', 'foo');\n  equal(a.get('b'), 'foo', 'should have invalidated the cache so that the newly set value is actually set');\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/mixins/observable/propertyChanges_test");