minispade.register('ember-runtime/~tests/legacy_1x/system/binding_test', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*global TestNamespace:true*/\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * All calls to Ember.run.sync() were changed to\n    Ember.run.sync()\n\n  * Bindings no longer accept a root object as their second param.  Instead\n    our test binding objects were put under a single object they could\n    originate from.\n\n  * tests that inspected internal properties were removed.\n\n  * converted foo.get/foo.set to use Ember.get/Ember.set\n\n  * Removed tests for Ember.Binding.isConnected.  Since binding instances are now\n    shared this property no longer makes sense.\n\n  * Changed call calls for obj.bind(...) to Ember.bind(obj, ...);\n\n  * Changed all calls to sc_super() to this._super()\n\n  * Changed all calls to disconnect() to pass the root object.\n\n  * removed calls to Ember.Binding.destroy() as that method is no longer useful\n    (or defined)\n\n  * changed use of T_STRING to 'string'\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n// ========================================================================\n// Ember.Binding Tests\n// ========================================================================\n\nvar fromObject, toObject, binding, Bon1, bon2, root; // global variables\n\nmodule(\"basic object binding\", {\n  setup: function() {\n    fromObject = Ember.Object.create({ value: 'start' }) ;\n    toObject = Ember.Object.create({ value: 'end' }) ;\n    root = { fromObject: fromObject, toObject: toObject };\n    Ember.run(function () {\n      binding = Ember.bind(root, 'toObject.value', 'fromObject.value');\n    });\n  }\n});\n\ntest(\"binding should have synced on connect\", function() {\n  equal(get(toObject, \"value\"), \"start\", \"toObject.value should match fromObject.value\");\n});\n\ntest(\"fromObject change should propagate to toObject only after flush\", function() {\n  Ember.run(function () {\n    set(fromObject, \"value\", \"change\") ;\n    equal(get(toObject, \"value\"), \"start\") ;\n  });\n  equal(get(toObject, \"value\"), \"change\") ;\n});\n\ntest(\"toObject change should propagate to fromObject only after flush\", function() {\n  Ember.run(function () {\n    set(toObject, \"value\", \"change\") ;\n    equal(get(fromObject, \"value\"), \"start\") ;\n  });\n  equal(get(fromObject, \"value\"), \"change\") ;\n});\n\ntest(\"deferred observing during bindings\", function() {\n\n  // setup special binding\n  fromObject = Ember.Object.create({\n    value1: 'value1',\n    value2: 'value2'\n  });\n\n  toObject = Ember.Object.create({\n    value1: 'value1',\n    value2: 'value2',\n\n    callCount: 0,\n\n    observer: Ember.observer(function() {\n      equal(get(this, 'value1'), 'CHANGED', 'value1 when observer fires');\n      equal(get(this, 'value2'), 'CHANGED', 'value2 when observer fires');\n      this.callCount++;\n    }, 'value1', 'value2')\n  });\n\n  var root = { fromObject: fromObject, toObject: toObject };\n  Ember.run(function () {\n    Ember.bind(root, 'toObject.value1', 'fromObject.value1');\n    Ember.bind(root, 'toObject.value2', 'fromObject.value2');\n\n    // change both value1 + value2, then  flush bindings.  observer should only\n    // fire after bindings are done flushing.\n    set(fromObject, 'value1', 'CHANGED');\n    set(fromObject, 'value2', 'CHANGED');\n  });\n\n  equal(toObject.callCount, 2, 'should call observer twice');\n});\n\ntest(\"binding disconnection actually works\", function() {\n  binding.disconnect(root);\n  Ember.run(function () {\n    set(fromObject, 'value', 'change');\n  });\n  equal(get(toObject, 'value'), 'start');\n});\n\n// ..........................................................\n// one way binding\n//\n\nmodule(\"one way binding\", {\n\n  setup: function() {\n    Ember.run(function() {\n      fromObject = Ember.Object.create({ value: 'start' }) ;\n      toObject = Ember.Object.create({ value: 'end' }) ;\n      root = { fromObject: fromObject, toObject: toObject };\n      binding = Ember.oneWay(root, 'toObject.value', 'fromObject.value');\n    });\n  },\n  teardown: function(){\n    Ember.run.cancelTimers();\n  }\n});\n\ntest(\"fromObject change should propagate after flush\", function() {\n  Ember.run(function() {\n    set(fromObject, \"value\", \"change\") ;\n    equal(get(toObject, \"value\"), \"start\") ;\n    Ember.run.sync() ;\n    equal(get(toObject, \"value\"), \"change\") ;\n  });\n});\n\ntest(\"toObject change should NOT propagate\", function() {\n  Ember.run(function() {\n    set(toObject, \"value\", \"change\") ;\n    equal(get(fromObject, \"value\"), \"start\") ;\n    Ember.run.sync() ;\n    equal(get(fromObject, \"value\"), \"start\") ;\n  });\n});\n\nvar first, second, third, binding1, binding2; // global variables\n\n// ..........................................................\n// chained binding\n//\n\nmodule(\"chained binding\", {\n\n  setup: function() {\n    Ember.run(function() {\n      first = Ember.Object.create({ output: 'first' }) ;\n\n      second = Ember.Object.create({\n        input: 'second',\n        output: 'second',\n\n        inputDidChange: Ember.observer(function() {\n          set(this, \"output\", get(this, \"input\")) ;\n        }, \"input\")\n      }) ;\n\n      third = Ember.Object.create({ input: \"third\" }) ;\n\n      root = { first: first, second: second, third: third };\n      binding1 = Ember.bind(root, 'second.input', 'first.output');\n      binding2 = Ember.bind(root, 'second.output', 'third.input');\n    });\n  },\n  teardown: function(){\n    Ember.run.cancelTimers();\n  }\n});\n\ntest(\"changing first output should propograte to third after flush\", function() {\n  Ember.run(function() {\n    set(first, \"output\", \"change\") ;\n    equal(\"change\", get(first, \"output\"), \"first.output\") ;\n    ok(\"change\" !== get(third, \"input\"), \"third.input\") ;\n\n    var didChange = true;\n    while(didChange) didChange = Ember.run.sync() ;\n\n    equal(\"change\", get(first, \"output\"), \"first.output\") ;\n    equal(\"change\", get(second, \"input\"), \"second.input\") ;\n    equal(\"change\", get(second, \"output\"), \"second.output\") ;\n    equal(\"change\", get(third,\"input\"), \"third.input\") ;\n  });\n});\n\n// ..........................................................\n// Custom Binding\n//\n\nmodule(\"Custom Binding\", {\n  setup: function() {\n    Bon1 = Ember.Object.extend({\n      value1: \"hi\",\n      value2: 83,\n      array1: []\n    });\n\n    bon2 = Ember.Object.create({\n      val1: \"hello\",\n      val2: 25,\n      arr: [1,2,3,4]\n    });\n\n    TestNamespace = {\n      bon2: bon2,\n      Bon1: Bon1\n    };\n  },\n  teardown: function() {\n    Bon1 = bon2 = TestNamespace  = null;\n    Ember.run.cancelTimers();\n  }\n});\n\ntest(\"two bindings to the same value should sync in the order they are initialized\", function() {\n\n  Ember.run.begin();\n\n  var a = Ember.Object.create({\n    foo: \"bar\"\n  });\n\n  var b = Ember.Object.create({\n    foo: \"baz\",\n    fooBinding: \"a.foo\",\n\n    a: a,\n\n    C: Ember.Object.extend({\n      foo: \"bee\",\n      fooBinding: \"owner.foo\"\n    }),\n\n    init: function() {\n      this._super();\n      set(this, 'c', this.C.create({ owner: this }));\n    }\n\n  });\n\n  Ember.run.end();\n\n  equal(get(a, 'foo'), \"bar\", 'a.foo should not change');\n  equal(get(b, 'foo'), \"bar\", 'a.foo should propagate up to b.foo');\n  equal(get(b.c, 'foo'), \"bar\", 'a.foo should propagate up to b.c.foo');\n});\n\n// ..........................................................\n// propertyNameBinding with longhand\n//\n\nmodule(\"propertyNameBinding with longhand\", {\n  setup: function(){\n    TestNamespace = {};\n    Ember.run(function () {\n      TestNamespace.fromObject = Ember.Object.create({\n        value: \"originalValue\"\n      });\n\n      TestNamespace.toObject = Ember.Object.create({\n          valueBinding: Ember.Binding.from('TestNamespace.fromObject.value'),\n          localValue: \"originalLocal\",\n          relativeBinding: Ember.Binding.from('localValue')\n      });\n    });\n  },\n  teardown: function(){\n    TestNamespace = undefined;\n  }\n});\n\ntest(\"works with full path\", function(){\n  Ember.run(function () {\n    set(TestNamespace.fromObject, 'value', \"updatedValue\");\n  });\n\n  equal(get(TestNamespace.toObject, 'value'), \"updatedValue\");\n\n  Ember.run(function () {\n    set(TestNamespace.fromObject, 'value', \"newerValue\");\n  });\n\n  equal(get(TestNamespace.toObject, 'value'), \"newerValue\");\n});\n\ntest(\"works with local path\", function(){\n  Ember.run(function () {\n    set(TestNamespace.toObject, 'localValue', \"updatedValue\");\n  });\n\n  equal(get(TestNamespace.toObject, 'relative'), \"updatedValue\");\n\n  Ember.run(function () {\n    set(TestNamespace.toObject, 'localValue', \"newerValue\");\n  });\n\n  equal(get(TestNamespace.toObject, 'relative'), \"newerValue\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/system/binding_test");