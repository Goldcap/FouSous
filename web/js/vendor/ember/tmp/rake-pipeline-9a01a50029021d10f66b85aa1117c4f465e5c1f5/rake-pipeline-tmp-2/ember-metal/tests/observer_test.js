minispade.register('ember-metal/~tests/observer_test', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals Global:true */\nminispade.require('ember-metal/~tests/props_helper');\n\n// ..........................................................\n// ADD OBSERVER\n//\n\nmodule('Ember.addObserver');\n\ntestBoth('observer should fire when property is modified', function(get,set) {\n\n  var obj = {};\n  var count = 0;\n\n  Ember.addObserver(obj, 'foo', function() {\n    equal(get(obj, 'foo'), 'bar', 'should invoke AFTER value changed');\n    count++;\n  });\n\n  set(obj, 'foo', 'bar');\n  equal(count, 1, 'should have invoked observer');\n});\n\ntestBoth('observer should fire when dependent property is modified', function(get, set) {\n  var obj = { bar: 'bar' };\n  Ember.defineProperty(obj, 'foo', Ember.computed(function() {\n    return get(this,'bar').toUpperCase();\n  }).property('bar'));\n\n  var count = 0;\n  Ember.addObserver(obj, 'foo', function() {\n    equal(get(obj, 'foo'), 'BAZ', 'should have invoked after prop change');\n    count++;\n  });\n\n  set(obj, 'bar', 'baz');\n  equal(count, 1, 'should have invoked observer');\n});\n\ntestBoth('nested observers should fire in order', function(get,set) {\n  var obj = { foo: 'foo', bar: 'bar' };\n  var fooCount = 0, barCount = 0;\n\n  Ember.addObserver(obj, 'foo' ,function() { fooCount++; });\n  Ember.addObserver(obj, 'bar', function() {\n    set(obj, 'foo', 'BAZ');\n    equal(fooCount, 1, 'fooCount should have fired already');\n    barCount++;\n  });\n\n  set(obj, 'bar', 'BIFF');\n  equal(barCount, 1, 'barCount should have fired');\n  equal(fooCount, 1, 'foo should have fired');\n\n});\n\ntestBoth('suspending an observer should not fire during callback', function(get,set) {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  otherTarget = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  Ember.addObserver(obj, 'foo', target, target.method);\n  Ember.addObserver(obj, 'foo', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      set(obj, 'foo', '2');\n\n      return 'result';\n  }\n\n  set(obj, 'foo', '1');\n  \n  equal(Ember._suspendObserver(obj, 'foo', target, target.method, callback), 'result');\n\n  set(obj, 'foo', '3');\n\n  deepEqual(target.values, ['1', '3'], 'should invoke');\n  deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');\n});\n\n\ntestBoth('suspending an observer should not defer change notifications during callback', function(get,set) {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  otherTarget = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  Ember.addObserver(obj, 'foo', target, target.method);\n  Ember.addObserver(obj, 'foo', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      set(obj, 'foo', '2');\n\n      return 'result';\n  }\n\n  set(obj, 'foo', '1');\n  \n  Ember.beginPropertyChanges();\n  equal(Ember._suspendObserver(obj, 'foo', target, target.method, callback), 'result');\n  Ember.endPropertyChanges();\n\n  set(obj, 'foo', '3');\n\n  deepEqual(target.values, ['1', '3'], 'should invoke');\n  deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');\n});\n\ntestBoth('suspending observers should not fire during callback', function(get,set) {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  otherTarget = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  Ember.addObserver(obj, 'foo', target, target.method);\n  Ember.addObserver(obj, 'foo', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      set(obj, 'foo', '2');\n\n      return 'result';\n  }\n\n  set(obj, 'foo', '1');\n\n  equal(Ember._suspendObservers(obj, ['foo'], target, target.method, callback), 'result');\n\n  set(obj, 'foo', '3');\n\n  deepEqual(target.values, ['1', '3'], 'should invoke');\n  deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');\n});\n\n\ntestBoth('suspending observers should not defer change notifications during callback', function(get,set) {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  otherTarget = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  Ember.addObserver(obj, 'foo', target, target.method);\n  Ember.addObserver(obj, 'foo', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      set(obj, 'foo', '2');\n\n      return 'result';\n  }\n\n  set(obj, 'foo', '1');\n\n  Ember.beginPropertyChanges();\n  equal(Ember._suspendObservers(obj, ['foo'], target, target.method, callback), 'result');\n  Ember.endPropertyChanges();\n\n  set(obj, 'foo', '3');\n\n  deepEqual(target.values, ['1', '3'], 'should invoke');\n  deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');\n});\n\ntestBoth('deferring property change notifications', function(get,set) {\n  var obj = { foo: 'foo' };\n  var fooCount = 0;\n\n  Ember.addObserver(obj, 'foo' ,function() { fooCount++; });\n\n  Ember.beginPropertyChanges(obj);\n  set(obj, 'foo', 'BIFF');\n  set(obj, 'foo', 'BAZ');\n  Ember.endPropertyChanges(obj);\n\n  equal(fooCount, 1, 'foo should have fired once');\n});\n\ntestBoth('deferring property change notifications safely despite exceptions', function(get,set) {\n  var obj = { foo: 'foo' };\n  var fooCount = 0;\n  var exc = new Error(\"Something unexpected happened!\");\n\n  expect(2);\n  Ember.addObserver(obj, 'foo' ,function() { fooCount++; });\n\n  try {\n    Ember.changeProperties(function(){\n      set(obj, 'foo', 'BIFF');\n      set(obj, 'foo', 'BAZ');\n      throw exc;\n    });\n  } catch(err) {\n    if (err !== exc)\n      throw err;\n  }\n\n  equal(fooCount, 1, 'foo should have fired once');\n\n  Ember.changeProperties(function(){\n    set(obj, 'foo', 'BIFF2');\n    set(obj, 'foo', 'BAZ2');\n  });\n\n  equal(fooCount, 2, 'foo should have fired again once');\n});\n\ntestBoth('deferring property change notifications will not defer before observers', function(get,set) {\n  var obj = { foo: 'foo' };\n  var fooCount = 0;\n\n  Ember.addBeforeObserver(obj, 'foo' ,function() { fooCount++; });\n\n  Ember.beginPropertyChanges(obj);\n  set(obj, 'foo', 'BIFF');\n  equal(fooCount, 1, 'should fire before observer immediately');\n  set(obj, 'foo', 'BAZ');\n  Ember.endPropertyChanges(obj);\n\n  equal(fooCount, 1, 'should not fire before observer twice');\n});\n\ntestBoth('implementing sendEvent on object should invoke when deferring property change notifications ends', function(get, set) {\n  var count = 0, events = [];\n  var obj = {\n    sendEvent: function(eventName) {\n      events.push(eventName);\n    },\n    foo: 'baz'\n  };\n\n  Ember.addObserver(obj, 'foo', function() { count++; });\n\n  Ember.beginPropertyChanges(obj);\n  set(obj, 'foo', 'BAZ');\n\n  equal(count, 0, 'should have not invoked observer');\n  equal(events.length, 1, 'should have invoked sendEvent for before');\n\n  Ember.endPropertyChanges(obj);\n\n  equal(count, 1, 'should have invoked observer');\n  equal(events.length, 2, 'should have invoked sendEvent');\n  equal(events[0], 'foo:before');\n  equal(events[1], 'foo:change');\n});\n\ntestBoth('addObserver should propagate through prototype', function(get,set) {\n  var obj = { foo: 'foo', count: 0 }, obj2;\n\n  Ember.addObserver(obj, 'foo', function() { this.count++; });\n  obj2 = Ember.create(obj);\n\n  set(obj2, 'foo', 'bar');\n\n  equal(obj2.count, 1, 'should have invoked observer on inherited');\n  equal(obj.count, 0, 'should not have invoked observer on parent');\n\n  obj2.count = 0;\n  set(obj, 'foo', 'baz');\n  equal(obj.count, 1, 'should have invoked observer on parent');\n  equal(obj2.count, 0, 'should not have invoked observer on inherited');\n});\n\ntestBoth('addObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    didChange: function(obj, keyName) {\n      var value = get(obj, keyName);\n      equal(this, target1, 'should invoke with this');\n      equal(obj, observed, 'param1 should be observed object');\n      equal(keyName, 'foo', 'param2 should be keyName');\n      equal(value, 'BAZ', 'param3 should new value');\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    didChange: function(obj, keyName) {\n      var value = get(obj, keyName);\n      equal(this, target2, 'should invoke with this');\n      equal(obj, observed, 'param1 should be observed object');\n      equal(keyName, 'foo', 'param2 should be keyName');\n      equal(value, 'BAZ', 'param3 should new value');\n      this.count++;\n    }\n  };\n\n  Ember.addObserver(observed, 'foo', target1, 'didChange');\n  Ember.addObserver(observed, 'foo', target2, target2.didChange);\n\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 1, 'target1 observer should have fired');\n  equal(target2.count, 1, 'target2 observer should have fired');\n\n});\n\ntestBoth('addObserver should allow multiple objects to observe a property', function(get, set) { var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    didChange: function(obj, keyName, value) {\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    didChange: function(obj, keyName, value) {\n      this.count++;\n    }\n  };\n\n  Ember.addObserver(observed, 'foo', target1, 'didChange');\n  Ember.addObserver(observed, 'foo', target2, 'didChange');\n\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 1, 'target1 observer should have fired');\n  equal(target2.count, 1, 'target2 observer should have fired');\n});\n\n// ..........................................................\n// REMOVE OBSERVER\n//\n\nmodule('Ember.removeObserver');\n\ntestBoth('removing observer should stop firing', function(get,set) {\n\n  var obj = {};\n  var count = 0;\n  function F() { count++; }\n  Ember.addObserver(obj, 'foo', F);\n\n  set(obj, 'foo', 'bar');\n  equal(count, 1, 'should have invoked observer');\n\n  Ember.removeObserver(obj, 'foo', F);\n});\n\ntestBoth('local observers can be removed', function(get, set) {\n  var barObserved = 0;\n\n  var MyMixin = Ember.Mixin.create({\n    foo1: Ember.observer(function() {\n      barObserved++;\n    }, 'bar'),\n\n    foo2: Ember.observer(function() {\n      barObserved++;\n    }, 'bar')\n  });\n\n  var obj = {};\n  MyMixin.apply(obj);\n\n  set(obj, 'bar', 'HI!');\n  equal(barObserved, 2, 'precond - observers should be fired');\n\n  Ember.removeObserver(obj, 'bar', null, 'foo1');\n\n  barObserved = 0;\n  set(obj, 'bar', 'HI AGAIN!');\n\n  equal(barObserved, 1, 'removed observers should not be called');\n});\n\ntestBoth('removeObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    didChange: function() {\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    didChange: function() {\n      this.count++;\n    }\n  };\n\n  Ember.addObserver(observed, 'foo', target1, 'didChange');\n  Ember.addObserver(observed, 'foo', target2, target2.didChange);\n\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 1, 'target1 observer should have fired');\n  equal(target2.count, 1, 'target2 observer should have fired');\n\n  Ember.removeObserver(observed, 'foo', target1, 'didChange');\n  Ember.removeObserver(observed, 'foo', target2, target2.didChange);\n\n  target1.count = target2.count = 0;\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 0, 'target1 observer should not fire again');\n  equal(target2.count, 0, 'target2 observer should not fire again');\n});\n\n// ..........................................................\n// BEFORE OBSERVER\n//\n\nmodule('Ember.addBeforeObserver');\n\ntestBoth('observer should fire before a property is modified', function(get,set) {\n\n  var obj = { foo: 'foo' };\n  var count = 0;\n\n  Ember.addBeforeObserver(obj, 'foo', function() {\n    equal(get(obj, 'foo'), 'foo', 'should invoke before value changed');\n    count++;\n  });\n\n  set(obj, 'foo', 'bar');\n  equal(count, 1, 'should have invoked observer');\n});\n\ntestBoth('observer should fire before dependent property is modified', function(get, set) {\n  var obj = { bar: 'bar' };\n  Ember.defineProperty(obj, 'foo', Ember.computed(function() {\n    return get(this,'bar').toUpperCase();\n  }).property('bar'));\n\n  var count = 0;\n  Ember.addBeforeObserver(obj, 'foo', function() {\n    equal(get(obj, 'foo'), 'BAR', 'should have invoked after prop change');\n    count++;\n  });\n\n  set(obj, 'bar', 'baz');\n  equal(count, 1, 'should have invoked observer');\n});\n\ntestBoth('addBeforeObserver should propagate through prototype', function(get,set) {\n  var obj = { foo: 'foo', count: 0 }, obj2;\n\n  Ember.addBeforeObserver(obj, 'foo', function() { this.count++; });\n  obj2 = Ember.create(obj);\n\n  set(obj2, 'foo', 'bar');\n  equal(obj2.count, 1, 'should have invoked observer on inherited');\n  equal(obj.count, 0, 'should not have invoked observer on parent');\n\n  obj2.count = 0;\n  set(obj, 'foo', 'baz');\n  equal(obj.count, 1, 'should have invoked oberver on parent');\n  equal(obj2.count, 0, 'should not have invoked observer on inherited');\n});\n\ntestBoth('addBeforeObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    willChange: function(obj, keyName) {\n      var value = get(obj, keyName);\n      equal(this, target1, 'should invoke with this');\n      equal(obj, observed, 'param1 should be observed object');\n      equal(keyName, 'foo', 'param2 should be keyName');\n      equal(value, 'foo', 'param3 should old value');\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    willChange: function(obj, keyName) {\n      var value = get(obj, keyName);\n      equal(this, target2, 'should invoke with this');\n      equal(obj, observed, 'param1 should be observed object');\n      equal(keyName, 'foo', 'param2 should be keyName');\n      equal(value, 'foo', 'param3 should old value');\n      this.count++;\n    }\n  };\n\n  Ember.addBeforeObserver(observed, 'foo', target1, 'willChange');\n  Ember.addBeforeObserver(observed, 'foo', target2, target2.willChange);\n\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 1, 'target1 observer should have fired');\n  equal(target2.count, 1, 'target2 observer should have fired');\n\n});\n\n// ..........................................................\n// CHAINED OBSERVERS\n//\n\nvar obj, count;\n\nmodule('Ember.addObserver - dependentkey with chained properties', {\n  setup: function() {\n    obj = {\n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }\n    };\n\n    Global = {\n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }\n    };\n\n    count = 0;\n  },\n\n  teardown: function() {\n    obj = count = Global = null;\n  }\n});\n\ntestBoth('depending on a simple chain', function(get, set) {\n\n  var val ;\n  Ember.addObserver(obj, 'foo.bar.baz.biff', function(target, key) {\n    val = Ember.get(target, key);\n    count++;\n  });\n\n  set(Ember.get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(val, 'BUZZ');\n  equal(count, 1);\n\n  set(Ember.get(obj, 'foo.bar'), 'baz', { biff: 'BLARG' });\n  equal(val, 'BLARG');\n  equal(count, 2);\n\n  set(Ember.get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equal(val, 'BOOM');\n  equal(count, 3);\n\n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equal(val, 'BLARG');\n  equal(count, 4);\n\n  set(Ember.get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(val, 'BUZZ');\n  equal(count, 5);\n\n  var foo = get(obj, 'foo');\n\n  set(obj, 'foo', 'BOO');\n  equal(val, undefined);\n  equal(count, 6);\n\n  set(foo.bar.baz, 'biff', \"BOOM\");\n  equal(count, 6, 'should be not have invoked observer');\n});\n\ntestBoth('depending on a Global chain', function(get, set) {\n\n  var val ;\n  Ember.addObserver(obj, 'Global.foo.bar.baz.biff', function(target, key){\n    val = Ember.get(window, key);\n    count++;\n  });\n\n  set(Ember.get(Global, 'foo.bar.baz'),  'biff', 'BUZZ');\n  equal(val, 'BUZZ');\n  equal(count, 1);\n\n  set(Ember.get(Global, 'foo.bar'),  'baz', { biff: 'BLARG' });\n  equal(val, 'BLARG');\n  equal(count, 2);\n\n  set(Ember.get(Global, 'foo'),  'bar', { baz: { biff: 'BOOM' } });\n  equal(val, 'BOOM');\n  equal(count, 3);\n\n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equal(val, 'BLARG');\n  equal(count, 4);\n\n  set(Ember.get(Global, 'foo.bar.baz'),  'biff', 'BUZZ');\n  equal(val, 'BUZZ');\n  equal(count, 5);\n\n  var foo = get(obj, 'foo');\n\n  set(Global, 'foo', 'BOO');\n  equal(val, undefined);\n  equal(count, 6);\n\n  set(foo.bar.baz, 'biff', \"BOOM\");\n  equal(count, 6, 'should be not have invoked observer');\n});\n\n// ..........................................................\n// SETTING IDENTICAL VALUES\n//\n\nmodule('props/observer_test - setting identical values');\n\ntestBoth('setting simple prop should not trigger', function(get, set) {\n\n  var obj = { foo: 'bar' };\n  var count = 0;\n\n  Ember.addObserver(obj, 'foo', function() { count++; });\n\n  set(obj, 'foo', 'bar');\n  equal(count, 0, 'should not trigger observer');\n\n  set(obj, 'foo', 'baz');\n  equal(count, 1, 'should trigger observer');\n\n  set(obj, 'foo', 'baz');\n  equal(count, 1, 'should not trigger observer again');\n});\n\n// The issue here is when a computed property is directly set with a value, then has a\n// dependent key change (which triggers a cache expiration and recomputation), observers will\n// not be fired if the CP setter is called with the last set value.\ntestBoth('setting a cached computed property whose value has changed should trigger', function(get, set) {\n  var obj = {};\n\n  Ember.defineProperty(obj, 'foo', Ember.computed(function(key, value) {\n    if (arguments.length === 2) { return value; }\n    return get(this, 'baz');\n  }).property('baz').cacheable());\n\n  var count = 0;\n\n  Ember.addObserver(obj, 'foo', function() { count++; });\n\n  set(obj, 'foo', 'bar');\n  equal(count, 1);\n  equal(get(obj, 'foo'), 'bar');\n\n  set(obj, 'baz', 'qux');\n  equal(count, 2);\n  equal(get(obj, 'foo'), 'qux');\n\n  get(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equal(count, 3);\n  equal(get(obj, 'foo'), 'bar');\n});\n\nmodule(\"Ember.immediateObserver\");\n\ntestBoth(\"immediate observers should fire synchronously\", function(get, set) {\n  var obj = {},\n      observerCalled = 0,\n      mixin;\n\n  // explicitly create a run loop so we do not inadvertently\n  // trigger deferred behavior\n  Ember.run(function() {\n    mixin = Ember.Mixin.create({\n      fooDidChange: Ember.immediateObserver(function() {\n        observerCalled++;\n        equal(get(this, 'foo'), \"barbaz\", \"newly set value is immediately available\");\n      }, 'foo')\n    });\n\n    mixin.apply(obj);\n\n    Ember.defineProperty(obj, 'foo', Ember.computed(function(key, value) {\n      if (arguments.length > 1) {\n        return value;\n      }\n      return \"yes hello this is foo\";\n    }).cacheable());\n\n    equal(get(obj, 'foo'), \"yes hello this is foo\", \"precond - computed property returns a value\");\n    equal(observerCalled, 0, \"observer has not yet been called\");\n\n    set(obj, 'foo', 'barbaz');\n\n    equal(observerCalled, 1, \"observer was called once\");\n  });\n});\n\ntestBoth(\"immediate observers are for internal properties only\", function(get, set) {\n  raises(function() {\n    Ember.immediateObserver(Ember.K, 'foo.bar');\n  });\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/observer_test");