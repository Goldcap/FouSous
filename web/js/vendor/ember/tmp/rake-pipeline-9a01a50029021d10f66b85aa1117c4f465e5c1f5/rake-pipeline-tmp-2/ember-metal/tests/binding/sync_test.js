minispade.register('ember-metal/~tests/binding/sync_test', "(function() {module(\"system/binding/sync_test.js\");\n\ntestBoth(\"bindings should not sync twice in a single run loop\", function(get, set) {\n  var a, b, setValue, setCalled=0, getCalled=0;\n\n  Ember.run(function() {\n    a = {};\n\n    Ember.defineProperty(a, 'foo', Ember.computed(function(key, value) {\n      if (arguments.length === 2) {\n        setCalled++;\n        setValue = value;\n        return value;\n      } else {\n        getCalled++;\n        return setValue;\n      }\n    }).volatile());\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n  });\n\n  // reset after initial binding synchronization\n  getCalled = 0;\n\n  Ember.run(function() {\n    set(a, 'foo', 'trollface');\n  });\n\n  equal(get(b, 'foo'), \"trollface\", \"the binding should sync\");\n  equal(setCalled, 1, \"Set should only be called once\");\n  equal(getCalled, 1, \"Get should only be called once\");\n});\n\ntestBoth(\"bindings should not infinite loop if computed properties return objects\", function(get, set) {\n  var a, b, getCalled=0;\n\n  Ember.run(function() {\n    a = {};\n\n    Ember.defineProperty(a, 'foo', Ember.computed(function() {\n      getCalled++;\n      if (getCalled > 1000) {\n        throw 'infinite loop detected';\n      }\n      return ['foo', 'bar'];\n    }));\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n  });\n\n  deepEqual(get(b, 'foo'), ['foo', 'bar'], \"the binding should sync\");\n  equal(getCalled, 1, \"Get should only be called once\");\n});\n\ntestBoth(\"bindings should do the right thing when observers trigger bindings in the opposite direction\", function(get, set) {\n  var a, b, c;\n\n  Ember.run(function() {\n    a = {\n      foo: 'trololol'\n    };\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n\n    c = {\n      a: a\n    };\n    Ember.bind(c, 'foo', 'a.foo');\n  });\n\n  Ember.addObserver(b, 'foo', function() {\n    set(c, 'foo', \"what is going on\");\n  });\n\n  Ember.run(function() {\n    set(a, 'foo', 'trollface');\n  });\n\n  equal(get(a, 'foo'), \"what is going on\");\n});\n\ntestBoth(\"bindings should do the right thing when binding is in prototype\", function(get, set) {\n  var obj, proto, a, b, selectionChanged;\n  Ember.run(function() {\n    obj = {\n      selection: null\n    };\n\n    selectionChanged = 0;\n\n    Ember.addObserver(obj, 'selection', function () {\n      selectionChanged++;\n    });\n\n    proto = {\n      obj: obj,\n      changeSelection: function (value) {\n        set(this, 'selection', value);\n      }\n    };\n    Ember.bind(proto, 'selection', 'obj.selection');\n\n    a = Ember.create(proto);\n    b = Ember.create(proto);\n    Ember.rewatch(a);\n    Ember.rewatch(b);\n  });\n\n  Ember.run(function () {\n    set(a, 'selection', 'a');\n  });\n\n  Ember.run(function () {\n    set(b, 'selection', 'b');\n  });\n\n  Ember.run(function () {\n    set(a, 'selection', 'a');\n  });\n\n  equal(selectionChanged, 3);\n  equal(get(obj, 'selection'), 'a');\n});\n\ntestBoth(\"bindings should not try to sync destroyed objects\", function(get, set) {\n  var a, b;\n\n  Ember.run(function() {\n    a = {\n      foo: 'trololol'\n    };\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n  });\n\n  Ember.run(function() {\n    set(a, 'foo', 'trollface');\n    set(b, 'isDestroyed', true);\n    ok(true, \"should not raise\");\n  });\n\n  Ember.run(function() {\n    a = {\n      foo: 'trololol'\n    };\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n  });\n\n  Ember.run(function() {\n    set(b, 'foo', 'trollface');\n    set(a, 'isDestroyed', true);\n    ok(true, \"should not raise\");\n  });\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/binding/sync_test");