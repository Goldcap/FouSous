minispade.register('ember-metal/~tests/run_loop/unwind_test', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/run_loop/unwind_test');\n\ntest('RunLoop unwinds despite unhandled exception', function() {\n  var initialRunLoop = Ember.run.currentRunLoop;\n\n  raises(function(){\n    Ember.run(function() {\n      Ember.run.schedule('actions', function() { throw new Error(\"boom!\"); });\n    });\n  }, Error, \"boom!\");\n\n  // The real danger at this point is that calls to autorun will stick\n  // tasks into the already-dead runloop, which will never get\n  // flushed. I can't easily demonstrate this in a unit test because\n  // autorun explicitly doesn't work in test mode. - ef4\n  equal(Ember.run.currentRunLoop, initialRunLoop, \"Previous run loop should be cleaned up despite exception\");\n\n  // Prevent a failure in this test from breaking subsequent tests.\n  Ember.run.currentRunLoop = initialRunLoop;\n\n});\n\ntest('Ember.run unwinds despite unhandled exception', function() {\n  var initialRunLoop = Ember.run.currentRunLoop;\n\n  raises(function(){\n    Ember.run(function() {\n      throw new Error(\"boom!\");\n    });\n  }, Error, \"boom!\");\n\n  equal(Ember.run.currentRunLoop, initialRunLoop, \"Previous run loop should be cleaned up despite exception\");\n\n  // Prevent a failure in this test from breaking subsequent tests.\n  Ember.run.currentRunLoop = initialRunLoop;\n\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/unwind_test");