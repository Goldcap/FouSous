minispade.register('ember-metal/~tests/watching/watch_test', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals Global:true */\nminispade.require('ember-metal/~tests/props_helper');\n\nvar willCount = 0 , didCount = 0,\n    willKeys = [] , didKeys = [],\n    willChange = Ember.propertyWillChange,\n    didChange = Ember.propertyDidChange;\n\nmodule('Ember.watch', {\n  setup: function() {\n    willCount = didCount = 0;\n    willKeys = [];\n    didKeys = [];\n    Ember.propertyWillChange = function(cur, keyName) {\n      willCount++;\n      willKeys.push(keyName);\n      willChange.call(this, cur, keyName);\n    };\n\n    Ember.propertyDidChange = function(cur, keyName) {\n      didCount++;\n      didKeys.push(keyName);\n      didChange.call(this, cur, keyName);\n    };\n  },\n\n  teardown: function() {\n    Ember.propertyWillChange = willChange;\n    Ember.propertyDidChange  = didChange;\n  }\n});\n\ntestBoth('watching a computed property', function(get, set) {\n\n  var obj = {};\n  Ember.defineProperty(obj, 'foo', Ember.computed(function(keyName, value) {\n    if (value !== undefined) this.__foo = value;\n    return this.__foo;\n  }));\n\n  Ember.watch(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n});\n\ntestBoth('watching a regular defined property', function(get, set) {\n\n  var obj = { foo: 'baz' };\n\n  Ember.watch(obj, 'foo');\n  equal(get(obj, 'foo'), 'baz', 'should have original prop');\n\n  set(obj, 'foo', 'bar');\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n\n  equal(get(obj, 'foo'), 'bar', 'should get new value');\n  equal(obj.foo, 'bar', 'property should be accessible on obj');\n});\n\ntestBoth('watching a regular undefined property', function(get, set) {\n\n  var obj = { };\n\n  Ember.watch(obj, 'foo');\n\n  equal('foo' in obj, false, 'precond undefined');\n\n  set(obj, 'foo', 'bar');\n\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n\n  equal(get(obj, 'foo'), 'bar', 'should get new value');\n  equal(obj.foo, 'bar', 'property should be accessible on obj');\n});\n\ntestBoth('watches should inherit', function(get, set) {\n\n  var obj = { foo: 'baz' };\n  var objB = Ember.create(obj);\n\n  Ember.watch(obj, 'foo');\n  equal(get(obj, 'foo'), 'baz', 'should have original prop');\n\n  set(obj, 'foo', 'bar');\n  set(objB, 'foo', 'baz');\n  equal(willCount, 2, 'should have invoked willCount once only');\n  equal(didCount, 2, 'should have invoked didCount once only');\n});\n\ntest(\"watching an object THEN defining it should work also\", function() {\n\n  var obj = {};\n  Ember.watch(obj, 'foo');\n\n  Ember.defineProperty(obj, 'foo');\n  Ember.set(obj, 'foo', 'bar');\n\n  equal(Ember.get(obj, 'foo'), 'bar', 'should have set');\n  equal(willCount, 1, 'should have invoked willChange once');\n  equal(didCount, 1, 'should have invoked didChange once');\n\n});\n\ntest(\"watching a chain then defining the property\", function () {\n  var obj = {};\n  var foo = {bar: 'bar'};\n  Ember.watch(obj, 'foo.bar');\n\n  Ember.defineProperty(obj, 'foo', undefined, foo);\n  Ember.set(foo, 'bar', 'baz');\n\n  deepEqual(willKeys, ['bar', 'foo.bar'], 'should have invoked willChange with bar, foo.bar');\n  deepEqual(didKeys, ['bar', 'foo.bar'], 'should have invoked didChange with bar, foo.bar');\n  equal(willCount, 2, 'should have invoked willChange twice');\n  equal(didCount, 2, 'should have invoked didChange twice');\n});\n\ntest(\"watching a chain then defining the nested property\", function () {\n  var bar = {};\n  var obj = {foo: bar};\n  var baz = {baz: 'baz'};\n  Ember.watch(obj, 'foo.bar.baz');\n\n  Ember.defineProperty(bar, 'bar', undefined, baz);\n  Ember.set(baz, 'baz', 'BOO');\n\n  deepEqual(willKeys, ['baz', 'foo.bar.baz'], 'should have invoked willChange with bar, foo.bar');\n  deepEqual(didKeys, ['baz', 'foo.bar.baz'], 'should have invoked didChange with bar, foo.bar');\n  equal(willCount, 2, 'should have invoked willChange twice');\n  equal(didCount, 2, 'should have invoked didChange twice');\n});\n\ntestBoth('watching an object value then unwatching should restore old value', function(get, set) {\n\n  var obj = { foo: { bar: { baz: { biff: 'BIFF' } } } };\n  Ember.watch(obj, 'foo.bar.baz.biff');\n\n  var foo = Ember.get(obj, 'foo');\n  equal(get(get(get(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');\n\n  Ember.unwatch(obj, 'foo.bar.baz.biff');\n  equal(get(get(get(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');\n});\n\ntestBoth('watching a global object that does not yet exist should queue', function(get, set) {\n\n  Global = null;\n\n  var obj = {};\n  Ember.watch(obj, 'Global.foo'); // only works on global chained props\n\n  equal(willCount, 0, 'should not have fired yet');\n  equal(didCount, 0, 'should not have fired yet');\n\n  Global = { foo: 'bar' };\n  Ember.watch.flushPending(); // this will also be invoked automatically on ready\n\n  equal(willCount, 0, 'should not have fired yet');\n  equal(didCount, 0, 'should not have fired yet');\n\n  set(Global, 'foo', 'baz');\n\n  // should fire twice because this is a chained property (once on key, once\n  // on path)\n  equal(willCount, 2, 'should be watching');\n  equal(didCount, 2, 'should be watching');\n\n  Global = null; // reset\n});\n\ntest('when watching a global object, destroy should remove chain watchers from the global object', function() {\n\n  Global = { foo: 'bar' };\n  var obj = {};\n\n  Ember.watch(obj, 'Global.foo');\n\n  var meta_Global = Ember.meta(Global);\n  var chainNode = Ember.meta(obj).chains._chains.Global._chains.foo;\n  var guid = Ember.guidFor(chainNode);\n\n  equal(meta_Global.watching.foo, 1, 'should be watching foo');\n  strictEqual(meta_Global.chainWatchers.foo[guid], chainNode, 'should have chain watcher');\n\n  Ember.destroy(obj);\n\n  equal(meta_Global.watching.foo, 0, 'should not be watching foo');\n  strictEqual(meta_Global.chainWatchers.foo[guid], undefined, 'should not have chain watcher');\n\n  Global = null; // reset\n});\n\ntest('when watching another object, destroy should remove chain watchers from the other object', function() {\n\n  var objA = {};\n  var objB = {foo: 'bar'};\n  objA.b = objB;\n\n  Ember.watch(objA, 'b.foo');\n\n  var meta_objB = Ember.meta(objB);\n  var chainNode = Ember.meta(objA).chains._chains.b._chains.foo;\n  var guid = Ember.guidFor(chainNode);\n\n  equal(meta_objB.watching.foo, 1, 'should be watching foo');\n  strictEqual(meta_objB.chainWatchers.foo[guid], chainNode, 'should have chain watcher');\n\n  Ember.destroy(objA);\n\n  equal(meta_objB.watching.foo, 0, 'should not be watching foo');\n  strictEqual(meta_objB.chainWatchers.foo[guid], undefined, 'should not have chain watcher');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/watching/watch_test");