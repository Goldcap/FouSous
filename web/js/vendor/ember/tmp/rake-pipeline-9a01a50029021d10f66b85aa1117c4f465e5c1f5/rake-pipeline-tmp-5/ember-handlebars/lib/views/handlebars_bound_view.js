minispade.register('ember-handlebars/views/handlebars_bound_view', "(function() {// ==========================================================================\n// Project:   Ember Handlebars Views\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals Handlebars */\n\nvar get = Ember.get, set = Ember.set, getPath = Ember.Handlebars.getPath;\nminispade.require('ember-views/views/view');\nminispade.require('ember-handlebars/views/metamorph_view');\n\n/**\n  @ignore\n  @private\n  @class\n\n  Ember._HandlebarsBoundView is a private view created by the Handlebars `{{bind}}`\n  helpers that is used to keep track of bound properties.\n\n  Every time a property is bound using a `{{mustache}}`, an anonymous subclass\n  of Ember._HandlebarsBoundView is created with the appropriate sub-template and\n  context set up. When the associated property changes, just the template for\n  this view will re-render.\n*/\nEmber._HandlebarsBoundView = Ember._MetamorphView.extend({\n/** @scope Ember._HandlebarsBoundView.prototype */\n\n  /**\n    The function used to determine if the `displayTemplate` or\n    `inverseTemplate` should be rendered. This should be a function that takes\n    a value and returns a Boolean.\n\n    @type Function\n    @default null\n  */\n  shouldDisplayFunc: null,\n\n  /**\n    Whether the template rendered by this view gets passed the context object\n    of its parent template, or gets passed the value of retrieving `path`\n    from the `pathRoot`.\n\n    For example, this is true when using the `{{#if}}` helper, because the\n    template inside the helper should look up properties relative to the same\n    object as outside the block. This would be false when used with `{{#with\n    foo}}` because the template should receive the object found by evaluating\n    `foo`.\n\n    @type Boolean\n    @default false\n  */\n  preserveContext: false,\n\n  /**\n    If `preserveContext` is true, this is the object that will be used\n    to render the template.\n\n    @type Object\n  */\n  previousContext: null,\n\n  /**\n    The template to render when `shouldDisplayFunc` evaluates to true.\n\n    @type Function\n    @default null\n  */\n  displayTemplate: null,\n\n  /**\n    The template to render when `shouldDisplayFunc` evaluates to false.\n\n    @type Function\n    @default null\n  */\n  inverseTemplate: null,\n\n\n  /**\n    The path to look up on `pathRoot` that is passed to\n    `shouldDisplayFunc` to determine which template to render.\n\n    In addition, if `preserveContext` is false, the object at this path will\n    be passed to the template when rendering.\n\n    @type String\n    @default null\n  */\n  path: null,\n\n  /**\n    The object from which the `path` will be looked up. Sometimes this is the\n    same as the `previousContext`, but in cases where this view has been generated\n    for paths that start with a keyword such as `view` or `controller`, the\n    path root will be that resolved object.\n\n    @type Object\n  */\n  pathRoot: null,\n\n  normalizedValue: Ember.computed(function() {\n    var path = get(this, 'path'),\n        pathRoot  = get(this, 'pathRoot'),\n        valueNormalizer = get(this, 'valueNormalizerFunc'),\n        result, templateData;\n\n    // Use the pathRoot as the result if no path is provided. This\n    // happens if the path is `this`, which gets normalized into\n    // a `pathRoot` of the current Handlebars context and a path\n    // of `''`.\n    if (path === '') {\n      result = pathRoot;\n    } else {\n      templateData = get(this, 'templateData');\n      result = getPath(pathRoot, path, { data: templateData });\n    }\n\n    return valueNormalizer ? valueNormalizer(result) : result;\n  }).property('path', 'pathRoot', 'valueNormalizerFunc').volatile(),\n\n  rerenderIfNeeded: function() {\n    if (!get(this, 'isDestroyed') && get(this, 'normalizedValue') !== this._lastNormalizedValue) {\n      this.rerender();\n    }\n  },\n\n  /**\n    Determines which template to invoke, sets up the correct state based on\n    that logic, then invokes the default Ember.View `render` implementation.\n\n    This method will first look up the `path` key on `pathRoot`,\n    then pass that value to the `shouldDisplayFunc` function. If that returns\n    true, the `displayTemplate` function will be rendered to DOM. Otherwise,\n    `inverseTemplate`, if specified, will be rendered.\n\n    For example, if this Ember._HandlebarsBoundView represented the {{#with foo}}\n    helper, it would look up the `foo` property of its context, and\n    `shouldDisplayFunc` would always return true. The object found by looking\n    up `foo` would be passed to `displayTemplate`.\n\n    @param {Ember.RenderBuffer} buffer\n  */\n  render: function(buffer) {\n    // If not invoked via a triple-mustache ({{{foo}}}), escape\n    // the content of the template.\n    var escape = get(this, 'isEscaped');\n\n    var shouldDisplay = get(this, 'shouldDisplayFunc'),\n        preserveContext = get(this, 'preserveContext'),\n        context = get(this, 'previousContext');\n\n    var inverseTemplate = get(this, 'inverseTemplate'),\n        displayTemplate = get(this, 'displayTemplate');\n\n    var result = get(this, 'normalizedValue');\n    this._lastNormalizedValue = result;\n\n    // First, test the conditional to see if we should\n    // render the template or not.\n    if (shouldDisplay(result)) {\n      set(this, 'template', displayTemplate);\n\n      // If we are preserving the context (for example, if this\n      // is an #if block, call the template with the same object.\n      if (preserveContext) {\n        set(this, '_context', context);\n      } else {\n      // Otherwise, determine if this is a block bind or not.\n      // If so, pass the specified object to the template\n        if (displayTemplate) {\n          set(this, '_context', result);\n        } else {\n        // This is not a bind block, just push the result of the\n        // expression to the render context and return.\n          if (result === null || result === undefined) {\n            result = \"\";\n          } else if (!(result instanceof Handlebars.SafeString)) {\n            result = String(result);\n          }\n\n          if (escape) { result = Handlebars.Utils.escapeExpression(result); }\n          buffer.push(result);\n          return;\n        }\n      }\n    } else if (inverseTemplate) {\n      set(this, 'template', inverseTemplate);\n\n      if (preserveContext) {\n        set(this, '_context', context);\n      } else {\n        set(this, '_context', result);\n      }\n    } else {\n      set(this, 'template', function() { return ''; });\n    }\n\n    return this._super(buffer);\n  }\n});\n\n})();\n//@ sourceURL=ember-handlebars/views/handlebars_bound_view");