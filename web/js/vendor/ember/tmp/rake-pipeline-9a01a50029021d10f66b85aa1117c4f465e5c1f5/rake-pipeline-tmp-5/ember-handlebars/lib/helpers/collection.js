minispade.register('ember-handlebars/helpers/collection', "(function() {// ==========================================================================\n// Project:   Ember Handlebars Views\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals Handlebars */\n\n// TODO: Don't require all of this module\nminispade.require('ember-handlebars');\nminispade.require('ember-handlebars/helpers/view');\n\nvar get = Ember.get, getPath = Ember.Handlebars.getPath, fmt = Ember.String.fmt;\n\n/**\n  `{{collection}}` is a `Ember.Handlebars` helper for adding instances of\n  `Ember.CollectionView` to a template.  See `Ember.CollectionView` for additional\n  information on how a `CollectionView` functions.\n\n  `{{collection}}`'s primary use is as a block helper with a `contentBinding` option\n  pointing towards an `Ember.Array`-compatible object.  An `Ember.View` instance will\n  be created for each item in its `content` property. Each view will have its own\n  `content` property set to the appropriate item in the collection.\n\n  The provided block will be applied as the template for each item's view.\n\n  Given an empty `<body>` the following template:\n\n      <script type=\"text/x-handlebars\">\n        {{#collection contentBinding=\"App.items\"}}\n          Hi {{content.name}}\n        {{/collection}}\n      </script>\n\n  And the following application code\n\n      App = Ember.Application.create()\n      App.items = [\n        Ember.Object.create({name: 'Dave'}),\n        Ember.Object.create({name: 'Mary'}),\n        Ember.Object.create({name: 'Sara'})\n      ]\n\n  Will result in the HTML structure below\n\n      <div class=\"ember-view\">\n        <div class=\"ember-view\">Hi Dave</div>\n        <div class=\"ember-view\">Hi Mary</div>\n        <div class=\"ember-view\">Hi Sara</div>\n      </div>\n\n  ### Blockless Use\n  If you provide an `itemViewClass` option that has its own `template` you can omit\n  the block.\n\n  The following template:\n\n      <script type=\"text/x-handlebars\">\n        {{collection contentBinding=\"App.items\" itemViewClass=\"App.AnItemView\"}}\n      </script>\n\n  And application code\n\n      App = Ember.Application.create()\n      App.items = [\n        Ember.Object.create({name: 'Dave'}),\n        Ember.Object.create({name: 'Mary'}),\n        Ember.Object.create({name: 'Sara'})\n      ]\n\n      App.AnItemView = Ember.View.extend({\n        template: Ember.Handlebars.compile(\"Greetings {{content.name}}\")\n      })\n\n  Will result in the HTML structure below\n\n      <div class=\"ember-view\">\n        <div class=\"ember-view\">Greetings Dave</div>\n        <div class=\"ember-view\">Greetings Mary</div>\n        <div class=\"ember-view\">Greetings Sara</div>\n      </div>\n\n  ### Specifying a CollectionView subclass\n  By default the `{{collection}}` helper will create an instance of `Ember.CollectionView`.\n  You can supply a `Ember.CollectionView` subclass to the helper by passing it\n  as the first argument:\n\n      <script type=\"text/x-handlebars\">\n        {{#collection App.MyCustomCollectionClass contentBinding=\"App.items\"}}\n          Hi {{content.name}}\n        {{/collection}}\n      </script>\n\n\n  ### Forwarded `item.*`-named Options\n  As with the `{{view}}`, helper options passed to the `{{collection}}` will be set on\n  the resulting `Ember.CollectionView` as properties. Additionally, options prefixed with\n  `item` will be applied to the views rendered for each item (note the camelcasing):\n\n        <script type=\"text/x-handlebars\">\n          {{#collection contentBinding=\"App.items\"\n                        itemTagName=\"p\"\n                        itemClassNames=\"greeting\"}}\n            Howdy {{content.name}}\n          {{/collection}}\n        </script>\n\n  Will result in the following HTML structure:\n\n      <div class=\"ember-view\">\n        <p class=\"ember-view greeting\">Howdy Dave</p>\n        <p class=\"ember-view greeting\">Howdy Mary</p>\n        <p class=\"ember-view greeting\">Howdy Sara</p>\n      </div>\n  \n  @name Handlebars.helpers.collection\n  @param {String} path\n  @param {Hash} options\n  @returns {String} HTML string\n*/\nEmber.Handlebars.registerHelper('collection', function(path, options) {\n  // If no path is provided, treat path param as options.\n  if (path && path.data && path.data.isRenderData) {\n    options = path;\n    path = undefined;\n    Ember.assert(\"You cannot pass more than one argument to the collection helper\", arguments.length === 1);\n  } else {\n    Ember.assert(\"You cannot pass more than one argument to the collection helper\", arguments.length === 2);\n  }\n\n  var fn = options.fn;\n  var data = options.data;\n  var inverse = options.inverse;\n\n  // If passed a path string, convert that into an object.\n  // Otherwise, just default to the standard class.\n  var collectionClass;\n  collectionClass = path ? getPath(this, path, options) : Ember.CollectionView;\n  Ember.assert(fmt(\"%@ #collection: Could not find collection class %@\", [data.view, path]), !!collectionClass);\n\n  var hash = options.hash, itemHash = {}, match;\n\n  // Extract item view class if provided else default to the standard class\n  var itemViewClass, itemViewPath = hash.itemViewClass;\n  var collectionPrototype = collectionClass.proto();\n  delete hash.itemViewClass;\n  itemViewClass = itemViewPath ? getPath(collectionPrototype, itemViewPath, options) : collectionPrototype.itemViewClass;\n  Ember.assert(fmt(\"%@ #collection: Could not find itemViewClass %@\", [data.view, itemViewPath]), !!itemViewClass);\n\n  // Go through options passed to the {{collection}} helper and extract options\n  // that configure item views instead of the collection itself.\n  for (var prop in hash) {\n    if (hash.hasOwnProperty(prop)) {\n      match = prop.match(/^item(.)(.*)$/);\n\n      if(match) {\n        // Convert itemShouldFoo -> shouldFoo\n        itemHash[match[1].toLowerCase() + match[2]] = hash[prop];\n        // Delete from hash as this will end up getting passed to the\n        // {{view}} helper method.\n        delete hash[prop];\n      }\n    }\n  }\n\n  var tagName = hash.tagName || collectionPrototype.tagName;\n\n  if (fn) {\n    itemHash.template = fn;\n    delete options.fn;\n  }\n\n  var emptyViewClass;\n  if (inverse && inverse !== Handlebars.VM.noop) {\n    emptyViewClass = get(collectionPrototype, 'emptyViewClass');\n    emptyViewClass = emptyViewClass.extend({\n          template: inverse,\n          tagName: itemHash.tagName\n    });\n  } else if (hash.emptyViewClass) {\n    emptyViewClass = getPath(this, hash.emptyViewClass, options);\n  }\n  hash.emptyView = emptyViewClass;\n\n  if (hash.eachHelper === 'each') {\n    itemHash._context = Ember.computed(function() {\n      return get(this, 'content');\n    }).property('content');\n    delete hash.eachHelper;\n  }\n\n  var viewOptions = Ember.Handlebars.ViewHelper.propertiesFromHTMLOptions({ data: data, hash: itemHash }, this);\n  hash.itemViewClass = itemViewClass.extend(viewOptions);\n\n  return Ember.Handlebars.helpers.view.call(this, collectionClass, options);\n});\n\n\n\n\n})();\n//@ sourceURL=ember-handlebars/helpers/collection");