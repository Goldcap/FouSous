minispade.register('ember-handlebars/ext', "(function() {// ==========================================================================\n// Project:   Ember Handlebars Views\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals Handlebars */\nminispade.require(\"ember-views/system/render_buffer\");\n\nvar objectCreate = Ember.create;\n\n/**\n  @namespace\n  @name Handlebars\n  @private\n*/\n\n/**\n  @namespace\n  @name Handlebars.helpers\n  @description Helpers for Handlebars templates\n*/\n\nEmber.assert(\"Ember Handlebars requires Handlebars 1.0.beta.5 or greater\", window.Handlebars && window.Handlebars.VERSION.match(/^1\\.0\\.beta\\.[56789]$|^1\\.0\\.rc\\.[123456789]+/));\n\n/**\n  @class\n\n  Prepares the Handlebars templating library for use inside Ember's view\n  system.\n\n  The Ember.Handlebars object is the standard Handlebars library, extended to use\n  Ember's get() method instead of direct property access, which allows\n  computed properties to be used inside templates.\n\n  To create an Ember.Handlebars template, call Ember.Handlebars.compile().  This will\n  return a function that can be used by Ember.View for rendering.\n*/\nEmber.Handlebars = objectCreate(Handlebars);\n\nEmber.Handlebars.helpers = objectCreate(Handlebars.helpers);\n\n/**\n  Override the the opcode compiler and JavaScript compiler for Handlebars.\n  @private\n*/\nEmber.Handlebars.Compiler = function() {};\nEmber.Handlebars.Compiler.prototype = objectCreate(Handlebars.Compiler.prototype);\nEmber.Handlebars.Compiler.prototype.compiler = Ember.Handlebars.Compiler;\n\n/** @private */\nEmber.Handlebars.JavaScriptCompiler = function() {};\nEmber.Handlebars.JavaScriptCompiler.prototype = objectCreate(Handlebars.JavaScriptCompiler.prototype);\nEmber.Handlebars.JavaScriptCompiler.prototype.compiler = Ember.Handlebars.JavaScriptCompiler;\nEmber.Handlebars.JavaScriptCompiler.prototype.namespace = \"Ember.Handlebars\";\n\n\nEmber.Handlebars.JavaScriptCompiler.prototype.initializeBuffer = function() {\n  return \"''\";\n};\n\n/**\n  Override the default buffer for Ember Handlebars. By default, Handlebars creates\n  an empty String at the beginning of each invocation and appends to it. Ember's\n  Handlebars overrides this to append to a single shared buffer.\n\n  @private\n*/\nEmber.Handlebars.JavaScriptCompiler.prototype.appendToBuffer = function(string) {\n  return \"data.buffer.push(\"+string+\");\";\n};\n\n/**\n  Rewrite simple mustaches from {{foo}} to {{bind \"foo\"}}. This means that all simple\n  mustaches in Ember's Handlebars will also set up an observer to keep the DOM\n  up to date when the underlying property changes.\n\n  @private\n*/\nEmber.Handlebars.Compiler.prototype.mustache = function(mustache) {\n  if (mustache.params.length || mustache.hash) {\n    return Handlebars.Compiler.prototype.mustache.call(this, mustache);\n  } else {\n    var id = new Handlebars.AST.IdNode(['_triageMustache']);\n\n    // Update the mustache node to include a hash value indicating whether the original node\n    // was escaped. This will allow us to properly escape values when the underlying value\n    // changes and we need to re-render the value.\n    if(!mustache.escaped) {\n      mustache.hash = mustache.hash || new Handlebars.AST.HashNode([]);\n      mustache.hash.pairs.push([\"unescaped\", new Handlebars.AST.StringNode(\"true\")]);\n    }\n    mustache = new Handlebars.AST.MustacheNode([id].concat([mustache.id]), mustache.hash, !mustache.escaped);\n    return Handlebars.Compiler.prototype.mustache.call(this, mustache);\n  }\n};\n\n/**\n  Used for precompilation of Ember Handlebars templates. This will not be used during normal\n  app execution.\n\n  @param {String} string The template to precompile\n*/\nEmber.Handlebars.precompile = function(string) {\n  var ast = Handlebars.parse(string);\n\n  var options = {\n    knownHelpers: {\n      action: true,\n      unbound: true,\n      bindAttr: true,\n      template: true,\n      view: true,\n      _triageMustache: true\n    },\n    data: true,\n    stringParams: true\n  };\n\n  var environment = new Ember.Handlebars.Compiler().compile(ast, options);\n  return new Ember.Handlebars.JavaScriptCompiler().compile(environment, options, undefined, true);\n};\n\n/**\n  The entry point for Ember Handlebars. This replaces the default Handlebars.compile and turns on\n  template-local data and String parameters.\n\n  @param {String} string The template to compile\n*/\nEmber.Handlebars.compile = function(string) {\n  var ast = Handlebars.parse(string);\n  var options = { data: true, stringParams: true };\n  var environment = new Ember.Handlebars.Compiler().compile(ast, options);\n  var templateSpec = new Ember.Handlebars.JavaScriptCompiler().compile(environment, options, undefined, true);\n\n  return Handlebars.template(templateSpec);\n};\n\n/**\n  If a path starts with a reserved keyword, returns the root\n  that should be used.\n\n  @private\n*/\nvar normalizePath = Ember.Handlebars.normalizePath = function(root, path, data) {\n  var keywords = (data && data.keywords) || {},\n      keyword, isKeyword;\n\n  // Get the first segment of the path. For example, if the\n  // path is \"foo.bar.baz\", returns \"foo\".\n  keyword = path.split('.', 1)[0];\n\n  // Test to see if the first path is a keyword that has been\n  // passed along in the view's data hash. If so, we will treat\n  // that object as the new root.\n  if (keywords.hasOwnProperty(keyword)) {\n    // Look up the value in the template's data hash.\n    root = keywords[keyword];\n    isKeyword = true;\n\n    // Handle cases where the entire path is the reserved\n    // word. In that case, return the object itself.\n    if (path === keyword) {\n      path = '';\n    } else {\n      // Strip the keyword from the path and look up\n      // the remainder from the newly found root.\n      path = path.substr(keyword.length+1);\n    }\n  }\n\n  return { root: root, path: path, isKeyword: isKeyword };\n};\n/**\n  Lookup both on root and on window. If the path starts with\n  a keyword, the corresponding object will be looked up in the\n  template's data hash and used to resolve the path.\n\n  @param {Object} root The object to look up the property on\n  @param {String} path The path to be lookedup\n  @param {Object} options The template's option hash\n*/\n\nEmber.Handlebars.getPath = function(root, path, options) {\n  var data = options && options.data,\n      normalizedPath = normalizePath(root, path, data),\n      value;\n\n  // In cases where the path begins with a keyword, change the\n  // root to the value represented by that keyword, and ensure\n  // the path is relative to it.\n  root = normalizedPath.root;\n  path = normalizedPath.path;\n\n  value = Ember.get(root, path);\n\n  if (value === undefined && root !== window && Ember.isGlobalPath(path)) {\n    value = Ember.get(window, path);\n  }\n  return value;\n};\n\n/**\n  Registers a helper in Handlebars that will be called if no property with the\n  given name can be found on the current context object, and no helper with\n  that name is registered.\n\n  This throws an exception with a more helpful error message so the user can\n  track down where the problem is happening.\n\n  @name Handlebars.helpers.helperMissing\n  @param {String} path\n  @param {Hash} options\n*/\nEmber.Handlebars.registerHelper('helperMissing', function(path, options) {\n  var error, view = \"\";\n\n  error = \"%@ Handlebars error: Could not find property '%@' on object %@.\";\n  if (options.data){\n    view = options.data.view;\n  }\n  throw new Ember.Error(Ember.String.fmt(error, [view, path, this]));\n});\n\n\n})();\n//@ sourceURL=ember-handlebars/ext");