minispade.register('ember-metal/run_loop', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            Portions ©2008-2010 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-metal/core'); // Ember.Logger\nminispade.require('ember-metal/watching'); // Ember.watch.flushPending\nminispade.require('ember-metal/observer'); // Ember.beginPropertyChanges, Ember.endPropertyChanges\nminispade.require('ember-metal/utils'); // Ember.guidFor\n\n// ..........................................................\n// HELPERS\n//\n\nvar slice = [].slice,\n    forEach = Ember.ArrayPolyfills.forEach;\n\n// invokes passed params - normalizing so you can pass target/func,\n// target/string or just func\n/** @private */\nfunction invoke(target, method, args, ignore) {\n\n  if (method === undefined) {\n    method = target;\n    target = undefined;\n  }\n\n  if ('string' === typeof method) { method = target[method]; }\n  if (args && ignore > 0) {\n    args = args.length > ignore ? slice.call(args, ignore) : null;\n  }\n\n  // Unfortunately in some browsers we lose the backtrace if we rethrow the existing error,\n  // so in the event that we don't have an `onerror` handler we don't wrap in a try/catch\n  if ('function' === typeof Ember.onerror) {\n    try {\n      // IE8's Function.prototype.apply doesn't accept undefined/null arguments.\n      return method.apply(target || this, args || []);\n    } catch (error) {\n      Ember.onerror(error);\n    }\n  } else {\n    // IE8's Function.prototype.apply doesn't accept undefined/null arguments.\n    return method.apply(target || this, args || []);\n  }\n}\n\n\n// ..........................................................\n// RUNLOOP\n//\n\nvar timerMark; // used by timers...\n\n/** @private */\nvar RunLoop = function(prev) {\n  this._prev = prev || null;\n  this.onceTimers = {};\n};\n\nRunLoop.prototype = {\n  end: function() {\n    this.flush();\n  },\n\n  prev: function() {\n    return this._prev;\n  },\n\n  // ..........................................................\n  // Delayed Actions\n  //\n\n  schedule: function(queueName, target, method) {\n    var queues = this._queues, queue;\n    if (!queues) { queues = this._queues = {}; }\n    queue = queues[queueName];\n    if (!queue) { queue = queues[queueName] = []; }\n\n    var args = arguments.length > 3 ? slice.call(arguments, 3) : null;\n    queue.push({ target: target, method: method, args: args });\n    return this;\n  },\n\n  flush: function(queueName) {\n    var queueNames, idx, len, queue, log;\n\n    if (!this._queues) { return this; } // nothing to do\n\n    function iter(item) {\n      invoke(item.target, item.method, item.args);\n    }\n\n    Ember.watch.flushPending(); // make sure all chained watchers are setup\n\n    if (queueName) {\n      while (this._queues && (queue = this._queues[queueName])) {\n        this._queues[queueName] = null;\n\n        // the sync phase is to allow property changes to propagate.  don't\n        // invoke observers until that is finished.\n        if (queueName === 'sync') {\n          log = Ember.LOG_BINDINGS;\n          if (log) { Ember.Logger.log('Begin: Flush Sync Queue'); }\n\n          Ember.beginPropertyChanges();\n          try {\n            forEach.call(queue, iter);\n          } finally {\n            Ember.endPropertyChanges();\n          }\n\n          if (log) { Ember.Logger.log('End: Flush Sync Queue'); }\n\n        } else {\n          forEach.call(queue, iter);\n        }\n      }\n\n    } else {\n      queueNames = Ember.run.queues;\n      len = queueNames.length;\n      idx = 0;\n\n      outerloop:\n      while (idx < len) {\n        queueName = queueNames[idx];\n        queue = this._queues && this._queues[queueName];\n        delete this._queues[queueName];\n\n        if (queue) {\n          // the sync phase is to allow property changes to propagate.  don't\n          // invoke observers until that is finished.\n          if (queueName === 'sync') {\n            log = Ember.LOG_BINDINGS;\n            if (log) { Ember.Logger.log('Begin: Flush Sync Queue'); }\n\n            Ember.beginPropertyChanges();\n            try {\n              forEach.call(queue, iter);\n            } finally {\n              Ember.endPropertyChanges();\n            }\n\n            if (log) { Ember.Logger.log('End: Flush Sync Queue'); }\n          } else {\n            forEach.call(queue, iter);\n          }\n        }\n\n        // Loop through prior queues\n        for (var i = 0; i <= idx; i++) {\n          if (this._queues && this._queues[queueNames[i]]) {\n            // Start over at the first queue with contents\n            idx = i;\n            continue outerloop;\n          }\n        }\n\n        idx++;\n      }\n    }\n\n    timerMark = null;\n\n    return this;\n  }\n\n};\n\nEmber.RunLoop = RunLoop;\n\n// ..........................................................\n// Ember.run - this is ideally the only public API the dev sees\n//\n/**\n* @namespace Ember.run is both a function and a namespace for\n* RunLoop-related functions.\n* @name Ember.run\n*/\n\n/**\n  Runs the passed target and method inside of a RunLoop, ensuring any\n  deferred actions including bindings and views updates are flushed at the\n  end.\n\n  Normally you should not need to invoke this method yourself.  However if\n  you are implementing raw event handlers when interfacing with other\n  libraries or plugins, you should probably wrap all of your code inside this\n  call.\n\n      Ember.run(function(){\n        // code to be execute within a RunLoop \n      });\n\n  @name run\n  @methodOf Ember.run\n  @param {Object} target\n    (Optional) target of method to call\n\n  @param {Function|String} method\n    Method to invoke.  May be a function or a string.  If you pass a string\n    then it will be looked up on the passed target.\n\n  @param {Object...} args\n    Any additional arguments you wish to pass to the method.\n\n  @returns {Object} return value from invoking the passed function.\n*/\nEmber.run = function(target, method) {\n  var ret, loop;\n  run.begin();\n  try {\n    if (target || method) { ret = invoke(target, method, arguments, 2); }\n  } finally {\n    run.end();\n  }\n  return ret;\n};\n\n/** @private */\nvar run = Ember.run;\n\n\n/**\n  Begins a new RunLoop.  Any deferred actions invoked after the begin will\n  be buffered until you invoke a matching call to Ember.run.end().  This is\n  an lower-level way to use a RunLoop instead of using Ember.run().\n\n      Ember.run.begin();\n      // code to be execute within a RunLoop \n      Ember.run.end();\n\n\n  @returns {void}\n*/\nEmber.run.begin = function() {\n  run.currentRunLoop = new RunLoop(run.currentRunLoop);\n};\n\n/**\n  Ends a RunLoop.  This must be called sometime after you call Ember.run.begin()\n  to flush any deferred actions.  This is a lower-level way to use a RunLoop\n  instead of using Ember.run().\n\n      Ember.run.begin();\n      // code to be execute within a RunLoop \n      Ember.run.end();\n\n  @returns {void}\n*/\nEmber.run.end = function() {\n  Ember.assert('must have a current run loop', run.currentRunLoop);\n  try {\n    run.currentRunLoop.end();\n  }\n  finally {\n    run.currentRunLoop = run.currentRunLoop.prev();\n  }\n};\n\n/**\n  Array of named queues.  This array determines the order in which queues\n  are flushed at the end of the RunLoop.  You can define your own queues by\n  simply adding the queue name to this array.  Normally you should not need\n  to inspect or modify this property.\n\n  @type Array\n  @default ['sync', 'actions', 'destroy', 'timers']\n*/\nEmber.run.queues = ['sync', 'actions', 'destroy', 'timers'];\n\n/**\n  Adds the passed target/method and any optional arguments to the named\n  queue to be executed at the end of the RunLoop.  If you have not already\n  started a RunLoop when calling this method one will be started for you\n  automatically.\n\n  At the end of a RunLoop, any methods scheduled in this way will be invoked.\n  Methods will be invoked in an order matching the named queues defined in\n  the run.queues property.\n\n      Ember.run.schedule('timers', this, function(){\n        // this will be executed at the end of the RunLoop, when timers are run\n        console.log(\"scheduled on timers queue\");\n      });\n      Ember.run.schedule('sync', this, function(){\n        // this will be executed at the end of the RunLoop, when bindings are synced\n        console.log(\"scheduled on sync queue\");\n      });\n      // Note the functions will be run in order based on the run queues order. Output would be:\n      //   scheduled on sync queue\n      //   scheduled on timers queue\n\n  @param {String} queue\n    The name of the queue to schedule against.  Default queues are 'sync' and\n    'actions'\n\n  @param {Object} target\n    (Optional) target object to use as the context when invoking a method.\n\n  @param {String|Function} method\n    The method to invoke.  If you pass a string it will be resolved on the\n    target object at the time the scheduled item is invoked allowing you to\n    change the target function.\n\n  @param {Object} arguments...\n    Optional arguments to be passed to the queued method.\n\n  @returns {void}\n*/\nEmber.run.schedule = function(queue, target, method) {\n  var loop = run.autorun();\n  loop.schedule.apply(loop, arguments);\n};\n\nvar scheduledAutorun;\n/** @private */\nfunction autorun() {\n  scheduledAutorun = null;\n  if (run.currentRunLoop) { run.end(); }\n}\n\n// Used by global test teardown\n/** @private */\nEmber.run.hasScheduledTimers = function() {\n  return !!(scheduledAutorun || scheduledLater || scheduledNext);\n};\n\n// Used by global test teardown\n/** @private */\nEmber.run.cancelTimers = function () {\n  if (scheduledAutorun) {\n    clearTimeout(scheduledAutorun);\n    scheduledAutorun = null;\n  }\n  if (scheduledLater) {\n    clearTimeout(scheduledLater);\n    scheduledLater = null;\n  }\n  if (scheduledNext) {\n    clearTimeout(scheduledNext);\n    scheduledNext = null;\n  }\n  timers = {};\n};\n\n/**\n  Begins a new RunLoop if necessary and schedules a timer to flush the\n  RunLoop at a later time.  This method is used by parts of Ember to\n  ensure the RunLoop always finishes.  You normally do not need to call this\n  method directly.  Instead use Ember.run().\n\n      Ember.run.autorun();\n\n  @returns {Ember.RunLoop} the new current RunLoop\n*/\nEmber.run.autorun = function() {\n  if (!run.currentRunLoop) {\n    Ember.assert(\"You have turned on testing mode, which disabled the run-loop's autorun. You will need to wrap any code with asynchronous side-effects in an Ember.run\", !Ember.testing);\n\n    run.begin();\n\n    if (!scheduledAutorun) {\n      scheduledAutorun = setTimeout(autorun, 1);\n    }\n  }\n\n  return run.currentRunLoop;\n};\n\n/**\n  Immediately flushes any events scheduled in the 'sync' queue.  Bindings\n  use this queue so this method is a useful way to immediately force all\n  bindings in the application to sync.\n\n  You should call this method anytime you need any changed state to propagate\n  throughout the app immediately without repainting the UI.\n\n      Ember.run.sync();\n\n  @returns {void}\n*/\nEmber.run.sync = function() {\n  run.autorun();\n  run.currentRunLoop.flush('sync');\n};\n\n// ..........................................................\n// TIMERS\n//\n\nvar timers = {}; // active timers...\n\nvar scheduledLater;\n/** @private */\nfunction invokeLaterTimers() {\n  scheduledLater = null;\n  var now = (+ new Date()), earliest = -1;\n  for (var key in timers) {\n    if (!timers.hasOwnProperty(key)) { continue; }\n    var timer = timers[key];\n    if (timer && timer.expires) {\n      if (now >= timer.expires) {\n        delete timers[key];\n        invoke(timer.target, timer.method, timer.args, 2);\n      } else {\n        if (earliest<0 || (timer.expires < earliest)) earliest=timer.expires;\n      }\n    }\n  }\n\n  // schedule next timeout to fire...\n  if (earliest > 0) { scheduledLater = setTimeout(invokeLaterTimers, earliest-(+ new Date())); }\n}\n\n/**\n  Invokes the passed target/method and optional arguments after a specified\n  period if time.  The last parameter of this method must always be a number\n  of milliseconds.\n\n  You should use this method whenever you need to run some action after a\n  period of time instead of using setTimeout().  This method will ensure that\n  items that expire during the same script execution cycle all execute\n  together, which is often more efficient than using a real setTimeout.\n\n      Ember.run.later(myContext, function(){\n        // code here will execute within a RunLoop in about 500ms with this == myContext\n      }, 500);\n\n  @param {Object} target\n    (optional) target of method to invoke\n\n  @param {Function|String} method\n    The method to invoke.  If you pass a string it will be resolved on the\n    target at the time the method is invoked.\n\n  @param {Object...} args\n    Optional arguments to pass to the timeout.\n\n  @param {Number} wait\n    Number of milliseconds to wait.\n\n  @returns {String} a string you can use to cancel the timer in Ember.run.cancel() later.\n*/\nEmber.run.later = function(target, method) {\n  var args, expires, timer, guid, wait;\n\n  // setTimeout compatibility...\n  if (arguments.length===2 && 'function' === typeof target) {\n    wait   = method;\n    method = target;\n    target = undefined;\n    args   = [target, method];\n  } else {\n    args = slice.call(arguments);\n    wait = args.pop();\n  }\n\n  expires = (+ new Date()) + wait;\n  timer   = { target: target, method: method, expires: expires, args: args };\n  guid    = Ember.guidFor(timer);\n  timers[guid] = timer;\n  run.once(timers, invokeLaterTimers);\n  return guid;\n};\n\n/** @private */\nfunction invokeOnceTimer(guid, onceTimers) {\n  if (onceTimers[this.tguid]) { delete onceTimers[this.tguid][this.mguid]; }\n  if (timers[guid]) { invoke(this.target, this.method, this.args, 2); }\n  delete timers[guid];\n}\n\nfunction scheduleOnce(queue, target, method, args) {\n  var tguid = Ember.guidFor(target),\n    mguid = Ember.guidFor(method),\n    onceTimers = run.autorun().onceTimers,\n    guid = onceTimers[tguid] && onceTimers[tguid][mguid],\n    timer;\n\n  if (guid && timers[guid]) {\n    timers[guid].args = args; // replace args\n  } else {\n    timer = {\n      target: target,\n      method: method,\n      args:   args,\n      tguid:  tguid,\n      mguid:  mguid\n    };\n\n    guid  = Ember.guidFor(timer);\n    timers[guid] = timer;\n    if (!onceTimers[tguid]) { onceTimers[tguid] = {}; }\n    onceTimers[tguid][mguid] = guid; // so it isn't scheduled more than once\n\n    run.schedule(queue, timer, invokeOnceTimer, guid, onceTimers);\n  }\n\n  return guid;\n}\n\n/**\n  Schedules an item to run one time during the current RunLoop.  Calling\n  this method with the same target/method combination will have no effect.\n\n  Note that although you can pass optional arguments these will not be\n  considered when looking for duplicates.  New arguments will replace previous\n  calls.\n\n      Ember.run(function(){\n        var doFoo = function() { foo(); }\n        Ember.run.once(myContext, doFoo);\n        Ember.run.once(myContext, doFoo);\n        // doFoo will only be executed once at the end of the RunLoop\n      });\n\n  @param {Object} target\n    (optional) target of method to invoke\n\n  @param {Function|String} method\n    The method to invoke.  If you pass a string it will be resolved on the\n    target at the time the method is invoked.\n\n  @param {Object...} args\n    Optional arguments to pass to the timeout.\n\n\n  @returns {Object} timer\n*/\nEmber.run.once = function(target, method) {\n  return scheduleOnce('actions', target, method, slice.call(arguments));\n};\n\nEmber.run.scheduleOnce = function(queue, target, method) {\n  return scheduleOnce(queue, target, method, slice.call(arguments));\n};\n\nvar scheduledNext;\n/** @private */\nfunction invokeNextTimers() {\n  scheduledNext = null;\n  for(var key in timers) {\n    if (!timers.hasOwnProperty(key)) { continue; }\n    var timer = timers[key];\n    if (timer.next) {\n      delete timers[key];\n      invoke(timer.target, timer.method, timer.args, 2);\n    }\n  }\n}\n\n/**\n  Schedules an item to run after control has been returned to the system.\n  This is often equivalent to calling setTimeout(function...,1).\n\n      Ember.run.next(myContext, function(){\n        // code to be executed in the next RunLoop, which will be scheduled after the current one\n      });\n\n  @param {Object} target\n    (optional) target of method to invoke\n\n  @param {Function|String} method\n    The method to invoke.  If you pass a string it will be resolved on the\n    target at the time the method is invoked.\n\n  @param {Object...} args\n    Optional arguments to pass to the timeout.\n\n  @returns {Object} timer\n*/\nEmber.run.next = function(target, method) {\n  var guid,\n      timer = {\n        target: target,\n        method: method,\n        args: slice.call(arguments),\n        next: true\n      };\n\n  guid = Ember.guidFor(timer);\n  timers[guid] = timer;\n\n  if (!scheduledNext) { scheduledNext = setTimeout(invokeNextTimers, 1); }\n  return guid;\n};\n\n/**\n  Cancels a scheduled item.  Must be a value returned by `Ember.run.later()`,\n  `Ember.run.once()`, or `Ember.run.next()`.\n\n      var runNext = Ember.run.next(myContext, function(){\n        // will not be executed\n      });\n      Ember.run.cancel(runNext);\n\n      var runLater = Ember.run.later(myContext, function(){\n        // will not be executed\n      }, 500);\n      Ember.run.cancel(runLater);\n\n      var runOnce = Ember.run.once(myContext, function(){\n        // will not be executed\n      });\n      Ember.run.cancel(runOnce);\n\n  @param {Object} timer\n    Timer object to cancel\n\n  @returns {void}\n*/\nEmber.run.cancel = function(timer) {\n  delete timers[timer];\n};\n\n})();\n//@ sourceURL=ember-metal/run_loop");