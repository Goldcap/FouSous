minispade.register('ember-metal/binding', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-metal/core'); // Ember.Logger\nminispade.require('ember-metal/accessors'); // get, set, trySet\nminispade.require('ember-metal/utils'); // guidFor, isArray, meta\nminispade.require('ember-metal/observer'); // addObserver, removeObserver\nminispade.require('ember-metal/run_loop'); // Ember.run.schedule\nminispade.require('ember-metal/map');\n\n// ..........................................................\n// CONSTANTS\n//\n\n/**\n  @static\n\n  Debug parameter you can turn on. This will log all bindings that fire to\n  the console. This should be disabled in production code. Note that you\n  can also enable this from the console or temporarily.\n\n  @type Boolean\n  @default false\n*/\nEmber.LOG_BINDINGS = false || !!Ember.ENV.LOG_BINDINGS;\n\nvar get     = Ember.get,\n    set     = Ember.set,\n    guidFor = Ember.guidFor,\n    isGlobalPath = Ember.isGlobalPath;\n\n\n/** @private */\nfunction getWithGlobals(obj, path) {\n  return get(isGlobalPath(path) ? window : obj, path);\n}\n\n// ..........................................................\n// BINDING\n//\n\n/** @private */\nvar Binding = function(toPath, fromPath) {\n  this._direction = 'fwd';\n  this._from = fromPath;\n  this._to   = toPath;\n  this._directionMap = Ember.Map.create();\n};\n\nBinding.prototype = /** @scope Ember.Binding.prototype */ {\n  /**\n    This copies the Binding so it can be connected to another object.\n    @returns {Ember.Binding}\n  */\n  copy: function () {\n    var copy = new Binding(this._to, this._from);\n    if (this._oneWay) { copy._oneWay = true; }\n    return copy;\n  },\n\n  // ..........................................................\n  // CONFIG\n  //\n\n  /**\n    This will set \"from\" property path to the specified value. It will not\n    attempt to resolve this property path to an actual object until you\n    connect the binding.\n\n    The binding will search for the property path starting at the root object\n    you pass when you connect() the binding.  It follows the same rules as\n    `get()` - see that method for more information.\n\n    @param {String} propertyPath the property path to connect to\n    @returns {Ember.Binding} receiver\n  */\n  from: function(path) {\n    this._from = path;\n    return this;\n  },\n\n  /**\n    This will set the \"to\" property path to the specified value. It will not\n    attempt to resolve this property path to an actual object until you\n    connect the binding.\n\n    The binding will search for the property path starting at the root object\n    you pass when you connect() the binding.  It follows the same rules as\n    `get()` - see that method for more information.\n\n    @param {String|Tuple} propertyPath A property path or tuple\n    @returns {Ember.Binding} this\n  */\n  to: function(path) {\n    this._to = path;\n    return this;\n  },\n\n  /**\n    Configures the binding as one way. A one-way binding will relay changes\n    on the \"from\" side to the \"to\" side, but not the other way around. This\n    means that if you change the \"to\" side directly, the \"from\" side may have\n    a different value.\n\n    @returns {Ember.Binding} receiver\n  */\n  oneWay: function() {\n    this._oneWay = true;\n    return this;\n  },\n\n  /** @private */\n  toString: function() {\n    var oneWay = this._oneWay ? '[oneWay]' : '';\n    return \"Ember.Binding<\" + guidFor(this) + \">(\" + this._from + \" -> \" + this._to + \")\" + oneWay;\n  },\n\n  // ..........................................................\n  // CONNECT AND SYNC\n  //\n\n  /**\n    Attempts to connect this binding instance so that it can receive and relay\n    changes. This method will raise an exception if you have not set the\n    from/to properties yet.\n\n    @param {Object} obj The root object for this binding.\n    @returns {Ember.Binding} this\n  */\n  connect: function(obj) {\n    Ember.assert('Must pass a valid object to Ember.Binding.connect()', !!obj);\n\n    var fromPath = this._from, toPath = this._to;\n    Ember.trySet(obj, toPath, getWithGlobals(obj, fromPath));\n\n    // add an observer on the object to be notified when the binding should be updated\n    Ember.addObserver(obj, fromPath, this, this.fromDidChange);\n\n    // if the binding is a two-way binding, also set up an observer on the target\n    if (!this._oneWay) { Ember.addObserver(obj, toPath, this, this.toDidChange); }\n\n    this._readyToSync = true;\n\n    return this;\n  },\n\n  /**\n    Disconnects the binding instance. Changes will no longer be relayed. You\n    will not usually need to call this method.\n\n    @param {Object} obj\n      The root object you passed when connecting the binding.\n\n    @returns {Ember.Binding} this\n  */\n  disconnect: function(obj) {\n    Ember.assert('Must pass a valid object to Ember.Binding.disconnect()', !!obj);\n\n    var twoWay = !this._oneWay;\n\n    // remove an observer on the object so we're no longer notified of\n    // changes that should update bindings.\n    Ember.removeObserver(obj, this._from, this, this.fromDidChange);\n\n    // if the binding is two-way, remove the observer from the target as well\n    if (twoWay) { Ember.removeObserver(obj, this._to, this, this.toDidChange); }\n\n    this._readyToSync = false; // disable scheduled syncs...\n    return this;\n  },\n\n  // ..........................................................\n  // PRIVATE\n  //\n\n  /** @private - called when the from side changes */\n  fromDidChange: function(target) {\n    this._scheduleSync(target, 'fwd');\n  },\n\n  /** @private - called when the to side changes */\n  toDidChange: function(target) {\n    this._scheduleSync(target, 'back');\n  },\n\n  /** @private */\n  _scheduleSync: function(obj, dir) {\n    var directionMap = this._directionMap;\n    var existingDir = directionMap.get(obj);\n\n    // if we haven't scheduled the binding yet, schedule it\n    if (!existingDir) {\n      Ember.run.schedule('sync', this, this._sync, obj);\n      directionMap.set(obj, dir);\n    }\n\n    // If both a 'back' and 'fwd' sync have been scheduled on the same object,\n    // default to a 'fwd' sync so that it remains deterministic.\n    if (existingDir === 'back' && dir === 'fwd') {\n      directionMap.set(obj, 'fwd');\n    }\n  },\n\n  /** @private */\n  _sync: function(obj) {\n    var log = Ember.LOG_BINDINGS;\n\n    // don't synchronize destroyed objects or disconnected bindings\n    if (obj.isDestroyed || !this._readyToSync) { return; }\n\n    // get the direction of the binding for the object we are\n    // synchronizing from\n    var directionMap = this._directionMap;\n    var direction = directionMap.get(obj);\n\n    var fromPath = this._from, toPath = this._to;\n\n    directionMap.remove(obj);\n\n    // if we're synchronizing from the remote object...\n    if (direction === 'fwd') {\n      var fromValue = getWithGlobals(obj, this._from);\n      if (log) {\n        Ember.Logger.log(' ', this.toString(), '->', fromValue, obj);\n      }\n      if (this._oneWay) {\n        Ember.trySet(obj, toPath, fromValue);\n      } else {\n        Ember._suspendObserver(obj, toPath, this, this.toDidChange, function () {\n          Ember.trySet(obj, toPath, fromValue);\n        });\n      }\n    // if we're synchronizing *to* the remote object\n    } else if (direction === 'back') {\n      var toValue = get(obj, this._to);\n      if (log) {\n        Ember.Logger.log(' ', this.toString(), '<-', toValue, obj);\n      }\n      Ember._suspendObserver(obj, fromPath, this, this.fromDidChange, function () {\n        Ember.trySet(Ember.isGlobalPath(fromPath) ? window : obj, fromPath, toValue);\n      });\n    }\n  }\n\n};\n\n/** @private */\nfunction mixinProperties(to, from) {\n  for (var key in from) {\n    if (from.hasOwnProperty(key)) {\n      to[key] = from[key];\n    }\n  }\n}\n\nmixinProperties(Binding,\n/** @scope Ember.Binding */ {\n\n  /**\n    @see Ember.Binding.prototype.from\n  */\n  from: function() {\n    var C = this, binding = new C();\n    return binding.from.apply(binding, arguments);\n  },\n\n  /**\n    @see Ember.Binding.prototype.to\n  */\n  to: function() {\n    var C = this, binding = new C();\n    return binding.to.apply(binding, arguments);\n  },\n\n  /**\n    Creates a new Binding instance and makes it apply in a single direction.\n    A one-way binding will relay changes on the \"from\" side object (supplies\n    as the `from` argument) the \"to\" side, but not the other way around.\n    This means that if you change the \"to\" side directly, the \"from\" side may have\n    a different value.\n\n    @param {String} from from path.\n    @param {Boolean} [flag] (Optional) passing nothing here will make the binding oneWay.  You can\n    instead pass false to disable oneWay, making the binding two way again.\n\n    @see Ember.Binding.prototype.oneWay\n  */\n  oneWay: function(from, flag) {\n    var C = this, binding = new C(null, from);\n    return binding.oneWay(flag);\n  }\n\n});\n\n/**\n  @class\n\n  An Ember.Binding connects the properties of two objects so that whenever the\n  value of one property changes, the other property will be changed also.\n\n  ## Automatic Creation of Bindings with `/^*Binding/`-named Properties\n  You do not usually create Binding objects directly but instead describe\n  bindings in your class or object definition using automatic binding detection.\n\n  Properties ending in a `Binding` suffix will be converted to Ember.Binding instances.\n  The value of this property should be a string representing a path to another object or\n  a custom binding instanced created using Binding helpers (see \"Customizing Your Bindings\"):\n\n      valueBinding: \"MyApp.someController.title\"\n\n  This will create a binding from `MyApp.someController.title` to the `value`\n  property of your object instance automatically. Now the two values will be\n  kept in sync.\n\n  ## One Way Bindings\n\n  One especially useful binding customization you can use is the `oneWay()`\n  helper. This helper tells Ember that you are only interested in\n  receiving changes on the object you are binding from. For example, if you\n  are binding to a preference and you want to be notified if the preference\n  has changed, but your object will not be changing the preference itself, you\n  could do:\n\n      bigTitlesBinding: Ember.Binding.oneWay(\"MyApp.preferencesController.bigTitles\")\n\n  This way if the value of MyApp.preferencesController.bigTitles changes the\n  \"bigTitles\" property of your object will change also. However, if you\n  change the value of your \"bigTitles\" property, it will not update the\n  preferencesController.\n\n  One way bindings are almost twice as fast to setup and twice as fast to\n  execute because the binding only has to worry about changes to one side.\n\n  You should consider using one way bindings anytime you have an object that\n  may be created frequently and you do not intend to change a property; only\n  to monitor it for changes. (such as in the example above).\n\n  ## Adding Bindings Manually\n\n  All of the examples above show you how to configure a custom binding, but\n  the result of these customizations will be a binding template, not a fully\n  active Binding instance. The binding will actually become active only when you\n  instantiate the object the binding belongs to. It is useful however, to\n  understand what actually happens when the binding is activated.\n\n  For a binding to function it must have at least a \"from\" property and a \"to\"\n  property. The from property path points to the object/key that you want to\n  bind from while the to path points to the object/key you want to bind to.\n\n  When you define a custom binding, you are usually describing the property\n  you want to bind from (such as \"MyApp.someController.value\" in the examples\n  above). When your object is created, it will automatically assign the value\n  you want to bind \"to\" based on the name of your binding key. In the\n  examples above, during init, Ember objects will effectively call\n  something like this on your binding:\n\n      binding = Ember.Binding.from(this.valueBinding).to(\"value\");\n\n  This creates a new binding instance based on the template you provide, and\n  sets the to path to the \"value\" property of the new object. Now that the\n  binding is fully configured with a \"from\" and a \"to\", it simply needs to be\n  connected to become active. This is done through the connect() method:\n\n      binding.connect(this);\n\n  Note that when you connect a binding you pass the object you want it to be\n  connected to.  This object will be used as the root for both the from and\n  to side of the binding when inspecting relative paths.  This allows the\n  binding to be automatically inherited by subclassed objects as well.\n\n  Now that the binding is connected, it will observe both the from and to side\n  and relay changes.\n\n  If you ever needed to do so (you almost never will, but it is useful to\n  understand this anyway), you could manually create an active binding by\n  using the Ember.bind() helper method. (This is the same method used by\n  to setup your bindings on objects):\n\n      Ember.bind(MyApp.anotherObject, \"value\", \"MyApp.someController.value\");\n\n  Both of these code fragments have the same effect as doing the most friendly\n  form of binding creation like so:\n\n      MyApp.anotherObject = Ember.Object.create({\n        valueBinding: \"MyApp.someController.value\",\n\n        // OTHER CODE FOR THIS OBJECT...\n\n      });\n\n  Ember's built in binding creation method makes it easy to automatically\n  create bindings for you. You should always use the highest-level APIs\n  available, even if you understand how it works underneath.\n\n  @since Ember 0.9\n*/\nEmber.Binding = Binding;\n\n/**\n  Global helper method to create a new binding.  Just pass the root object\n  along with a to and from path to create and connect the binding.\n\n  @param {Object} obj\n    The root object of the transform.\n\n  @param {String} to\n    The path to the 'to' side of the binding.  Must be relative to obj.\n\n  @param {String} from\n    The path to the 'from' side of the binding.  Must be relative to obj or\n    a global path.\n\n  @returns {Ember.Binding} binding instance\n*/\nEmber.bind = function(obj, to, from) {\n  return new Ember.Binding(to, from).connect(obj);\n};\n\nEmber.oneWay = function(obj, to, from) {\n  return new Ember.Binding(to, from).oneWay().connect(obj);\n};\n\n})();\n//@ sourceURL=ember-metal/binding");