minispade.register('ember-metal/mixin', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-metal/core');\nminispade.require('ember-metal/accessors');\nminispade.require('ember-metal/computed');\nminispade.require('ember-metal/properties');\nminispade.require('ember-metal/observer');\nminispade.require('ember-metal/utils');\nminispade.require('ember-metal/array');\nminispade.require('ember-metal/binding');\n\nvar Mixin, REQUIRED, Alias,\n    classToString, superClassString,\n    a_map = Ember.ArrayPolyfills.map,\n    a_indexOf = Ember.ArrayPolyfills.indexOf,\n    a_forEach = Ember.ArrayPolyfills.forEach,\n    a_slice = [].slice,\n    EMPTY_META = {}, // dummy for non-writable meta\n    META_SKIP = { __emberproto__: true, __ember_count__: true },\n    o_create = Ember.create,\n    defineProperty = Ember.defineProperty,\n    guidFor = Ember.guidFor;\n\n/** @private */\nfunction mixinsMeta(obj) {\n  var m = Ember.meta(obj, true), ret = m.mixins;\n  if (!ret) {\n    ret = m.mixins = { __emberproto__: obj };\n  } else if (ret.__emberproto__ !== obj) {\n    ret = m.mixins = o_create(ret);\n    ret.__emberproto__ = obj;\n  }\n  return ret;\n}\n\n/** @private */\nfunction initMixin(mixin, args) {\n  if (args && args.length > 0) {\n    mixin.mixins = a_map.call(args, function(x) {\n      if (x instanceof Mixin) { return x; }\n\n      // Note: Manually setup a primitive mixin here.  This is the only\n      // way to actually get a primitive mixin.  This way normal creation\n      // of mixins will give you combined mixins...\n      var mixin = new Mixin();\n      mixin.properties = x;\n      return mixin;\n    });\n  }\n  return mixin;\n}\n\n/** @private */\nfunction isMethod(obj) {\n  return 'function' === typeof obj &&\n         obj.isMethod !== false &&\n         obj !== Boolean && obj !== Object && obj !== Number && obj !== Array && obj !== Date && obj !== String;\n}\n\n/** @private */\nfunction mergeMixins(mixins, m, descs, values, base) {\n  var len = mixins.length, idx, mixin, guid, props, value, key, ovalue, concats;\n\n  /** @private */\n  function removeKeys(keyName) {\n    delete descs[keyName];\n    delete values[keyName];\n  }\n\n  for(idx=0; idx < len; idx++) {\n    mixin = mixins[idx];\n    Ember.assert('Expected hash or Mixin instance, got ' + Object.prototype.toString.call(mixin), typeof mixin === 'object' && mixin !== null && Object.prototype.toString.call(mixin) !== '[object Array]');\n\n    if (mixin instanceof Mixin) {\n      guid = guidFor(mixin);\n      if (m[guid]) { continue; }\n      m[guid] = mixin;\n      props = mixin.properties;\n    } else {\n      props = mixin; // apply anonymous mixin properties\n    }\n\n    if (props) {\n      // reset before adding each new mixin to pickup concats from previous\n      concats = values.concatenatedProperties || base.concatenatedProperties;\n      if (props.concatenatedProperties) {\n        concats = concats ? concats.concat(props.concatenatedProperties) : props.concatenatedProperties;\n      }\n\n      for (key in props) {\n        if (!props.hasOwnProperty(key)) { continue; }\n        value = props[key];\n        if (value instanceof Ember.Descriptor) {\n          if (value === REQUIRED && descs[key]) { continue; }\n\n          descs[key]  = value;\n          values[key] = undefined;\n        } else {\n          // impl super if needed...\n          if (isMethod(value)) {\n            ovalue = descs[key] === undefined && values[key];\n            if (!ovalue) { ovalue = base[key]; }\n            if ('function' !== typeof ovalue) { ovalue = null; }\n            if (ovalue) {\n              var o = value.__ember_observes__, ob = value.__ember_observesBefore__;\n              value = Ember.wrap(value, ovalue);\n              value.__ember_observes__ = o;\n              value.__ember_observesBefore__ = ob;\n            }\n          } else if ((concats && a_indexOf.call(concats, key) >= 0) || key === 'concatenatedProperties') {\n            var baseValue = values[key] || base[key];\n            value = baseValue ? baseValue.concat(value) : Ember.makeArray(value);\n          }\n\n          descs[key] = undefined;\n          values[key] = value;\n        }\n      }\n\n      // manually copy toString() because some JS engines do not enumerate it\n      if (props.hasOwnProperty('toString')) {\n        base.toString = props.toString;\n      }\n\n    } else if (mixin.mixins) {\n      mergeMixins(mixin.mixins, m, descs, values, base);\n      if (mixin._without) { a_forEach.call(mixin._without, removeKeys); }\n    }\n  }\n}\n\n/** @private */\nfunction writableReq(obj) {\n  var m = Ember.meta(obj), req = m.required;\n  if (!req || req.__emberproto__ !== obj) {\n    req = m.required = req ? o_create(req) : { __ember_count__: 0 };\n    req.__emberproto__ = obj;\n  }\n  return req;\n}\n\nvar IS_BINDING = Ember.IS_BINDING = /^.+Binding$/;\n\n/** @private */\nfunction detectBinding(obj, key, value, m) {\n  if (IS_BINDING.test(key)) {\n    var bindings = m.bindings;\n    if (!bindings) {\n      bindings = m.bindings = { __emberproto__: obj };\n    } else if (bindings.__emberproto__ !== obj) {\n      bindings = m.bindings = o_create(m.bindings);\n      bindings.__emberproto__ = obj;\n    }\n    bindings[key] = value;\n  }\n}\n\n/** @private */\nfunction connectBindings(obj, m) {\n  // TODO Mixin.apply(instance) should disconnect binding if exists\n  var bindings = m.bindings, key, binding, to;\n  if (bindings) {\n    for (key in bindings) {\n      binding = key !== '__emberproto__' && bindings[key];\n      if (binding) {\n        to = key.slice(0, -7); // strip Binding off end\n        if (binding instanceof Ember.Binding) {\n          binding = binding.copy(); // copy prototypes' instance\n          binding.to(to);\n        } else { // binding is string path\n          binding = new Ember.Binding(to, binding);\n        }\n        binding.connect(obj);\n        obj[key] = binding;\n      }\n    }\n    // mark as applied\n    m.bindings = { __emberproto__: obj };\n  }\n}\n\nfunction finishPartial(obj, m) {\n  connectBindings(obj, m || Ember.meta(obj));\n  return obj;\n}\n\n/** @private */\nfunction applyMixin(obj, mixins, partial) {\n  var descs = {}, values = {}, m = Ember.meta(obj), req = m.required,\n      key, value, desc, prevValue, paths, len, idx;\n\n  // Go through all mixins and hashes passed in, and:\n  //\n  // * Handle concatenated properties\n  // * Set up _super wrapping if necessary\n  // * Set up computed property descriptors\n  // * Copying `toString` in broken browsers\n  mergeMixins(mixins, mixinsMeta(obj), descs, values, obj);\n\n  for(key in values) {\n    if (key === 'contructor') { continue; }\n    if (!values.hasOwnProperty(key)) { continue; }\n\n    desc = descs[key];\n    value = values[key];\n\n    if (desc === REQUIRED) {\n      if (!(key in obj)) {\n        Ember.assert('Required property not defined: '+key, !!partial);\n\n        // for partial applies add to hash of required keys\n        req = writableReq(obj);\n        req.__ember_count__++;\n        req[key] = true;\n      }\n    } else {\n      while (desc && desc instanceof Alias) {\n        var altKey = desc.methodName;\n        if (descs[altKey] || values[altKey]) {\n          value = values[altKey];\n          desc  = descs[altKey];\n        } else if (m.descs[altKey]) {\n          desc  = m.descs[altKey];\n          value = undefined;\n        } else {\n          desc = undefined;\n          value = obj[altKey];\n        }\n      }\n\n      if (desc === undefined && value === undefined) { continue; }\n\n      prevValue = obj[key];\n\n      if ('function' === typeof prevValue) {\n        if ((paths = prevValue.__ember_observesBefore__)) {\n          len = paths.length;\n          for (idx=0; idx < len; idx++) {\n            Ember.removeBeforeObserver(obj, paths[idx], null, key);\n          }\n        } else if ((paths = prevValue.__ember_observes__)) {\n          len = paths.length;\n          for (idx=0; idx < len; idx++) {\n            Ember.removeObserver(obj, paths[idx], null, key);\n          }\n        }\n      }\n\n      detectBinding(obj, key, value, m);\n\n      defineProperty(obj, key, desc, value, m);\n\n      if ('function' === typeof value) {\n        if (paths = value.__ember_observesBefore__) {\n          len = paths.length;\n          for (idx=0; idx < len; idx++) {\n            Ember.addBeforeObserver(obj, paths[idx], null, key);\n          }\n        } else if (paths = value.__ember_observes__) {\n          len = paths.length;\n          for (idx=0; idx < len; idx++) {\n            Ember.addObserver(obj, paths[idx], null, key);\n          }\n        }\n      }\n\n      if (req && req[key]) {\n        req = writableReq(obj);\n        req.__ember_count__--;\n        req[key] = false;\n      }\n    }\n  }\n\n  if (!partial) { // don't apply to prototype\n    finishPartial(obj, m);\n  }\n\n  // Make sure no required attrs remain\n  if (!partial && req && req.__ember_count__>0) {\n    var keys = [];\n    for (key in req) {\n      if (META_SKIP[key]) { continue; }\n      keys.push(key);\n    }\n    // TODO: Remove surrounding if clause from production build\n    Ember.assert('Required properties not defined: '+keys.join(','));\n  }\n  return obj;\n}\n\nEmber.mixin = function(obj) {\n  var args = a_slice.call(arguments, 1);\n  applyMixin(obj, args, false);\n  return obj;\n};\n\n/**\n  @class\n\n  The `Ember.Mixin` class allows you to create mixins, whose properties can be\n  added to other classes. For instance,\n\n      App.Editable = Ember.Mixin.create({\n        edit: function() {\n          console.log('starting to edit');\n          this.set('isEditing', true);\n        },\n        isEditing: false\n      });\n\n      // Mix mixins into classes by passing them as the first arguments to\n      // .extend or .create.\n      App.CommentView = Ember.View.extend(App.Editable, {\n        template: Ember.Handlebars.compile('{{#if isEditing}}...{{else}}...{{/if}}')\n      });\n\n      commentView = App.CommentView.create();\n      commentView.edit(); // => outputs 'starting to edit'\n\n  Note that Mixins are created with `Ember.Mixin.create`, not\n  `Ember.Mixin.extend`.\n*/\nEmber.Mixin = function() { return initMixin(this, arguments); };\n\n/** @private */\nMixin = Ember.Mixin;\n\n/** @private */\nMixin._apply = applyMixin;\n\nMixin.applyPartial = function(obj) {\n  var args = a_slice.call(arguments, 1);\n  return applyMixin(obj, args, true);\n};\n\nMixin.finishPartial = finishPartial;\n\nMixin.create = function() {\n  classToString.processed = false;\n  var M = this;\n  return initMixin(new M(), arguments);\n};\n\nvar MixinPrototype = Mixin.prototype;\n\nMixinPrototype.reopen = function() {\n  var mixin, tmp;\n\n  if (this.properties) {\n    mixin = Mixin.create();\n    mixin.properties = this.properties;\n    delete this.properties;\n    this.mixins = [mixin];\n  } else if (!this.mixins) {\n    this.mixins = [];\n  }\n\n  var len = arguments.length, mixins = this.mixins, idx;\n\n  for(idx=0; idx < len; idx++) {\n    mixin = arguments[idx];\n    Ember.assert('Expected hash or Mixin instance, got ' + Object.prototype.toString.call(mixin), typeof mixin === 'object' && mixin !== null && Object.prototype.toString.call(mixin) !== '[object Array]');\n\n    if (mixin instanceof Mixin) {\n      mixins.push(mixin);\n    } else {\n      tmp = Mixin.create();\n      tmp.properties = mixin;\n      mixins.push(tmp);\n    }\n  }\n\n  return this;\n};\n\nMixinPrototype.apply = function(obj) {\n  return applyMixin(obj, [this], false);\n};\n\nMixinPrototype.applyPartial = function(obj) {\n  return applyMixin(obj, [this], true);\n};\n\n/** @private */\nfunction _detect(curMixin, targetMixin, seen) {\n  var guid = guidFor(curMixin);\n\n  if (seen[guid]) { return false; }\n  seen[guid] = true;\n\n  if (curMixin === targetMixin) { return true; }\n  var mixins = curMixin.mixins, loc = mixins ? mixins.length : 0;\n  while (--loc >= 0) {\n    if (_detect(mixins[loc], targetMixin, seen)) { return true; }\n  }\n  return false;\n}\n\nMixinPrototype.detect = function(obj) {\n  if (!obj) { return false; }\n  if (obj instanceof Mixin) { return _detect(obj, this, {}); }\n  var mixins = Ember.meta(obj, false).mixins;\n  if (mixins) {\n    return !!mixins[guidFor(this)];\n  }\n  return false;\n};\n\nMixinPrototype.without = function() {\n  var ret = new Mixin(this);\n  ret._without = a_slice.call(arguments);\n  return ret;\n};\n\n/** @private */\nfunction _keys(ret, mixin, seen) {\n  if (seen[guidFor(mixin)]) { return; }\n  seen[guidFor(mixin)] = true;\n\n  if (mixin.properties) {\n    var props = mixin.properties;\n    for (var key in props) {\n      if (props.hasOwnProperty(key)) { ret[key] = true; }\n    }\n  } else if (mixin.mixins) {\n    a_forEach.call(mixin.mixins, function(x) { _keys(ret, x, seen); });\n  }\n}\n\nMixinPrototype.keys = function() {\n  var keys = {}, seen = {}, ret = [];\n  _keys(keys, this, seen);\n  for(var key in keys) {\n    if (keys.hasOwnProperty(key)) { ret.push(key); }\n  }\n  return ret;\n};\n\n/** @private - make Mixin's have nice displayNames */\n\nvar NAME_KEY = Ember.GUID_KEY+'_name';\nvar get = Ember.get;\n\n/** @private */\nfunction processNames(paths, root, seen) {\n  var idx = paths.length;\n  for(var key in root) {\n    if (!root.hasOwnProperty || !root.hasOwnProperty(key)) { continue; }\n    var obj = root[key];\n    paths[idx] = key;\n\n    if (obj && obj.toString === classToString) {\n      obj[NAME_KEY] = paths.join('.');\n    } else if (obj && get(obj, 'isNamespace')) {\n      if (seen[guidFor(obj)]) { continue; }\n      seen[guidFor(obj)] = true;\n      processNames(paths, obj, seen);\n    }\n  }\n  paths.length = idx; // cut out last item\n}\n\n/** @private */\nfunction findNamespaces() {\n  var Namespace = Ember.Namespace, obj, isNamespace;\n\n  if (Namespace.PROCESSED) { return; }\n\n  for (var prop in window) {\n    //  get(window.globalStorage, 'isNamespace') would try to read the storage for domain isNamespace and cause exception in Firefox.\n    // globalStorage is a storage obsoleted by the WhatWG storage specification. See https://developer.mozilla.org/en/DOM/Storage#globalStorage\n    if (prop === \"globalStorage\" && window.StorageList && window.globalStorage instanceof window.StorageList) { continue; }\n    // Unfortunately, some versions of IE don't support window.hasOwnProperty\n    if (window.hasOwnProperty && !window.hasOwnProperty(prop)) { continue; }\n\n    // At times we are not allowed to access certain properties for security reasons.\n    // There are also times where even if we can access them, we are not allowed to access their properties.\n    try {\n      obj = window[prop];\n      isNamespace = obj && get(obj, 'isNamespace');\n    } catch (e) {\n      continue;\n    }\n\n    if (isNamespace) {\n      Ember.deprecate(\"Namespaces should not begin with lowercase.\", /^[A-Z]/.test(prop));\n      obj[NAME_KEY] = prop;\n    }\n  }\n}\n\nEmber.identifyNamespaces = findNamespaces;\n\n/** @private */\nsuperClassString = function(mixin) {\n  var superclass = mixin.superclass;\n  if (superclass) {\n    if (superclass[NAME_KEY]) { return superclass[NAME_KEY]; }\n    else { return superClassString(superclass); }\n  } else {\n    return;\n  }\n};\n\n/** @private */\nclassToString = function() {\n  var Namespace = Ember.Namespace, namespace;\n\n  // TODO: Namespace should really be in Metal\n  if (Namespace) {\n    if (!this[NAME_KEY] && !classToString.processed) {\n      if (!Namespace.PROCESSED) {\n        findNamespaces();\n        Namespace.PROCESSED = true;\n      }\n\n      classToString.processed = true;\n\n      var namespaces = Namespace.NAMESPACES;\n      for (var i=0, l=namespaces.length; i<l; i++) {\n        namespace = namespaces[i];\n        processNames([namespace.toString()], namespace, {});\n      }\n    }\n  }\n\n  if (this[NAME_KEY]) {\n    return this[NAME_KEY];\n  } else {\n    var str = superClassString(this);\n    if (str) {\n      return \"(subclass of \" + str + \")\";\n    } else {\n      return \"(unknown mixin)\";\n    }\n  }\n};\n\nMixinPrototype.toString = classToString;\n\n// returns the mixins currently applied to the specified object\n// TODO: Make Ember.mixin\nMixin.mixins = function(obj) {\n  var ret = [], mixins = Ember.meta(obj, false).mixins, key, mixin;\n  if (mixins) {\n    for(key in mixins) {\n      if (META_SKIP[key]) { continue; }\n      mixin = mixins[key];\n\n      // skip primitive mixins since these are always anonymous\n      if (!mixin.properties) { ret.push(mixins[key]); }\n    }\n  }\n  return ret;\n};\n\nREQUIRED = new Ember.Descriptor();\nREQUIRED.toString = function() { return '(Required Property)'; };\n\nEmber.required = function() {\n  return REQUIRED;\n};\n\n/** @private */\nAlias = function(methodName) {\n  this.methodName = methodName;\n};\nAlias.prototype = new Ember.Descriptor();\n\nEmber.alias = function(methodName) {\n  return new Alias(methodName);\n};\n\n// ..........................................................\n// OBSERVER HELPER\n//\n\nEmber.observer = function(func) {\n  var paths = a_slice.call(arguments, 1);\n  func.__ember_observes__ = paths;\n  return func;\n};\n\n// If observers ever become asynchronous, Ember.immediateObserver\n// must remain synchronous.\nEmber.immediateObserver = function() {\n  for (var i=0, l=arguments.length; i<l; i++) {\n    var arg = arguments[i];\n    Ember.assert(\"Immediate observers must observe internal properties only, not properties on other objects.\", typeof arg !== \"string\" || arg.indexOf('.') === -1);\n  }\n\n  return Ember.observer.apply(this, arguments);\n};\n\nEmber.beforeObserver = function(func) {\n  var paths = a_slice.call(arguments, 1);\n  func.__ember_observesBefore__ = paths;\n  return func;\n};\n\n})();\n//@ sourceURL=ember-metal/mixin");