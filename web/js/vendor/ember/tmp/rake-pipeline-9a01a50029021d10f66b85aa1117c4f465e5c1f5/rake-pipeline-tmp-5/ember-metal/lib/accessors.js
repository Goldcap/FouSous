minispade.register('ember-metal/accessors', "(function() {// ==========================================================================\n// Project:  Ember Metal\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-metal/core');\nminispade.require('ember-metal/platform');\nminispade.require('ember-metal/utils');\n\nvar META_KEY = Ember.META_KEY, get, set;\n\nvar MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;\n\n/** @private */\nvar IS_GLOBAL = /^([A-Z$]|([0-9][A-Z$]))/;\nvar IS_GLOBAL_PATH = /^([A-Z$]|([0-9][A-Z$])).*[\\.\\*]/;\nvar HAS_THIS  = /^this[\\.\\*]/;\nvar FIRST_KEY = /^([^\\.\\*]+)/;\n\n// ..........................................................\n// GET AND SET\n//\n// If we are on a platform that supports accessors we can get use those.\n// Otherwise simulate accessors by looking up the property directly on the\n// object.\n\n/** @private */\nget = function get(obj, keyName) {\n  // Helpers that operate with 'this' within an #each\n  if (keyName === '') {\n    return obj;\n  }\n\n  if (!keyName && 'string'===typeof obj) {\n    keyName = obj;\n    obj = null;\n  }\n\n  if (!obj || keyName.indexOf('.') !== -1) {\n    return getPath(obj, keyName);\n  }\n\n  Ember.assert(\"You need to provide an object and key to `get`.\", !!obj && keyName);\n\n  var meta = obj[META_KEY], desc = meta && meta.descs[keyName], ret;\n  if (desc) {\n    return desc.get(obj, keyName);\n  } else {\n    if (MANDATORY_SETTER && meta && meta.watching[keyName] > 0) {\n      ret = meta.values[keyName];\n    } else {\n      ret = obj[keyName];\n    }\n\n    if (ret === undefined &&\n        'object' === typeof obj && !(keyName in obj) && 'function' === typeof obj.unknownProperty) {\n      return obj.unknownProperty(keyName);\n    }\n\n    return ret;\n  }\n};\n\n/** @private */\nset = function set(obj, keyName, value, tolerant) {\n  if (typeof obj === 'string') {\n    Ember.assert(\"Path '\" + obj + \"' must be global if no obj is given.\", IS_GLOBAL.test(obj));\n    value = keyName;\n    keyName = obj;\n    obj = null;\n  }\n\n  if (!obj || keyName.indexOf('.') !== -1) {\n    return setPath(obj, keyName, value, tolerant);\n  }\n\n  Ember.assert(\"You need to provide an object and key to `set`.\", !!obj && keyName !== undefined);\n  Ember.assert('calling set on destroyed object', !obj.isDestroyed);\n\n  var meta = obj[META_KEY], desc = meta && meta.descs[keyName],\n      isUnknown, currentValue;\n  if (desc) {\n    desc.set(obj, keyName, value);\n  }\n  else {\n    isUnknown = 'object' === typeof obj && !(keyName in obj);\n\n    // setUnknownProperty is called if `obj` is an object,\n    // the property does not already exist, and the\n    // `setUnknownProperty` method exists on the object\n    if (isUnknown && 'function' === typeof obj.setUnknownProperty) {\n      obj.setUnknownProperty(keyName, value);\n    } else if (meta && meta.watching[keyName] > 0) {\n      if (MANDATORY_SETTER) {\n        currentValue = meta.values[keyName];\n      } else {\n        currentValue = obj[keyName];\n      }\n      // only trigger a change if the value has changed\n      if (value !== currentValue) {\n        Ember.propertyWillChange(obj, keyName);\n        if (MANDATORY_SETTER) {\n          if (currentValue === undefined && !(keyName in obj)) {\n            Ember.defineProperty(obj, keyName, null, value); // setup mandatory setter\n          } else {\n            meta.values[keyName] = value;\n          }\n        } else {\n          obj[keyName] = value;\n        }\n        Ember.propertyDidChange(obj, keyName);\n      }\n    } else {\n      obj[keyName] = value;\n    }\n  }\n  return value;\n};\n\n/** @private */\nfunction firstKey(path) {\n  return path.match(FIRST_KEY)[0];\n}\n\n// assumes path is already normalized\n/** @private */\nfunction normalizeTuple(target, path) {\n  var hasThis  = HAS_THIS.test(path),\n      isGlobal = !hasThis && IS_GLOBAL_PATH.test(path),\n      key;\n\n  if (!target || isGlobal) target = window;\n  if (hasThis) path = path.slice(5);\n\n  if (target === window) {\n    key = firstKey(path);\n    target = get(target, key);\n    path   = path.slice(key.length+1);\n  }\n\n  // must return some kind of path to be valid else other things will break.\n  if (!path || path.length===0) throw new Error('Invalid Path');\n\n  return [ target, path ];\n}\n\n/** @private */\nfunction getPath(root, path) {\n  var hasThis, parts, tuple, idx, len;\n\n  // If there is no root and path is a key name, return that\n  // property from the global object.\n  // E.g. get('Ember') -> Ember\n  if (root === null && path.indexOf('.') === -1) { return get(window, path); }\n\n  // detect complicated paths and normalize them\n  hasThis  = HAS_THIS.test(path);\n\n  if (!root || hasThis) {\n    tuple = normalizeTuple(root, path);\n    root = tuple[0];\n    path = tuple[1];\n    tuple.length = 0;\n  }\n\n  parts = path.split(\".\");\n  len = parts.length;\n  for (idx=0; root && idx<len; idx++) {\n    root = get(root, parts[idx], true);\n    if (root && root.isDestroyed) { return undefined; }\n  }\n  return root;\n}\n\n/** @private */\nfunction setPath(root, path, value, tolerant) {\n  var keyName;\n\n  // get the last part of the path\n  keyName = path.slice(path.lastIndexOf('.') + 1);\n\n  // get the first part of the part\n  path    = path.slice(0, path.length-(keyName.length+1));\n\n  // unless the path is this, look up the first part to\n  // get the root\n  if (path !== 'this') {\n    root = getPath(root, path);\n  }\n\n  if (!keyName || keyName.length === 0) {\n    throw new Error('You passed an empty path');\n  }\n\n  if (!root) {\n    if (tolerant) { return; }\n    else { throw new Error('Object in path '+path+' could not be found or was destroyed.'); }\n  }\n\n  return set(root, keyName, value);\n}\n\n/**\n  @private\n\n  Normalizes a target/path pair to reflect that actual target/path that should\n  be observed, etc.  This takes into account passing in global property\n  paths (i.e. a path beginning with a captial letter not defined on the\n  target) and * separators.\n\n  @param {Object} target\n    The current target.  May be null.\n\n  @param {String} path\n    A path on the target or a global property path.\n\n  @returns {Array} a temporary array with the normalized target/path pair.\n*/\nEmber.normalizeTuple = function(target, path) {\n  return normalizeTuple(target, path);\n};\n\nEmber.getWithDefault = function(root, key, defaultValue) {\n  var value = get(root, key);\n\n  if (value === undefined) { return defaultValue; }\n  return value;\n};\n\n\n/**\n  @function\n\n  Gets the value of a property on an object.  If the property is computed,\n  the function will be invoked.  If the property is not defined but the\n  object implements the unknownProperty() method then that will be invoked.\n\n  If you plan to run on IE8 and older browsers then you should use this\n  method anytime you want to retrieve a property on an object that you don't\n  know for sure is private.  (My convention only properties beginning with\n  an underscore '_' are considered private.)\n\n  On all newer browsers, you only need to use this method to retrieve\n  properties if the property might not be defined on the object and you want\n  to respect the unknownProperty() handler.  Otherwise you can ignore this\n  method.\n\n  Note that if the obj itself is null, this method will simply return\n  undefined.\n\n  @param {Object} obj\n    The object to retrieve from.\n\n  @param {String} keyName\n    The property key to retrieve\n\n  @returns {Object} the property value or null.\n*/\nEmber.get = get;\nEmber.getPath = Ember.deprecateFunc('getPath is deprecated since get now supports paths', Ember.get);\n\n/**\n  @function\n\n  Sets the value of a property on an object, respecting computed properties\n  and notifying observers and other listeners of the change.  If the\n  property is not defined but the object implements the unknownProperty()\n  method then that will be invoked as well.\n\n  If you plan to run on IE8 and older browsers then you should use this\n  method anytime you want to set a property on an object that you don't\n  know for sure is private.  (My convention only properties beginning with\n  an underscore '_' are considered private.)\n\n  On all newer browsers, you only need to use this method to set\n  properties if the property might not be defined on the object and you want\n  to respect the unknownProperty() handler.  Otherwise you can ignore this\n  method.\n\n  @param {Object} obj\n    The object to modify.\n\n  @param {String} keyName\n    The property key to set\n\n  @param {Object} value\n    The value to set\n\n  @returns {Object} the passed value.\n*/\nEmber.set = set;\nEmber.setPath = Ember.deprecateFunc('setPath is deprecated since set now supports paths', Ember.set);\n\n/**\n  Error-tolerant form of Ember.set. Will not blow up if any part of the\n  chain is undefined, null, or destroyed.\n\n  This is primarily used when syncing bindings, which may try to update after\n  an object has been destroyed.\n*/\nEmber.trySet = function(root, path, value) {\n  return set(root, path, value, true);\n};\nEmber.trySetPath = Ember.deprecateFunc('trySetPath has been renamed to trySet', Ember.trySet);\n\n/**\n  Returns true if the provided path is global (e.g., \"MyApp.fooController.bar\")\n  instead of local (\"foo.bar.baz\").\n\n  @param {String} path\n  @returns Boolean\n*/\nEmber.isGlobalPath = function(path) {\n  return IS_GLOBAL.test(path);\n};\n\n\n\nif (Ember.config.overrideAccessors) {\n  Ember.config.overrideAccessors();\n  get = Ember.get;\n  set = Ember.set;\n}\n\n})();\n//@ sourceURL=ember-metal/accessors");