minispade.register('ember-metal/events', "(function() {// ==========================================================================\n// Project:  Ember Metal\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-metal/core');\nminispade.require('ember-metal/platform');\nminispade.require('ember-metal/utils');\n\nvar o_create = Ember.create,\n    meta = Ember.meta,\n    metaPath = Ember.metaPath,\n    guidFor = Ember.guidFor,\n    a_slice = [].slice;\n\n/**\n  The event system uses a series of nested hashes to store listeners on an\n  object. When a listener is registered, or when an event arrives, these\n  hashes are consulted to determine which target and action pair to invoke.\n\n  The hashes are stored in the object's meta hash, and look like this:\n\n      // Object's meta hash\n      {\n        listeners: {               // variable name: `listenerSet`\n          \"foo:changed\": {         // variable name: `targetSet`\n            [targetGuid]: {        // variable name: `actionSet`\n              [methodGuid]: {      // variable name: `action`\n                target: [Object object],\n                method: [Function function]\n              }\n            }\n          }\n        }\n      }\n\n*/\n\n// Gets the set of all actions, keyed on the guid of each action's\n// method property.\n/** @private */\nfunction actionSetFor(obj, eventName, target, writable) {\n  return metaPath(obj, ['listeners', eventName, guidFor(target)], writable);\n}\n\n// Gets the set of all targets, keyed on the guid of each action's\n// target property.\n/** @private */\nfunction targetSetFor(obj, eventName) {\n  var listenerSet = meta(obj, false).listeners;\n  if (!listenerSet) { return false; }\n\n  return listenerSet[eventName] || false;\n}\n\n// TODO: This knowledge should really be a part of the\n// meta system.\nvar SKIP_PROPERTIES = { __ember_source__: true };\n\n/** @private */\nfunction iterateSet(obj, eventName, callback, params) {\n  var targetSet = targetSetFor(obj, eventName);\n  if (!targetSet) { return false; }\n  // Iterate through all elements of the target set\n  for(var targetGuid in targetSet) {\n    if (SKIP_PROPERTIES[targetGuid]) { continue; }\n\n    var actionSet = targetSet[targetGuid];\n    if (actionSet) {\n      // Iterate through the elements of the action set\n      for(var methodGuid in actionSet) {\n        if (SKIP_PROPERTIES[methodGuid]) { continue; }\n\n        var action = actionSet[methodGuid];\n        if (action) {\n          if (callback(action, params, obj) === true) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/** @private */\nfunction invokeAction(action, params, sender) {\n  var method = action.method, target = action.target;\n  // If there is no target, the target is the object\n  // on which the event was fired.\n  if (!target) { target = sender; }\n  if ('string' === typeof method) { method = target[method]; }\n  if (params) {\n    method.apply(target, params);\n  } else {\n    method.apply(target);\n  }\n}\n\n/**\n  The sendEvent arguments > 2 are passed to an event listener.\n\n  @memberOf Ember\n*/\nfunction addListener(obj, eventName, target, method) {\n  Ember.assert(\"You must pass at least an object and event name to Ember.addListener\", !!obj && !!eventName);\n\n  if (!method && 'function' === typeof target) {\n    method = target;\n    target = null;\n  }\n\n  var actionSet = actionSetFor(obj, eventName, target, true),\n      methodGuid = guidFor(method);\n\n  if (!actionSet[methodGuid]) {\n    actionSet[methodGuid] = { target: target, method: method };\n  }\n\n  if ('function' === typeof obj.didAddListener) {\n    obj.didAddListener(eventName, target, method);\n  }\n}\n\n/** @memberOf Ember */\nfunction removeListener(obj, eventName, target, method) {\n  Ember.assert(\"You must pass at least an object and event name to Ember.removeListener\", !!obj && !!eventName);\n\n  if (!method && 'function' === typeof target) {\n    method = target;\n    target = null;\n  }\n\n  var actionSet = actionSetFor(obj, eventName, target, true),\n      methodGuid = guidFor(method);\n\n  // we can't simply delete this parameter, because if we do, we might\n  // re-expose the property from the prototype chain.\n  if (actionSet && actionSet[methodGuid]) { actionSet[methodGuid] = null; }\n\n  if ('function' === typeof obj.didRemoveListener) {\n    obj.didRemoveListener(eventName, target, method);\n  }\n}\n\n// Suspend listener during callback.\n//\n// This should only be used by the target of the event listener\n// when it is taking an action that would cause the event, e.g.\n// an object might suspend its property change listener while it is\n// setting that property.\n/** @private */\nfunction suspendListener(obj, eventName, target, method, callback) {\n  if (!method && 'function' === typeof target) {\n    method = target;\n    target = null;\n  }\n\n  var actionSet = actionSetFor(obj, eventName, target, true),\n      methodGuid = guidFor(method),\n      action = actionSet && actionSet[methodGuid];\n\n  actionSet[methodGuid] = null;\n  try {\n    return callback.call(target);\n  } finally {\n    actionSet[methodGuid] = action;\n  }\n}\n\nfunction suspendListeners(obj, eventNames, target, method, callback) {\n  if (!method && 'function' === typeof target) {\n    method = target;\n    target = null;\n  }\n\n  var oldActions = [],\n      actionSets = [],\n      eventName, actionSet, methodGuid, action, i, l;\n\n  for (i=0, l=eventNames.length; i<l; i++) {\n    eventName = eventNames[i];\n    actionSet = actionSetFor(obj, eventName, target, true),\n    methodGuid = guidFor(method);\n\n    oldActions.push(actionSet && actionSet[methodGuid]);\n    actionSets.push(actionSet);\n\n    actionSet[methodGuid] = null;\n  }\n\n  try {\n    return callback.call(target);\n  } finally {\n    for (i=0, l=oldActions.length; i<l; i++) {\n      eventName = eventNames[i];\n      actionSets[i][methodGuid] = oldActions[i];\n    }\n  }\n}\n\n// returns a list of currently watched events\n/** @memberOf Ember */\nfunction watchedEvents(obj) {\n  var listeners = meta(obj, false).listeners, ret = [];\n\n  if (listeners) {\n    for(var eventName in listeners) {\n      if (!SKIP_PROPERTIES[eventName] && listeners[eventName]) {\n        ret.push(eventName);\n      }\n    }\n  }\n  return ret;\n}\n\n/** @memberOf Ember */\nfunction sendEvent(obj, eventName, params) {\n  // first give object a chance to handle it\n  if (obj !== Ember && 'function' === typeof obj.sendEvent) {\n    obj.sendEvent(eventName, params);\n  }\n\n  iterateSet(obj, eventName, invokeAction, params);\n  return true;\n}\n\n/** @memberOf Ember */\nfunction deferEvent(obj, eventName, params) {\n  var actions = [];\n  iterateSet(obj, eventName, function (action) {\n    actions.push(action);\n  });\n\n  return function() {\n    if (obj.isDestroyed) { return; }\n\n    if (obj !== Ember && 'function' === typeof obj.sendEvent) {\n      obj.sendEvent(eventName, params);\n    }\n\n    for (var i=0, len=actions.length; i < len; ++i) {\n      invokeAction(actions[i], params, obj);\n    }\n  };\n}\n\n/** @memberOf Ember */\nfunction hasListeners(obj, eventName) {\n  if (iterateSet(obj, eventName, function() { return true; })) {\n    return true;\n  }\n\n  // no listeners!  might as well clean this up so it is faster later.\n  var set = metaPath(obj, ['listeners'], true);\n  set[eventName] = null;\n\n  return false;\n}\n\n/** @memberOf Ember */\nfunction listenersFor(obj, eventName) {\n  var ret = [];\n  iterateSet(obj, eventName, function (action) {\n    ret.push([action.target, action.method]);\n  });\n  return ret;\n}\n\nEmber.addListener = addListener;\nEmber.removeListener = removeListener;\nEmber._suspendListener = suspendListener;\nEmber._suspendListeners = suspendListeners;\nEmber.sendEvent = sendEvent;\nEmber.hasListeners = hasListeners;\nEmber.watchedEvents = watchedEvents;\nEmber.listenersFor = listenersFor;\nEmber.deferEvent = deferEvent;\n\n})();\n//@ sourceURL=ember-metal/events");