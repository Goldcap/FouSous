minispade.register('ember-metal/computed', "(function() {// ==========================================================================\n// Project:  Ember Metal\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-metal/core');\nminispade.require('ember-metal/platform');\nminispade.require('ember-metal/utils');\nminispade.require('ember-metal/properties');\nminispade.require('ember-metal/watching');\n\n\nEmber.warn(\"Computed properties will soon be cacheable by default. To enable this in your app, set `ENV.CP_DEFAULT_CACHEABLE = true`.\", Ember.CP_DEFAULT_CACHEABLE);\n\n\nvar get = Ember.get,\n    metaFor = Ember.meta,\n    guidFor = Ember.guidFor,\n    a_slice = [].slice,\n    o_create = Ember.create,\n    META_KEY = Ember.META_KEY,\n    watch = Ember.watch,\n    unwatch = Ember.unwatch;\n\n// ..........................................................\n// DEPENDENT KEYS\n//\n\n// data structure:\n//  meta.deps = {\n//   'depKey': {\n//     'keyName': count,\n//     __emberproto__: SRC_OBJ [to detect clones]\n//     },\n//   __emberproto__: SRC_OBJ\n//  }\n\n/**\n  @private\n\n  This function returns a map of unique dependencies for a\n  given object and key.\n*/\nfunction keysForDep(obj, depsMeta, depKey) {\n  var keys = depsMeta[depKey];\n  if (!keys) {\n    // if there are no dependencies yet for a the given key\n    // create a new empty list of dependencies for the key\n    keys = depsMeta[depKey] = { __emberproto__: obj };\n  } else if (keys.__emberproto__ !== obj) {\n    // otherwise if the dependency list is inherited from\n    // a superclass, clone the hash\n    keys = depsMeta[depKey] = o_create(keys);\n    keys.__emberproto__ = obj;\n  }\n  return keys;\n}\n\n/**\n  @private\n\n  return obj[META_KEY].deps\n  */\nfunction metaForDeps(obj, meta) {\n  var deps = meta.deps;\n  // If the current object has no dependencies...\n  if (!deps) {\n    // initialize the dependencies with a pointer back to\n    // the current object\n    deps = meta.deps = { __emberproto__: obj };\n  } else if (deps.__emberproto__ !== obj) {\n    // otherwise if the dependencies are inherited from the\n    // object's superclass, clone the deps\n    deps = meta.deps = o_create(deps);\n    deps.__emberproto__ = obj;\n  }\n  return deps;\n}\n\n/** @private */\nfunction addDependentKeys(desc, obj, keyName, meta) {\n  // the descriptor has a list of dependent keys, so\n  // add all of its dependent keys.\n  var depKeys = desc._dependentKeys, depsMeta, idx, len, depKey, keys;\n  if (!depKeys) return;\n\n  depsMeta = metaForDeps(obj, meta);\n\n  for(idx = 0, len = depKeys.length; idx < len; idx++) {\n    depKey = depKeys[idx];\n    // Lookup keys meta for depKey\n    keys = keysForDep(obj, depsMeta, depKey);\n    // Increment the number of times depKey depends on keyName.\n    keys[keyName] = (keys[keyName] || 0) + 1;\n    // Watch the depKey\n    watch(obj, depKey);\n  }\n}\n\n/** @private */\nfunction removeDependentKeys(desc, obj, keyName, meta) {\n  // the descriptor has a list of dependent keys, so\n  // add all of its dependent keys.\n  var depKeys = desc._dependentKeys, depsMeta, idx, len, depKey, keys;\n  if (!depKeys) return;\n\n  depsMeta = metaForDeps(obj, meta);\n\n  for(idx = 0, len = depKeys.length; idx < len; idx++) {\n    depKey = depKeys[idx];\n    // Lookup keys meta for depKey\n    keys = keysForDep(obj, depsMeta, depKey);\n    // Increment the number of times depKey depends on keyName.\n    keys[keyName] = (keys[keyName] || 0) - 1;\n    // Watch the depKey\n    unwatch(obj, depKey);\n  }\n}\n\n// ..........................................................\n// COMPUTED PROPERTY\n//\n\n/** @private */\nfunction ComputedProperty(func, opts) {\n  this.func = func;\n  this._cacheable = (opts && opts.cacheable !== undefined) ? opts.cacheable : Ember.CP_DEFAULT_CACHEABLE;\n  this._dependentKeys = opts && opts.dependentKeys;\n}\n\n/**\n  @constructor\n*/\nEmber.ComputedProperty = ComputedProperty;\nComputedProperty.prototype = new Ember.Descriptor();\n\n/**\n  @extends Ember.ComputedProperty\n  @private\n*/\nvar ComputedPropertyPrototype = ComputedProperty.prototype;\n\n/**\n  Call on a computed property to set it into cacheable mode.  When in this\n  mode the computed property will automatically cache the return value of\n  your function until one of the dependent keys changes.\n\n      MyApp.president = Ember.Object.create({\n        fullName: function() {\n          return this.get('firstName') + ' ' + this.get('lastName');\n\n          // After calculating the value of this function, Ember.js will\n          // return that value without re-executing this function until\n          // one of the dependent properties change.\n        }.property('firstName', 'lastName').cacheable()\n      });\n\n  Properties are cacheable by default.\n\n  @memberOf Ember.ComputedProperty.prototype\n  @name cacheable\n  @function\n  @param {Boolean} aFlag optional set to false to disable caching\n  @returns {Ember.ComputedProperty} receiver\n*/\nComputedPropertyPrototype.cacheable = function(aFlag) {\n  this._cacheable = aFlag !== false;\n  return this;\n};\n\n/**\n  Call on a computed property to set it into non-cached mode.  When in this\n  mode the computed property will not automatically cache the return value.\n\n      MyApp.outsideService = Ember.Object.create({\n        value: function() {\n          return OutsideService.getValue();\n        }.property().volatile()\n      });\n\n  @memberOf Ember.ComputedProperty.prototype\n  @name volatile\n  @function\n  @returns {Ember.ComputedProperty} receiver\n*/\nComputedPropertyPrototype.volatile = function() {\n  return this.cacheable(false);\n};\n\n/**\n  Sets the dependent keys on this computed property.  Pass any number of\n  arguments containing key paths that this computed property depends on.\n\n      MyApp.president = Ember.Object.create({\n        fullName: Ember.computed(function() {\n          return this.get('firstName') + ' ' + this.get('lastName');\n\n          // Tell Ember.js that this computed property depends on firstName\n          // and lastName\n        }).property('firstName', 'lastName')\n      });\n\n  @memberOf Ember.ComputedProperty.prototype\n  @name property\n  @function\n  @param {String} path... zero or more property paths\n  @returns {Ember.ComputedProperty} receiver\n*/\nComputedPropertyPrototype.property = function() {\n  var args = [];\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    args.push(arguments[i]);\n  }\n  this._dependentKeys = args;\n  return this;\n};\n\n/**\n  In some cases, you may want to annotate computed properties with additional\n  metadata about how they function or what values they operate on. For example,\n  computed property functions may close over variables that are then no longer\n  available for introspection.\n\n  You can pass a hash of these values to a computed property like this:\n\n      person: function() {\n        var personId = this.get('personId');\n        return App.Person.create({ id: personId });\n      }.property().meta({ type: App.Person })\n\n  The hash that you pass to the `meta()` function will be saved on the\n  computed property descriptor under the `_meta` key. Ember runtime\n  exposes a public API for retrieving these values from classes,\n  via the `metaForProperty()` function.\n\n  @memberOf Ember.ComputedProperty.prototype\n  @name meta\n  @function\n  @param {Hash} meta\n  @returns {Ember.ComputedProperty} property descriptor instance\n*/\n\nComputedPropertyPrototype.meta = function(meta) {\n  if (arguments.length === 0) {\n    return this._meta || {};\n  } else {\n    this._meta = meta;\n    return this;\n  }\n};\n\n/** @private - impl descriptor API */\nComputedPropertyPrototype.willWatch = function(obj, keyName) {\n  // watch already creates meta for this instance\n  var meta = obj[META_KEY];\n  Ember.assert('watch should have setup meta to be writable', meta.source === obj);\n  if (!(keyName in meta.cache)) {\n    addDependentKeys(this, obj, keyName, meta);\n  }\n};\n\nComputedPropertyPrototype.didUnwatch = function(obj, keyName) {\n  var meta = obj[META_KEY];\n  Ember.assert('unwatch should have setup meta to be writable', meta.source === obj);\n  if (!(keyName in meta.cache)) {\n    // unwatch already creates meta for this instance\n    removeDependentKeys(this, obj, keyName, meta);\n  }\n};\n\n/** @private - impl descriptor API */\nComputedPropertyPrototype.didChange = function(obj, keyName) {\n  // _suspended is set via a CP.set to ensure we don't clear\n  // the cached value set by the setter\n  if (this._cacheable && this._suspended !== obj) {\n    var meta = metaFor(obj);\n    if (keyName in meta.cache) {\n      delete meta.cache[keyName];\n      if (!meta.watching[keyName]) {\n        removeDependentKeys(this, obj, keyName, meta);\n      }\n    }\n  }\n};\n\n/** @private - impl descriptor API */\nComputedPropertyPrototype.get = function(obj, keyName) {\n  var ret, cache, meta;\n  if (this._cacheable) {\n    meta = metaFor(obj);\n    cache = meta.cache;\n    if (keyName in cache) { return cache[keyName]; }\n    ret = cache[keyName] = this.func.call(obj, keyName);\n    if (!meta.watching[keyName]) {\n      addDependentKeys(this, obj, keyName, meta);\n    }\n  } else {\n    ret = this.func.call(obj, keyName);\n  }\n  return ret;\n};\n\n/** @private - impl descriptor API */\nComputedPropertyPrototype.set = function(obj, keyName, value) {\n  var cacheable = this._cacheable,\n      meta = metaFor(obj, cacheable),\n      watched = meta.watching[keyName],\n      oldSuspended = this._suspended,\n      hadCachedValue,\n      ret;\n\n  this._suspended = obj;\n\n  if (watched) { Ember.propertyWillChange(obj, keyName); }\n  if (cacheable) {\n    if (keyName in meta.cache) {\n      delete meta.cache[keyName];\n      hadCachedValue = true;\n    }\n  }\n  ret = this.func.call(obj, keyName, value);\n  if (cacheable) {\n    if (!watched && !hadCachedValue) {\n      addDependentKeys(this, obj, keyName, meta);\n    }\n    meta.cache[keyName] = ret;\n  }\n  if (watched) { Ember.propertyDidChange(obj, keyName); }\n  this._suspended = oldSuspended;\n  return ret;\n};\n\n/** @private - called when property is defined */\nComputedPropertyPrototype.setup = function(obj, keyName) {\n  var meta = obj[META_KEY];\n  if (meta && meta.watching[keyName]) {\n    addDependentKeys(this, obj, keyName, metaFor(obj));\n  }\n};\n\n/** @private - called before property is overridden */\nComputedPropertyPrototype.teardown = function(obj, keyName) {\n  var meta = metaFor(obj);\n\n  if (meta.watching[keyName] || keyName in meta.cache) {\n    removeDependentKeys(this, obj, keyName, meta);\n  }\n\n  if (this._cacheable) { delete meta.cache[keyName]; }\n\n  return null; // no value to restore\n};\n\n/**\n  This helper returns a new property descriptor that wraps the passed\n  computed property function.  You can use this helper to define properties\n  with mixins or via Ember.defineProperty().\n\n  The function you pass will be used to both get and set property values.\n  The function should accept two parameters, key and value.  If value is not\n  undefined you should set the value first.  In either case return the\n  current value of the property.\n\n  @param {Function} func\n    The computed property function.\n\n  @returns {Ember.ComputedProperty} property descriptor instance\n*/\nEmber.computed = function(func) {\n  var args;\n\n  if (arguments.length > 1) {\n    args = a_slice.call(arguments, 0, -1);\n    func = a_slice.call(arguments, -1)[0];\n  }\n\n  var cp = new ComputedProperty(func);\n\n  if (args) {\n    cp.property.apply(cp, args);\n  }\n\n  return cp;\n};\n\n/**\n  Returns the cached value for a property, if one exists.\n  This can be useful for peeking at the value of a computed\n  property that is generated lazily, without accidentally causing\n  it to be created.\n\n  @param {Object} obj the object whose property you want to check\n  @param {String} key the name of the property whose cached value you want\n                      to return\n\n*/\nEmber.cacheFor = function cacheFor(obj, key) {\n  var cache = metaFor(obj, false).cache;\n\n  if (cache && key in cache) {\n    return cache[key];\n  }\n};\n\nEmber.computed.not = function(dependentKey) {\n  return Ember.computed(dependentKey, function(key) {\n    return !get(this, dependentKey);\n  }).cacheable();\n};\n\nEmber.computed.empty = function(dependentKey) {\n  return Ember.computed(dependentKey, function(key) {\n    var val = get(this, dependentKey);\n    return val === undefined || val === null || val === '' || (Ember.isArray(val) && get(val, 'length') === 0);\n  }).cacheable();\n};\n\nEmber.computed.bool = function(dependentKey) {\n  return Ember.computed(dependentKey, function(key) {\n    return !!get(this, dependentKey);\n  }).cacheable();\n};\n\n})();\n//@ sourceURL=ember-metal/computed");