minispade.register('ember-runtime/mixins/enumerable', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n\n\n\n\n// ..........................................................\n// HELPERS\n//\n\nvar get = Ember.get, set = Ember.set;\nvar a_slice = Array.prototype.slice;\nvar a_indexOf = Ember.EnumerableUtils.indexOf;\n\nvar contexts = [];\n/** @private */\nfunction popCtx() {\n  return contexts.length===0 ? {} : contexts.pop();\n}\n\n/** @private */\nfunction pushCtx(ctx) {\n  contexts.push(ctx);\n  return null;\n}\n\n/** @private */\nfunction iter(key, value) {\n  var valueProvided = arguments.length === 2;\n\n  function i(item) {\n    var cur = get(item, key);\n    return valueProvided ? value===cur : !!cur;\n  }\n  return i ;\n}\n\n/**\n  @class\n\n  This mixin defines the common interface implemented by enumerable objects\n  in Ember.  Most of these methods follow the standard Array iteration\n  API defined up to JavaScript 1.8 (excluding language-specific features that\n  cannot be emulated in older versions of JavaScript).\n\n  This mixin is applied automatically to the Array class on page load, so you\n  can use any of these methods on simple arrays.  If Array already implements\n  one of these methods, the mixin will not override them.\n\n  h3. Writing Your Own Enumerable\n\n  To make your own custom class enumerable, you need two items:\n\n  1. You must have a length property.  This property should change whenever\n     the number of items in your enumerable object changes.  If you using this\n     with an Ember.Object subclass, you should be sure to change the length\n     property using set().\n\n  2. If you must implement nextObject().  See documentation.\n\n  Once you have these two methods implement, apply the Ember.Enumerable mixin\n  to your class and you will be able to enumerate the contents of your object\n  like any other collection.\n\n  h3. Using Ember Enumeration with Other Libraries\n\n  Many other libraries provide some kind of iterator or enumeration like\n  facility.  This is often where the most common API conflicts occur.\n  Ember's API is designed to be as friendly as possible with other\n  libraries by implementing only methods that mostly correspond to the\n  JavaScript 1.8 API.\n\n  @extends Ember.Mixin\n  @since Ember 0.9\n*/\nEmber.Enumerable = Ember.Mixin.create(\n  /** @scope Ember.Enumerable.prototype */ {\n\n  /** @private - compatibility */\n  isEnumerable: true,\n\n  /**\n    Implement this method to make your class enumerable.\n\n    This method will be call repeatedly during enumeration.  The index value\n    will always begin with 0 and increment monotonically.  You don't have to\n    rely on the index value to determine what object to return, but you should\n    always check the value and start from the beginning when you see the\n    requested index is 0.\n\n    The previousObject is the object that was returned from the last call\n    to nextObject for the current iteration.  This is a useful way to\n    manage iteration if you are tracing a linked list, for example.\n\n    Finally the context parameter will always contain a hash you can use as\n    a \"scratchpad\" to maintain any other state you need in order to iterate\n    properly.  The context object is reused and is not reset between\n    iterations so make sure you setup the context with a fresh state whenever\n    the index parameter is 0.\n\n    Generally iterators will continue to call nextObject until the index\n    reaches the your current length-1.  If you run out of data before this\n    time for some reason, you should simply return undefined.\n\n    The default implementation of this method simply looks up the index.\n    This works great on any Array-like objects.\n\n    @param {Number} index the current index of the iteration\n    @param {Object} previousObject the value returned by the last call to nextObject.\n    @param {Object} context a context object you can use to maintain state.\n    @returns {Object} the next object in the iteration or undefined\n  */\n  nextObject: Ember.required(Function),\n\n  /**\n    Helper method returns the first object from a collection.  This is usually\n    used by bindings and other parts of the framework to extract a single\n    object if the enumerable contains only one item.\n\n    If you override this method, you should implement it so that it will\n    always return the same value each time it is called.  If your enumerable\n    contains only one object, this method should always return that object.\n    If your enumerable is empty, this method should return undefined.\n\n        var arr = [\"a\", \"b\", \"c\"];\n        arr.firstObject(); => \"a\"\n\n        var arr = [];\n        arr.firstObject(); => undefined\n\n    @returns {Object} the object or undefined\n  */\n  firstObject: Ember.computed(function() {\n    if (get(this, 'length')===0) return undefined ;\n\n    // handle generic enumerables\n    var context = popCtx(), ret;\n    ret = this.nextObject(0, null, context);\n    pushCtx(context);\n    return ret ;\n  }).property('[]').cacheable(),\n\n  /**\n    Helper method returns the last object from a collection. If your enumerable\n    contains only one object, this method should always return that object.\n    If your enumerable is empty, this method should return undefined.\n\n        var arr = [\"a\", \"b\", \"c\"];\n        arr.lastObject(); => \"c\"\n\n        var arr = [];\n        arr.lastObject(); => undefined\n\n    @returns {Object} the last object or undefined\n  */\n  lastObject: Ember.computed(function() {\n    var len = get(this, 'length');\n    if (len===0) return undefined ;\n    var context = popCtx(), idx=0, cur, last = null;\n    do {\n      last = cur;\n      cur = this.nextObject(idx++, last, context);\n    } while (cur !== undefined);\n    pushCtx(context);\n    return last;\n  }).property('[]').cacheable(),\n\n  /**\n    Returns true if the passed object can be found in the receiver.  The\n    default version will iterate through the enumerable until the object\n    is found.  You may want to override this with a more efficient version.\n\n        var arr = [\"a\", \"b\", \"c\"];\n        arr.contains(\"a\"); => true\n        arr.contains(\"z\"); => false\n\n    @param {Object} obj\n      The object to search for.\n\n    @returns {Boolean} true if object is found in enumerable.\n  */\n  contains: function(obj) {\n    return this.find(function(item) { return item===obj; }) !== undefined;\n  },\n\n  /**\n    Iterates through the enumerable, calling the passed function on each\n    item. This method corresponds to the forEach() method defined in\n    JavaScript 1.6.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n          function(item, index, enumerable);\n\n    - *item* is the current item in the iteration.\n    - *index* is the current index in the iteration\n    - *enumerable* is the enumerable object itself.\n\n    Note that in addition to a callback, you can also pass an optional target\n    object that will be set as \"this\" on the context. This is a good way\n    to give your iterator function access to the current object.\n\n    @param {Function} callback The callback to execute\n    @param {Object} [target] The target object to use\n    @returns {Object} receiver\n  */\n  forEach: function(callback, target) {\n    if (typeof callback !== \"function\") throw new TypeError() ;\n    var len = get(this, 'length'), last = null, context = popCtx();\n\n    if (target === undefined) target = null;\n\n    for(var idx=0;idx<len;idx++) {\n      var next = this.nextObject(idx, last, context) ;\n      callback.call(target, next, idx, this);\n      last = next ;\n    }\n    last = null ;\n    context = pushCtx(context);\n    return this ;\n  },\n\n  /**\n    Alias for mapProperty\n\n    @param {String} key name of the property\n    @returns {Array} The mapped array.\n  */\n  getEach: function(key) {\n    return this.mapProperty(key);\n  },\n\n  /**\n    Sets the value on the named property for each member. This is more\n    efficient than using other methods defined on this helper. If the object\n    implements Ember.Observable, the value will be changed to set(), otherwise\n    it will be set directly. null objects are skipped.\n\n    @param {String} key The key to set\n    @param {Object} value The object to set\n    @returns {Object} receiver\n  */\n  setEach: function(key, value) {\n    return this.forEach(function(item) {\n      set(item, key, value);\n    });\n  },\n\n  /**\n    Maps all of the items in the enumeration to another value, returning\n    a new array. This method corresponds to map() defined in JavaScript 1.6.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n        function(item, index, enumerable);\n\n    - *item* is the current item in the iteration.\n    - *index* is the current index in the iteration\n    - *enumerable* is the enumerable object itself.\n\n    It should return the mapped value.\n\n    Note that in addition to a callback, you can also pass an optional target\n    object that will be set as \"this\" on the context. This is a good way\n    to give your iterator function access to the current object.\n\n    @param {Function} callback The callback to execute\n    @param {Object} [target] The target object to use\n    @returns {Array} The mapped array.\n  */\n  map: function(callback, target) {\n    var ret = [];\n    this.forEach(function(x, idx, i) {\n      ret[idx] = callback.call(target, x, idx,i);\n    });\n    return ret ;\n  },\n\n  /**\n    Similar to map, this specialized function returns the value of the named\n    property on all items in the enumeration.\n\n    @param {String} key name of the property\n    @returns {Array} The mapped array.\n  */\n  mapProperty: function(key) {\n    return this.map(function(next) {\n      return get(next, key);\n    });\n  },\n\n  /**\n    Returns an array with all of the items in the enumeration that the passed\n    function returns true for. This method corresponds to filter() defined in\n    JavaScript 1.6.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n          function(item, index, enumerable);\n\n    - *item* is the current item in the iteration.\n    - *index* is the current index in the iteration\n    - *enumerable* is the enumerable object itself.\n\n    It should return the true to include the item in the results, false otherwise.\n\n    Note that in addition to a callback, you can also pass an optional target\n    object that will be set as \"this\" on the context. This is a good way\n    to give your iterator function access to the current object.\n\n    @param {Function} callback The callback to execute\n    @param {Object} [target] The target object to use\n    @returns {Array} A filtered array.\n  */\n  filter: function(callback, target) {\n    var ret = [];\n    this.forEach(function(x, idx, i) {\n      if (callback.call(target, x, idx, i)) ret.push(x);\n    });\n    return ret ;\n  },\n\n  /**\n    Returns an array with just the items with the matched property.  You\n    can pass an optional second argument with the target value.  Otherwise\n    this will match any property that evaluates to true.\n\n    @param {String} key the property to test\n    @param {String} [value] optional value to test against.\n    @returns {Array} filtered array\n  */\n  filterProperty: function(key, value) {\n    return this.filter(iter.apply(this, arguments));\n  },\n\n  /**\n    Returns the first item in the array for which the callback returns true.\n    This method works similar to the filter() method defined in JavaScript 1.6\n    except that it will stop working on the array once a match is found.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n          function(item, index, enumerable);\n\n    - *item* is the current item in the iteration.\n    - *index* is the current index in the iteration\n    - *enumerable* is the enumerable object itself.\n\n    It should return the true to include the item in the results, false otherwise.\n\n    Note that in addition to a callback, you can also pass an optional target\n    object that will be set as \"this\" on the context. This is a good way\n    to give your iterator function access to the current object.\n\n    @param {Function} callback The callback to execute\n    @param {Object} [target] The target object to use\n    @returns {Object} Found item or null.\n  */\n  find: function(callback, target) {\n    var len = get(this, 'length') ;\n    if (target === undefined) target = null;\n\n    var last = null, next, found = false, ret ;\n    var context = popCtx();\n    for(var idx=0;idx<len && !found;idx++) {\n      next = this.nextObject(idx, last, context) ;\n      if (found = callback.call(target, next, idx, this)) ret = next ;\n      last = next ;\n    }\n    next = last = null ;\n    context = pushCtx(context);\n    return ret ;\n  },\n\n  /**\n    Returns the first item with a property matching the passed value.  You\n    can pass an optional second argument with the target value.  Otherwise\n    this will match any property that evaluates to true.\n\n    This method works much like the more generic find() method.\n\n    @param {String} key the property to test\n    @param {String} [value] optional value to test against.\n    @returns {Object} found item or null\n  */\n  findProperty: function(key, value) {\n    return this.find(iter.apply(this, arguments));\n  },\n\n  /**\n    Returns true if the passed function returns true for every item in the\n    enumeration. This corresponds with the every() method in JavaScript 1.6.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n          function(item, index, enumerable);\n\n    - *item* is the current item in the iteration.\n    - *index* is the current index in the iteration\n    - *enumerable* is the enumerable object itself.\n\n    It should return the true or false.\n\n    Note that in addition to a callback, you can also pass an optional target\n    object that will be set as \"this\" on the context. This is a good way\n    to give your iterator function access to the current object.\n\n    Example Usage:\n\n          if (people.every(isEngineer)) { Paychecks.addBigBonus(); }\n\n    @param {Function} callback The callback to execute\n    @param {Object} [target] The target object to use\n    @returns {Boolean}\n  */\n  every: function(callback, target) {\n    return !this.find(function(x, idx, i) {\n      return !callback.call(target, x, idx, i);\n    });\n  },\n\n  /**\n    Returns true if the passed property resolves to true for all items in the\n    enumerable.  This method is often simpler/faster than using a callback.\n\n    @param {String} key the property to test\n    @param {String} [value] optional value to test against.\n    @returns {Array} filtered array\n  */\n  everyProperty: function(key, value) {\n    return this.every(iter.apply(this, arguments));\n  },\n\n\n  /**\n    Returns true if the passed function returns true for any item in the\n    enumeration. This corresponds with the every() method in JavaScript 1.6.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n          function(item, index, enumerable);\n\n    - *item* is the current item in the iteration.\n    - *index* is the current index in the iteration\n    - *enumerable* is the enumerable object itself.\n\n    It should return the true to include the item in the results, false otherwise.\n\n    Note that in addition to a callback, you can also pass an optional target\n    object that will be set as \"this\" on the context. This is a good way\n    to give your iterator function access to the current object.\n\n    Usage Example:\n\n          if (people.some(isManager)) { Paychecks.addBiggerBonus(); }\n\n    @param {Function} callback The callback to execute\n    @param {Object} [target] The target object to use\n    @returns {Array} A filtered array.\n  */\n  some: function(callback, target) {\n    return !!this.find(function(x, idx, i) {\n      return !!callback.call(target, x, idx, i);\n    });\n  },\n\n  /**\n    Returns true if the passed property resolves to true for any item in the\n    enumerable.  This method is often simpler/faster than using a callback.\n\n    @param {String} key the property to test\n    @param {String} [value] optional value to test against.\n    @returns {Boolean} true\n  */\n  someProperty: function(key, value) {\n    return this.some(iter.apply(this, arguments));\n  },\n\n  /**\n    This will combine the values of the enumerator into a single value. It\n    is a useful way to collect a summary value from an enumeration. This\n    corresponds to the reduce() method defined in JavaScript 1.8.\n\n    The callback method you provide should have the following signature (all\n    parameters are optional):\n\n          function(previousValue, item, index, enumerable);\n\n    - *previousValue* is the value returned by the last call to the iterator.\n    - *item* is the current item in the iteration.\n    - *index* is the current index in the iteration\n    - *enumerable* is the enumerable object itself.\n\n    Return the new cumulative value.\n\n    In addition to the callback you can also pass an initialValue. An error\n    will be raised if you do not pass an initial value and the enumerator is\n    empty.\n\n    Note that unlike the other methods, this method does not allow you to\n    pass a target object to set as this for the callback. It's part of the\n    spec. Sorry.\n\n    @param {Function} callback The callback to execute\n    @param {Object} initialValue Initial value for the reduce\n    @param {String} reducerProperty internal use only.\n    @returns {Object} The reduced value.\n  */\n  reduce: function(callback, initialValue, reducerProperty) {\n    if (typeof callback !== \"function\") { throw new TypeError(); }\n\n    var ret = initialValue;\n\n    this.forEach(function(item, i) {\n      ret = callback.call(null, ret, item, i, this, reducerProperty);\n    }, this);\n\n    return ret;\n  },\n\n  /**\n    Invokes the named method on every object in the receiver that\n    implements it.  This method corresponds to the implementation in\n    Prototype 1.6.\n\n    @param {String} methodName the name of the method\n    @param {Object...} args optional arguments to pass as well.\n    @returns {Array} return values from calling invoke.\n  */\n  invoke: function(methodName) {\n    var args, ret = [];\n    if (arguments.length>1) args = a_slice.call(arguments, 1);\n\n    this.forEach(function(x, idx) {\n      var method = x && x[methodName];\n      if ('function' === typeof method) {\n        ret[idx] = args ? method.apply(x, args) : method.call(x);\n      }\n    }, this);\n\n    return ret;\n  },\n\n  /**\n    Simply converts the enumerable into a genuine array.  The order is not\n    guaranteed.  Corresponds to the method implemented by Prototype.\n\n    @returns {Array} the enumerable as an array.\n  */\n  toArray: function() {\n    var ret = [];\n    this.forEach(function(o, idx) { ret[idx] = o; });\n    return ret ;\n  },\n\n  /**\n    Returns a copy of the array with all null elements removed.\n\n        var arr = [\"a\", null, \"c\", null];\n        arr.compact(); => [\"a\", \"c\"]\n\n    @returns {Array} the array without null elements.\n  */\n  compact: function() { return this.without(null); },\n\n  /**\n    Returns a new enumerable that excludes the passed value.  The default\n    implementation returns an array regardless of the receiver type unless\n    the receiver does not contain the value.\n\n        var arr = [\"a\", \"b\", \"a\", \"c\"];\n        arr.without(\"a\"); => [\"b\", \"c\"]\n\n    @param {Object} value\n    @returns {Ember.Enumerable}\n  */\n  without: function(value) {\n    if (!this.contains(value)) return this; // nothing to do\n    var ret = [] ;\n    this.forEach(function(k) {\n      if (k !== value) ret[ret.length] = k;\n    }) ;\n    return ret ;\n  },\n\n  /**\n    Returns a new enumerable that contains only unique values.  The default\n    implementation returns an array regardless of the receiver type.\n\n        var arr = [\"a\", \"a\", \"b\", \"b\"];\n        arr.uniq(); => [\"a\", \"b\"]\n\n    @returns {Ember.Enumerable}\n  */\n  uniq: function() {\n    var ret = [];\n    this.forEach(function(k){\n      if (a_indexOf(ret, k)<0) ret.push(k);\n    });\n    return ret;\n  },\n\n  /**\n    This property will trigger anytime the enumerable's content changes.\n    You can observe this property to be notified of changes to the enumerables\n    content.\n\n    For plain enumerables, this property is read only.  Ember.Array overrides\n    this method.\n\n    @type Ember.Array\n  */\n  '[]': Ember.computed(function(key, value) {\n    return this;\n  }).property().cacheable(),\n\n  // ..........................................................\n  // ENUMERABLE OBSERVERS\n  //\n\n  /**\n    Registers an enumerable observer.   Must implement Ember.EnumerableObserver\n    mixin.\n  */\n  addEnumerableObserver: function(target, opts) {\n    var willChange = (opts && opts.willChange) || 'enumerableWillChange',\n        didChange  = (opts && opts.didChange) || 'enumerableDidChange';\n\n    var hasObservers = get(this, 'hasEnumerableObservers');\n    if (!hasObservers) Ember.propertyWillChange(this, 'hasEnumerableObservers');\n    Ember.addListener(this, '@enumerable:before', target, willChange);\n    Ember.addListener(this, '@enumerable:change', target, didChange);\n    if (!hasObservers) Ember.propertyDidChange(this, 'hasEnumerableObservers');\n    return this;\n  },\n\n  /**\n    Removes a registered enumerable observer.\n  */\n  removeEnumerableObserver: function(target, opts) {\n    var willChange = (opts && opts.willChange) || 'enumerableWillChange',\n        didChange  = (opts && opts.didChange) || 'enumerableDidChange';\n\n    var hasObservers = get(this, 'hasEnumerableObservers');\n    if (hasObservers) Ember.propertyWillChange(this, 'hasEnumerableObservers');\n    Ember.removeListener(this, '@enumerable:before', target, willChange);\n    Ember.removeListener(this, '@enumerable:change', target, didChange);\n    if (hasObservers) Ember.propertyDidChange(this, 'hasEnumerableObservers');\n    return this;\n  },\n\n  /**\n    Becomes true whenever the array currently has observers watching changes\n    on the array.\n\n    @type Boolean\n  */\n  hasEnumerableObservers: Ember.computed(function() {\n    return Ember.hasListeners(this, '@enumerable:change') || Ember.hasListeners(this, '@enumerable:before');\n  }).property().cacheable(),\n\n\n  /**\n    Invoke this method just before the contents of your enumerable will\n    change.  You can either omit the parameters completely or pass the objects\n    to be removed or added if available or just a count.\n\n    @param {Ember.Enumerable|Number} removing\n      An enumerable of the objects to be removed or the number of items to\n      be removed.\n\n    @param {Ember.Enumerable|Number} adding\n      An enumerable of the objects to be added or the number of items to be\n      added.\n\n    @returns {Ember.Enumerable} receiver\n  */\n  enumerableContentWillChange: function(removing, adding) {\n\n    var removeCnt, addCnt, hasDelta;\n\n    if ('number' === typeof removing) removeCnt = removing;\n    else if (removing) removeCnt = get(removing, 'length');\n    else removeCnt = removing = -1;\n\n    if ('number' === typeof adding) addCnt = adding;\n    else if (adding) addCnt = get(adding,'length');\n    else addCnt = adding = -1;\n\n    hasDelta = addCnt<0 || removeCnt<0 || addCnt-removeCnt!==0;\n\n    if (removing === -1) removing = null;\n    if (adding   === -1) adding   = null;\n\n    Ember.propertyWillChange(this, '[]');\n    if (hasDelta) Ember.propertyWillChange(this, 'length');\n    Ember.sendEvent(this, '@enumerable:before', [this, removing, adding]);\n\n    return this;\n  },\n\n  /**\n    Invoke this method when the contents of your enumerable has changed.\n    This will notify any observers watching for content changes.  If your are\n    implementing an ordered enumerable (such as an array), also pass the\n    start and end values where the content changed so that it can be used to\n    notify range observers.\n\n    @param {Number} start\n      optional start offset for the content change.  For unordered\n      enumerables, you should always pass -1.\n\n    @param {Ember.Enumerable|Number} removing\n      An enumerable of the objects to be removed or the number of items to\n      be removed.\n\n    @param {Ember.Enumerable|Number} adding\n      An enumerable of the objects to be added or the number of items to be\n      added.\n\n    @returns {Object} receiver\n  */\n  enumerableContentDidChange: function(removing, adding) {\n    var notify = this.propertyDidChange, removeCnt, addCnt, hasDelta;\n\n    if ('number' === typeof removing) removeCnt = removing;\n    else if (removing) removeCnt = get(removing, 'length');\n    else removeCnt = removing = -1;\n\n    if ('number' === typeof adding) addCnt = adding;\n    else if (adding) addCnt = get(adding, 'length');\n    else addCnt = adding = -1;\n\n    hasDelta = addCnt<0 || removeCnt<0 || addCnt-removeCnt!==0;\n\n    if (removing === -1) removing = null;\n    if (adding   === -1) adding   = null;\n\n    Ember.sendEvent(this, '@enumerable:change', [this, removing, adding]);\n    if (hasDelta) Ember.propertyDidChange(this, 'length');\n    Ember.propertyDidChange(this, '[]');\n\n    return this ;\n  }\n\n}) ;\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/mixins/enumerable");