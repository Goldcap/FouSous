minispade.register('ember-runtime/mixins/observable', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar get = Ember.get, set = Ember.set, defineProperty = Ember.defineProperty;\n\n/**\n  @class\n\n  ## Overview\n  \n  This mixin provides properties and property observing functionality, core\n  features of the Ember object model.\n  \n  Properties and observers allow one object to observe changes to a\n  property on another object. This is one of the fundamental ways that\n  models, controllers and views communicate with each other in an Ember\n  application.\n  \n  Any object that has this mixin applied can be used in observer\n  operations. That includes Ember.Object and most objects you will\n  interact with as you write your Ember application.\n\n  Note that you will not generally apply this mixin to classes yourself,\n  but you will use the features provided by this module frequently, so it\n  is important to understand how to use it.\n  \n  ## Using get() and set()\n  \n  Because of Ember's support for bindings and observers, you will always\n  access properties using the get method, and set properties using the\n  set method. This allows the observing objects to be notified and\n  computed properties to be handled properly.\n  \n  More documentation about `get` and `set` are below.\n  \n  ## Observing Property Changes\n\n  You typically observe property changes simply by adding the `observes`\n  call to the end of your method declarations in classes that you write.\n  For example:\n\n      Ember.Object.create({\n        valueObserver: function() {\n          // Executes whenever the \"value\" property changes\n        }.observes('value')\n      });\n    \n  Although this is the most common way to add an observer, this capability\n  is actually built into the Ember.Object class on top of two methods\n  defined in this mixin: `addObserver` and `removeObserver`. You can use\n  these two methods to add and remove observers yourself if you need to\n  do so at runtime.\n\n  To add an observer for a property, call:\n\n      object.addObserver('propertyKey', targetObject, targetAction)\n\n  This will call the `targetAction` method on the `targetObject` to be called\n  whenever the value of the `propertyKey` changes.\n  \n  Note that if `propertyKey` is a computed property, the observer will be \n  called when any of the property dependencies are changed, even if the \n  resulting value of the computed property is unchanged. This is necessary\n  because computed properties are not computed until `get` is called.\n  \n  @extends Ember.Mixin\n*/\nEmber.Observable = Ember.Mixin.create(/** @scope Ember.Observable.prototype */ {\n\n  /** @private - compatibility */\n  isObserverable: true,\n\n  /**\n    Retrieves the value of a property from the object.\n\n    This method is usually similar to using object[keyName] or object.keyName,\n    however it supports both computed properties and the unknownProperty\n    handler.\n    \n    Because `get` unifies the syntax for accessing all these kinds\n    of properties, it can make many refactorings easier, such as replacing a\n    simple property with a computed property, or vice versa.\n\n    ### Computed Properties\n\n    Computed properties are methods defined with the `property` modifier\n    declared at the end, such as:\n\n          fullName: function() {\n            return this.getEach('firstName', 'lastName').compact().join(' ');\n          }.property('firstName', 'lastName')\n\n    When you call `get` on a computed property, the function will be\n    called and the return value will be returned instead of the function\n    itself.\n\n    ### Unknown Properties\n\n    Likewise, if you try to call `get` on a property whose value is\n    undefined, the unknownProperty() method will be called on the object.\n    If this method returns any value other than undefined, it will be returned\n    instead. This allows you to implement \"virtual\" properties that are\n    not defined upfront.\n\n    @param {String} key The property to retrieve\n    @returns {Object} The property value or undefined.\n  */\n  get: function(keyName) {\n    return get(this, keyName);\n  },\n\n  /**\n    To get multiple properties at once, call getProperties\n    with a list of strings or an array:\n\n          record.getProperties('firstName', 'lastName', 'zipCode'); // => { firstName: 'John', lastName: 'Doe', zipCode: '10011' }\n\n   is equivalent to:\n\n          record.getProperties(['firstName', 'lastName', 'zipCode']); // => { firstName: 'John', lastName: 'Doe', zipCode: '10011' }\n\n    @param {String...|Array} list of keys to get\n    @returns {Hash}\n  */\n  getProperties: function() {\n    var ret = {};\n    var propertyNames = arguments;\n    if (arguments.length === 1 && Ember.typeOf(arguments[0]) === 'array') {\n      propertyNames = arguments[0];\n    }\n    for(var i = 0; i < propertyNames.length; i++) {\n      ret[propertyNames[i]] = get(this, propertyNames[i]);\n    }\n    return ret;\n  },\n\n  /**\n    Sets the provided key or path to the value.\n\n    This method is generally very similar to calling object[key] = value or\n    object.key = value, except that it provides support for computed\n    properties, the unknownProperty() method and property observers.\n\n    ### Computed Properties\n\n    If you try to set a value on a key that has a computed property handler\n    defined (see the get() method for an example), then set() will call\n    that method, passing both the value and key instead of simply changing\n    the value itself. This is useful for those times when you need to\n    implement a property that is composed of one or more member\n    properties.\n\n    ### Unknown Properties\n\n    If you try to set a value on a key that is undefined in the target\n    object, then the unknownProperty() handler will be called instead. This\n    gives you an opportunity to implement complex \"virtual\" properties that\n    are not predefined on the object. If unknownProperty() returns\n    undefined, then set() will simply set the value on the object.\n\n    ### Property Observers\n\n    In addition to changing the property, set() will also register a\n    property change with the object. Unless you have placed this call\n    inside of a beginPropertyChanges() and endPropertyChanges(), any \"local\"\n    observers (i.e. observer methods declared on the same object), will be\n    called immediately. Any \"remote\" observers (i.e. observer methods\n    declared on another object) will be placed in a queue and called at a\n    later time in a coalesced manner.\n\n    ### Chaining\n\n    In addition to property changes, set() returns the value of the object\n    itself so you can do chaining like this:\n\n          record.set('firstName', 'Charles').set('lastName', 'Jolley');\n\n    @param {String} key The property to set\n    @param {Object} value The value to set or null.\n    @returns {Ember.Observable}\n  */\n  set: function(keyName, value) {\n    set(this, keyName, value);\n    return this;\n  },\n\n  /**\n    To set multiple properties at once, call setProperties\n    with a Hash:\n\n          record.setProperties({ firstName: 'Charles', lastName: 'Jolley' });\n\n    @param {Hash} hash the hash of keys and values to set\n    @returns {Ember.Observable}\n  */\n  setProperties: function(hash) {\n    return Ember.setProperties(this, hash);\n  },\n\n  /**\n    Begins a grouping of property changes.\n\n    You can use this method to group property changes so that notifications\n    will not be sent until the changes are finished. If you plan to make a\n    large number of changes to an object at one time, you should call this\n    method at the beginning of the changes to begin deferring change\n    notifications. When you are done making changes, call endPropertyChanges()\n    to deliver the deferred change notifications and end deferring.\n\n    @returns {Ember.Observable}\n  */\n  beginPropertyChanges: function() {\n    Ember.beginPropertyChanges();\n    return this;\n  },\n\n  /**\n    Ends a grouping of property changes.\n\n    You can use this method to group property changes so that notifications\n    will not be sent until the changes are finished. If you plan to make a\n    large number of changes to an object at one time, you should call\n    beginPropertyChanges() at the beginning of the changes to defer change\n    notifications. When you are done making changes, call this method to\n    deliver the deferred change notifications and end deferring.\n\n    @returns {Ember.Observable}\n  */\n  endPropertyChanges: function() {\n    Ember.endPropertyChanges();\n    return this;\n  },\n\n  /**\n    Notify the observer system that a property is about to change.\n\n    Sometimes you need to change a value directly or indirectly without\n    actually calling get() or set() on it. In this case, you can use this\n    method and propertyDidChange() instead. Calling these two methods\n    together will notify all observers that the property has potentially\n    changed value.\n\n    Note that you must always call propertyWillChange and propertyDidChange as\n    a pair. If you do not, it may get the property change groups out of order\n    and cause notifications to be delivered more often than you would like.\n\n    @param {String} key The property key that is about to change.\n    @returns {Ember.Observable}\n  */\n  propertyWillChange: function(keyName){\n    Ember.propertyWillChange(this, keyName);\n    return this;\n  },\n\n  /**\n    Notify the observer system that a property has just changed.\n\n    Sometimes you need to change a value directly or indirectly without\n    actually calling get() or set() on it. In this case, you can use this\n    method and propertyWillChange() instead. Calling these two methods\n    together will notify all observers that the property has potentially\n    changed value.\n\n    Note that you must always call propertyWillChange and propertyDidChange as\n    a pair. If you do not, it may get the property change groups out of order\n    and cause notifications to be delivered more often than you would like.\n\n    @param {String} keyName The property key that has just changed.\n    @returns {Ember.Observable}\n  */\n  propertyDidChange: function(keyName) {\n    Ember.propertyDidChange(this, keyName);\n    return this;\n  },\n  \n  /**\n    Convenience method to call `propertyWillChange` and `propertyDidChange` in\n    succession.\n  \n    @param {String} keyName The property key to be notified about.\n    @returns {Ember.Observable}\n  */\n  notifyPropertyChange: function(keyName) {\n    this.propertyWillChange(keyName);\n    this.propertyDidChange(keyName);\n    return this;\n  },\n\n  addBeforeObserver: function(key, target, method) {\n    Ember.addBeforeObserver(this, key, target, method);\n  },\n\n  /**\n    Adds an observer on a property.\n\n    This is the core method used to register an observer for a property.\n\n    Once you call this method, anytime the key's value is set, your observer\n    will be notified. Note that the observers are triggered anytime the\n    value is set, regardless of whether it has actually changed. Your\n    observer should be prepared to handle that.\n\n    You can also pass an optional context parameter to this method. The\n    context will be passed to your observer method whenever it is triggered.\n    Note that if you add the same target/method pair on a key multiple times\n    with different context parameters, your observer will only be called once\n    with the last context you passed.\n\n    ### Observer Methods\n\n    Observer methods you pass should generally have the following signature if\n    you do not pass a \"context\" parameter:\n\n          fooDidChange: function(sender, key, value, rev);\n\n    The sender is the object that changed. The key is the property that\n    changes. The value property is currently reserved and unused. The rev\n    is the last property revision of the object when it changed, which you can\n    use to detect if the key value has really changed or not.\n\n    If you pass a \"context\" parameter, the context will be passed before the\n    revision like so:\n\n          fooDidChange: function(sender, key, value, context, rev);\n\n    Usually you will not need the value, context or revision parameters at\n    the end. In this case, it is common to write observer methods that take\n    only a sender and key value as parameters or, if you aren't interested in\n    any of these values, to write an observer that has no parameters at all.\n\n    @param {String} key The key to observer\n    @param {Object} target The target object to invoke\n    @param {String|Function} method The method to invoke.\n    @returns {Ember.Object} self\n  */\n  addObserver: function(key, target, method) {\n    Ember.addObserver(this, key, target, method);\n  },\n\n  /**\n    Remove an observer you have previously registered on this object. Pass\n    the same key, target, and method you passed to addObserver() and your\n    target will no longer receive notifications.\n\n    @param {String} key The key to observer\n    @param {Object} target The target object to invoke\n    @param {String|Function} method The method to invoke.\n    @returns {Ember.Observable} receiver\n  */\n  removeObserver: function(key, target, method) {\n    Ember.removeObserver(this, key, target, method);\n  },\n\n  /**\n    Returns true if the object currently has observers registered for a\n    particular key. You can use this method to potentially defer performing\n    an expensive action until someone begins observing a particular property\n    on the object.\n\n    @param {String} key Key to check\n    @returns {Boolean}\n  */\n  hasObserverFor: function(key) {\n    return Ember.hasListeners(this, key+':change');\n  },\n\n  /**\n    This method will be called when a client attempts to get the value of a\n    property that has not been defined in one of the typical ways. Override\n    this method to create \"virtual\" properties.\n    \n    @param {String} key The name of the unknown property that was requested.\n    @returns {Object} The property value or undefined. Default is undefined.\n  */\n  unknownProperty: function(key) {\n    return undefined;\n  },\n\n  /**\n    This method will be called when a client attempts to set the value of a\n    property that has not been defined in one of the typical ways. Override\n    this method to create \"virtual\" properties.\n    \n    @param {String} key The name of the unknown property to be set.\n    @param {Object} value The value the unknown property is to be set to.\n  */\n  setUnknownProperty: function(key, value) {\n    defineProperty(this, key);\n    set(this, key, value);\n  },\n\n  /**\n    @deprecated\n    @param {String} path The property path to retrieve\n    @returns {Object} The property value or undefined.\n  */\n  getPath: function(path) {\n    Ember.deprecate(\"getPath is deprecated since get now supports paths\");\n    return this.get(path);\n  },\n\n  /**\n    @deprecated\n    @param {String} path The path to the property that will be set\n    @param {Object} value The value to set or null.\n    @returns {Ember.Observable}\n  */\n  setPath: function(path, value) {\n    Ember.deprecate(\"setPath is deprecated since set now supports paths\");\n    return this.set(path, value);\n  },\n\n  /**\n    Retrieves the value of a property, or a default value in the case that the property\n    returns undefined.\n    \n        person.getWithDefault('lastName', 'Doe');\n    \n    @param {String} keyName The name of the property to retrieve\n    @param {Object} defaultValue The value to return if the property value is undefined\n    @returns {Object} The property value or the defaultValue.\n  */\n  getWithDefault: function(keyName, defaultValue) {\n    return Ember.getWithDefault(this, keyName, defaultValue);\n  },\n\n  /**\n    Set the value of a property to the current value plus some amount.\n    \n        person.incrementProperty('age');\n        team.incrementProperty('score', 2);\n    \n    @param {String} keyName The name of the property to increment\n    @param {Object} increment The amount to increment by. Defaults to 1\n    @returns {Object} The new property value\n  */\n  incrementProperty: function(keyName, increment) {\n    if (!increment) { increment = 1; }\n    set(this, keyName, (get(this, keyName) || 0)+increment);\n    return get(this, keyName);\n  },\n  \n  /**\n    Set the value of a property to the current value minus some amount.\n    \n        player.decrementProperty('lives');\n        orc.decrementProperty('health', 5);\n    \n    @param {String} keyName The name of the property to decrement\n    @param {Object} increment The amount to decrement by. Defaults to 1\n    @returns {Object} The new property value\n  */\n  decrementProperty: function(keyName, increment) {\n    if (!increment) { increment = 1; }\n    set(this, keyName, (get(this, keyName) || 0)-increment);\n    return get(this, keyName);\n  },\n\n  /**\n    Set the value of a boolean property to the opposite of it's\n    current value.\n    \n        starship.toggleProperty('warpDriveEnaged');\n    \n    @param {String} keyName The name of the property to toggle\n    @returns {Object} The new property value\n  */\n  toggleProperty: function(keyName) {\n    set(this, keyName, !get(this, keyName));\n    return get(this, keyName);\n  },\n\n  /**\n    Returns the cached value of a computed property, if it exists.\n    This allows you to inspect the value of a computed property\n    without accidentally invoking it if it is intended to be\n    generated lazily.\n\n    @param {String} keyName\n    @returns {Object} The cached value of the computed property, if any\n  */\n  cacheFor: function(keyName) {\n    return Ember.cacheFor(this, keyName);\n  },\n\n  /** @private - intended for debugging purposes */\n  observersForKey: function(keyName) {\n    return Ember.observersFor(this, keyName);\n  }\n});\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/mixins/observable");