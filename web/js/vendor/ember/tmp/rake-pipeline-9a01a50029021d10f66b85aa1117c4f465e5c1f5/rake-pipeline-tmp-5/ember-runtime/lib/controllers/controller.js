minispade.register('ember-runtime/controllers/controller', "(function() {minispade.require('ember-runtime/system/object');\nminispade.require('ember-runtime/system/string');\n\n/**\n  @class\n  \n  Ember.ControllerMixin provides a standard interface for all classes\n  that compose Ember's controller layer: Ember.Controller, Ember.ArrayController,\n  and Ember.ObjectController.\n  \n  Within an Ember.Router-managed application single shared instaces of every\n  Controller object in your application's namespace will be added to the\n  application's Ember.Router instance. See `Ember.Application#initialize`\n  for additional information.\n  \n  ## Views\n  By default a controller instance will be the rendering context\n  for its associated Ember.View. This connection is made during calls to\n  `Ember.ControllerMixin#connectOutlet`.\n  \n  Within the view's template, the Ember.View instance can be accessed\n  through the controller with `{{view}}`.\n  \n  ## Target Forwarding\n  By default a controller will target your application's Ember.Router instance.\n  Calls to `{{action}}` within the template of a controller's view are forwarded\n  to the router. See `Ember.Handlebars.helpers.action` for additional information.\n  \n  @extends Ember.Mixin\n*/\nEmber.ControllerMixin = Ember.Mixin.create({\n  /**\n    The object to which events from the view should be sent.\n\n    For example, when a Handlebars template uses the `{{action}}` helper,\n    it will attempt to send the event to the view's controller's `target`.\n\n    By default, a controller's `target` is set to the router after it is\n    instantiated by `Ember.Application#initialize`.\n  */\n  target: null,\n  store: null\n});\n\nEmber.Controller = Ember.Object.extend(Ember.ControllerMixin);\n\n})();\n//@ sourceURL=ember-runtime/controllers/controller");