minispade.register('ember-runtime/ext/function', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            Portions ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-runtime/core');\n\nvar a_slice = Array.prototype.slice;\n\nif (Ember.EXTEND_PROTOTYPES) {\n\n  /**\n    The `property` extension of Javascript's Function prototype is available\n    when Ember.EXTEND_PROTOTYPES is true, which is the default. \n\n    Computed properties allow you to treat a function like a property:\n\n        MyApp.president = Ember.Object.create({\n          firstName: \"Barack\",\n          lastName: \"Obama\",\n\n          fullName: function() {\n            return this.get('firstName') + ' ' + this.get('lastName');\n\n            // Call this flag to mark the function as a property\n          }.property()\n        });\n\n        MyApp.president.get('fullName');    => \"Barack Obama\"\n\n    Treating a function like a property is useful because they can work with\n    bindings, just like any other property.\n\n    Many computed properties have dependencies on other properties. For\n    example, in the above example, the `fullName` property depends on\n    `firstName` and `lastName` to determine its value. You can tell Ember.js\n    about these dependencies like this:\n\n        MyApp.president = Ember.Object.create({\n          firstName: \"Barack\",\n          lastName: \"Obama\",\n\n          fullName: function() {\n            return this.get('firstName') + ' ' + this.get('lastName');\n\n            // Tell Ember.js that this computed property depends on firstName\n            // and lastName\n          }.property('firstName', 'lastName')\n        });\n\n    Make sure you list these dependencies so Ember.js knows when to update\n    bindings that connect to a computed property. Changing a dependency\n    will not immediately trigger an update of the computed property, but\n    will instead clear the cache so that it is updated when the next `get`\n    is called on the property.\n\n    Note: you will usually want to use `property(...)` with `cacheable()`.\n\n    @see Ember.ComputedProperty\n    @see Ember.computed\n  */\n  Function.prototype.property = function() {\n    var ret = Ember.computed(this);\n    return ret.property.apply(ret, arguments);\n  };\n\n  /**\n    The `observes` extension of Javascript's Function prototype is available\n    when Ember.EXTEND_PROTOTYPES is true, which is the default. \n\n    You can observe property changes simply by adding the `observes`\n    call to the end of your method declarations in classes that you write.\n    For example:\n\n        Ember.Object.create({\n          valueObserver: function() {\n            // Executes whenever the \"value\" property changes\n          }.observes('value')\n        });\n    \n    @see Ember.Observable\n  */\n  Function.prototype.observes = function() {\n    this.__ember_observes__ = a_slice.call(arguments);\n    return this;\n  };\n\n  /**\n    The `observesBefore` extension of Javascript's Function prototype is\n    available when Ember.EXTEND_PROTOTYPES is true, which is the default. \n\n    You can get notified when a property changes is about to happen by\n    by adding the `observesBefore` call to the end of your method\n    declarations in classes that you write. For example:\n\n        Ember.Object.create({\n          valueObserver: function() {\n            // Executes whenever the \"value\" property is about to change\n          }.observesBefore('value')\n        });\n    \n    @see Ember.Observable\n  */\n  Function.prototype.observesBefore = function() {\n    this.__ember_observesBefore__ = a_slice.call(arguments);\n    return this;\n  };\n\n}\n\n\n})();\n//@ sourceURL=ember-runtime/ext/function");