minispade.register('ember-runtime/system/array_proxy', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-runtime/mixins/mutable_array');\nminispade.require('ember-runtime/system/object');\n\n\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  @class\n\n  An ArrayProxy wraps any other object that implements Ember.Array and/or\n  Ember.MutableArray, forwarding all requests. This makes it very useful for\n  a number of binding use cases or other cases where being able to swap\n  out the underlying array is useful.\n\n  A simple example of usage:\n\n      var pets = ['dog', 'cat', 'fish'];\n      var ap = Ember.ArrayProxy.create({ content: Ember.A(pets) });\n      ap.get('firstObject'); // => 'dog'\n      ap.set('content', ['amoeba', 'paramecium']);\n      ap.get('firstObject'); // => 'amoeba'\n\n  This class can also be useful as a layer to transform the contents of\n  an array, as they are accessed. This can be done by overriding\n  `objectAtContent`:\n\n      var pets = ['dog', 'cat', 'fish'];\n      var ap = Ember.ArrayProxy.create({\n          content: Ember.A(pets),\n          objectAtContent: function(idx) {\n              return this.get('content').objectAt(idx).toUpperCase();\n          }\n      });\n      ap.get('firstObject'); // => 'DOG'\n\n\n  @extends Ember.Object\n  @extends Ember.Array\n  @extends Ember.MutableArray\n*/\nEmber.ArrayProxy = Ember.Object.extend(Ember.MutableArray,\n/** @scope Ember.ArrayProxy.prototype */ {\n\n  /**\n    The content array.  Must be an object that implements Ember.Array and/or\n    Ember.MutableArray.\n\n    @type Ember.Array\n  */\n  content: null,\n\n  /**\n   The array that the proxy pretends to be. In the default `ArrayProxy`\n   implementation, this and `content` are the same. Subclasses of `ArrayProxy`\n   can override this property to provide things like sorting and filtering.\n  */\n  arrangedContent: Ember.computed('content', function() {\n    return get(this, 'content');\n  }).cacheable(),\n\n  /**\n    Should actually retrieve the object at the specified index from the\n    content. You can override this method in subclasses to transform the\n    content item to something new.\n\n    This method will only be called if content is non-null.\n\n    @param {Number} idx\n      The index to retrieve.\n\n    @returns {Object} the value or undefined if none found\n  */\n  objectAtContent: function(idx) {\n    return get(this, 'arrangedContent').objectAt(idx);\n  },\n\n  /**\n    Should actually replace the specified objects on the content array.\n    You can override this method in subclasses to transform the content item\n    into something new.\n\n    This method will only be called if content is non-null.\n\n    @param {Number} idx\n      The starting index\n\n    @param {Number} amt\n      The number of items to remove from the content.\n\n    @param {Array} objects\n      Optional array of objects to insert or null if no objects.\n\n    @returns {void}\n  */\n  replaceContent: function(idx, amt, objects) {\n    get(this, 'arrangedContent').replace(idx, amt, objects);\n  },\n\n  /**\n    Invoked when the content property is about to change. Notifies observers that the\n    entire array content will change.\n  */\n  _contentWillChange: Ember.beforeObserver(function() {\n    this._teardownContent();\n  }, 'content'),\n\n  _teardownContent: function() {\n    var content = get(this, 'content');\n\n    if (content) {\n      content.removeArrayObserver(this, {\n        willChange: 'contentArrayWillChange',\n        didChange: 'contentArrayDidChange'\n      });\n    }\n  },\n\n  contentArrayWillChange: Ember.K,\n  contentArrayDidChange: Ember.K,\n\n  /**\n    Invoked when the content property changes.  Notifies observers that the\n    entire array content has changed.\n  */\n  _contentDidChange: Ember.observer(function() {\n    var content = get(this, 'content');\n\n    Ember.assert(\"Can't set ArrayProxy's content to itself\", content !== this);\n\n    this._setupContent();\n  }, 'content'),\n\n  _setupContent: function() {\n    var content = get(this, 'content');\n\n    if (content) {\n      content.addArrayObserver(this, {\n        willChange: 'contentArrayWillChange',\n        didChange: 'contentArrayDidChange'\n      });\n    }\n  },\n\n  _arrangedContentWillChange: Ember.beforeObserver(function() {\n    var arrangedContent = get(this, 'arrangedContent'),\n        len = arrangedContent ? get(arrangedContent, 'length') : 0;\n\n    this.arrangedContentArrayWillChange(this, 0, len, undefined);\n    this.arrangedContentWillChange(this);\n\n    this._teardownArrangedContent(arrangedContent);\n  }, 'arrangedContent'),\n\n  _arrangedContentDidChange: Ember.observer(function() {\n    var arrangedContent = get(this, 'arrangedContent'),\n        len = arrangedContent ? get(arrangedContent, 'length') : 0;\n\n    Ember.assert(\"Can't set ArrayProxy's content to itself\", arrangedContent !== this);\n\n    this._setupArrangedContent();\n\n    this.arrangedContentDidChange(this);\n    this.arrangedContentArrayDidChange(this, 0, undefined, len);\n  }, 'arrangedContent'),\n\n  _setupArrangedContent: function() {\n    var arrangedContent = get(this, 'arrangedContent');\n\n    if (arrangedContent) {\n      arrangedContent.addArrayObserver(this, {\n        willChange: 'arrangedContentArrayWillChange',\n        didChange: 'arrangedContentArrayDidChange'\n      });\n    }\n  },\n\n  _teardownArrangedContent: function() {\n    var arrangedContent = get(this, 'arrangedContent');\n\n    if (arrangedContent) {\n      arrangedContent.removeArrayObserver(this, {\n        willChange: 'arrangedContentArrayWillChange',\n        didChange: 'arrangedContentArrayDidChange'\n      });\n    }\n  },\n\n  arrangedContentWillChange: Ember.K,\n  arrangedContentDidChange: Ember.K,\n\n  /** @private (nodoc) */\n  objectAt: function(idx) {\n    return get(this, 'content') && this.objectAtContent(idx);\n  },\n\n  /** @private (nodoc) */\n  length: Ember.computed(function() {\n    var arrangedContent = get(this, 'arrangedContent');\n    return arrangedContent ? get(arrangedContent, 'length') : 0;\n    // No dependencies since Enumerable notifies length of change\n  }).property().cacheable(),\n\n  /** @private (nodoc) */\n  replace: function(idx, amt, objects) {\n    if (get(this, 'content')) this.replaceContent(idx, amt, objects);\n    return this;\n  },\n\n  /** @private (nodoc) */\n  arrangedContentArrayWillChange: function(item, idx, removedCnt, addedCnt) {\n    this.arrayContentWillChange(idx, removedCnt, addedCnt);\n  },\n\n  /** @private (nodoc) */\n  arrangedContentArrayDidChange: function(item, idx, removedCnt, addedCnt) {\n    this.arrayContentDidChange(idx, removedCnt, addedCnt);\n  },\n\n  /** @private (nodoc) */\n  init: function() {\n    this._super();\n    this._setupContent();\n    this._setupArrangedContent();\n  },\n\n  willDestroy: function() {\n    this._teardownArrangedContent();\n    this._teardownContent();\n  }\n});\n\n\n})();\n//@ sourceURL=ember-runtime/system/array_proxy");