minispade.register('ember-runtime/system/set', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-runtime/core');\nminispade.require('ember-runtime/system/core_object');\nminispade.require('ember-runtime/mixins/mutable_enumerable');\nminispade.require('ember-runtime/mixins/copyable');\nminispade.require('ember-runtime/mixins/freezable');\n\nvar get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, none = Ember.none;\n\n/**\n  @class\n\n  An unordered collection of objects.\n\n  A Set works a bit like an array except that its items are not ordered.\n  You can create a set to efficiently test for membership for an object. You\n  can also iterate through a set just like an array, even accessing objects\n  by index, however there is no guarantee as to their order.\n\n  All Sets are observable via the Enumerable Observer API - which works\n  on any enumerable object including both Sets and Arrays.\n\n  ## Creating a Set\n\n  You can create a set like you would most objects using\n  `new Ember.Set()`.  Most new sets you create will be empty, but you can\n  also initialize the set with some content by passing an array or other\n  enumerable of objects to the constructor.\n\n  Finally, you can pass in an existing set and the set will be copied. You\n  can also create a copy of a set by calling `Ember.Set#copy()`.\n\n      #js\n      // creates a new empty set\n      var foundNames = new Ember.Set();\n\n      // creates a set with four names in it.\n      var names = new Ember.Set([\"Charles\", \"Tom\", \"Juan\", \"Alex\"]); // :P\n\n      // creates a copy of the names set.\n      var namesCopy = new Ember.Set(names);\n\n      // same as above.\n      var anotherNamesCopy = names.copy();\n\n  ## Adding/Removing Objects\n\n  You generally add or remove objects from a set using `add()` or\n  `remove()`. You can add any type of object including primitives such as\n  numbers, strings, and booleans.\n\n  Unlike arrays, objects can only exist one time in a set. If you call `add()`\n  on a set with the same object multiple times, the object will only be added\n  once. Likewise, calling `remove()` with the same object multiple times will\n  remove the object the first time and have no effect on future calls until\n  you add the object to the set again.\n\n  NOTE: You cannot add/remove null or undefined to a set. Any attempt to do so\n  will be ignored.\n\n  In addition to add/remove you can also call `push()`/`pop()`. Push behaves\n  just like `add()` but `pop()`, unlike `remove()` will pick an arbitrary\n  object, remove it and return it. This is a good way to use a set as a job\n  queue when you don't care which order the jobs are executed in.\n\n  ## Testing for an Object\n\n  To test for an object's presence in a set you simply call\n  `Ember.Set#contains()`.\n\n  ## Observing changes\n\n  When using `Ember.Set`, you can observe the `\"[]\"` property to be\n  alerted whenever the content changes.  You can also add an enumerable\n  observer to the set to be notified of specific objects that are added and\n  removed from the set.  See `Ember.Enumerable` for more information on\n  enumerables.\n\n  This is often unhelpful. If you are filtering sets of objects, for instance,\n  it is very inefficient to re-filter all of the items each time the set\n  changes. It would be better if you could just adjust the filtered set based\n  on what was changed on the original set. The same issue applies to merging\n  sets, as well.\n\n  ## Other Methods\n\n  `Ember.Set` primary implements other mixin APIs.  For a complete reference\n  on the methods you will use with `Ember.Set`, please consult these mixins.\n  The most useful ones will be `Ember.Enumerable` and\n  `Ember.MutableEnumerable` which implement most of the common iterator\n  methods you are used to on Array.\n\n  Note that you can also use the `Ember.Copyable` and `Ember.Freezable`\n  APIs on `Ember.Set` as well.  Once a set is frozen it can no longer be\n  modified.  The benefit of this is that when you call frozenCopy() on it,\n  Ember will avoid making copies of the set.  This allows you to write\n  code that can know with certainty when the underlying set data will or\n  will not be modified.\n\n  @extends Ember.Enumerable\n  @extends Ember.MutableEnumerable\n  @extends Ember.Copyable\n  @extends Ember.Freezable\n\n  @since Ember 0.9\n*/\nEmber.Set = Ember.CoreObject.extend(Ember.MutableEnumerable, Ember.Copyable, Ember.Freezable,\n  /** @scope Ember.Set.prototype */ {\n\n  // ..........................................................\n  // IMPLEMENT ENUMERABLE APIS\n  //\n\n  /**\n    This property will change as the number of objects in the set changes.\n\n    @type number\n    @default 0\n  */\n  length: 0,\n\n  /**\n    Clears the set. This is useful if you want to reuse an existing set\n    without having to recreate it.\n\n        var colors = new Ember.Set([\"red\", \"green\", \"blue\"]);\n        colors.length;  => 3\n        colors.clear();\n        colors.length;  => 0\n\n    @returns {Ember.Set} An empty Set\n  */\n  clear: function() {\n    if (this.isFrozen) { throw new Error(Ember.FROZEN_ERROR); }\n\n    var len = get(this, 'length');\n    if (len === 0) { return this; }\n\n    var guid;\n\n    this.enumerableContentWillChange(len, 0);\n    Ember.propertyWillChange(this, 'firstObject');\n    Ember.propertyWillChange(this, 'lastObject');\n\n    for (var i=0; i < len; i++){\n      guid = guidFor(this[i]);\n      delete this[guid];\n      delete this[i];\n    }\n\n    set(this, 'length', 0);\n\n    Ember.propertyDidChange(this, 'firstObject');\n    Ember.propertyDidChange(this, 'lastObject');\n    this.enumerableContentDidChange(len, 0);\n\n    return this;\n  },\n\n  /**\n    Returns true if the passed object is also an enumerable that contains the\n    same objects as the receiver.\n\n        var colors = [\"red\", \"green\", \"blue\"],\n            same_colors = new Ember.Set(colors);\n        same_colors.isEqual(colors); => true\n        same_colors.isEqual([\"purple\", \"brown\"]); => false\n\n    @param {Ember.Set} obj the other object.\n    @returns {Boolean}\n  */\n  isEqual: function(obj) {\n    // fail fast\n    if (!Ember.Enumerable.detect(obj)) return false;\n\n    var loc = get(this, 'length');\n    if (get(obj, 'length') !== loc) return false;\n\n    while(--loc >= 0) {\n      if (!obj.contains(this[loc])) return false;\n    }\n\n    return true;\n  },\n\n  /**\n    Adds an object to the set. Only non-null objects can be added to a set\n    and those can only be added once. If the object is already in the set or\n    the passed value is null this method will have no effect.\n\n    This is an alias for `Ember.MutableEnumerable.addObject()`.\n\n        var colors = new Ember.Set();\n        colors.add(\"blue\");    => [\"blue\"]\n        colors.add(\"blue\");    => [\"blue\"]\n        colors.add(\"red\");     => [\"blue\", \"red\"]\n        colors.add(null);      => [\"blue\", \"red\"]\n        colors.add(undefined); => [\"blue\", \"red\"]\n\n    @function\n    @param {Object} obj The object to add.\n    @returns {Ember.Set} The set itself.\n  */\n  add: Ember.alias('addObject'),\n\n  /**\n    Removes the object from the set if it is found.  If you pass a null value\n    or an object that is already not in the set, this method will have no\n    effect. This is an alias for `Ember.MutableEnumerable.removeObject()`.\n\n        var colors = new Ember.Set([\"red\", \"green\", \"blue\"]);\n        colors.remove(\"red\");    => [\"blue\", \"green\"]\n        colors.remove(\"purple\"); => [\"blue\", \"green\"]\n        colors.remove(null);     => [\"blue\", \"green\"]\n\n    @function\n    @param {Object} obj The object to remove\n    @returns {Ember.Set} The set itself.\n  */\n  remove: Ember.alias('removeObject'),\n\n  /**\n    Removes the last element from the set and returns it, or null if it's empty.\n\n        var colors = new Ember.Set([\"green\", \"blue\"]);\n        colors.pop(); => \"blue\"\n        colors.pop(); => \"green\"\n        colors.pop(); => null\n\n    @returns {Object} The removed object from the set or null.\n  */\n  pop: function() {\n    if (get(this, 'isFrozen')) throw new Error(Ember.FROZEN_ERROR);\n    var obj = this.length > 0 ? this[this.length-1] : null;\n    this.remove(obj);\n    return obj;\n  },\n\n  /**\n    Inserts the given object on to the end of the set. It returns\n    the set itself.\n\n    This is an alias for `Ember.MutableEnumerable.addObject()`.\n\n        var colors = new Ember.Set();\n        colors.push(\"red\");   => [\"red\"]\n        colors.push(\"green\"); => [\"red\", \"green\"]\n        colors.push(\"blue\");  => [\"red\", \"green\", \"blue\"]\n\n    @function\n    @returns {Ember.Set} The set itself.\n  */\n  push: Ember.alias('addObject'),\n\n  /**\n    Removes the last element from the set and returns it, or null if it's empty.\n\n    This is an alias for `Ember.Set.pop()`.\n\n        var colors = new Ember.Set([\"green\", \"blue\"]);\n        colors.shift(); => \"blue\"\n        colors.shift(); => \"green\"\n        colors.shift(); => null\n\n    @function\n    @returns {Object} The removed object from the set or null.\n  */\n  shift: Ember.alias('pop'),\n\n  /**\n    Inserts the given object on to the end of the set. It returns\n    the set itself.\n\n    This is an alias of `Ember.Set.push()`\n\n        var colors = new Ember.Set();\n        colors.unshift(\"red\");   => [\"red\"]\n        colors.unshift(\"green\"); => [\"red\", \"green\"]\n        colors.unshift(\"blue\");  => [\"red\", \"green\", \"blue\"]\n\n    @function\n    @returns {Ember.Set} The set itself.\n  */\n  unshift: Ember.alias('push'),\n\n  /**\n    Adds each object in the passed enumerable to the set.\n\n    This is an alias of `Ember.MutableEnumerable.addObjects()`\n\n        var colors = new Ember.Set();\n        colors.addEach([\"red\", \"green\", \"blue\"]); => [\"red\", \"green\", \"blue\"]\n\n    @function\n    @param {Ember.Enumerable} objects the objects to add.\n    @returns {Ember.Set} The set itself.\n  */\n  addEach: Ember.alias('addObjects'),\n\n  /**\n    Removes each object in the passed enumerable to the set.\n\n    This is an alias of `Ember.MutableEnumerable.removeObjects()`\n\n        var colors = new Ember.Set([\"red\", \"green\", \"blue\"]);\n        colors.removeEach([\"red\", \"blue\"]); => [\"green\"]\n\n    @function\n    @param {Ember.Enumerable} objects the objects to remove.\n    @returns {Ember.Set} The set itself.\n  */\n  removeEach: Ember.alias('removeObjects'),\n\n  // ..........................................................\n  // PRIVATE ENUMERABLE SUPPORT\n  //\n\n  /** @private */\n  init: function(items) {\n    this._super();\n    if (items) this.addObjects(items);\n  },\n\n  /** @private (nodoc) - implement Ember.Enumerable */\n  nextObject: function(idx) {\n    return this[idx];\n  },\n\n  /** @private - more optimized version */\n  firstObject: Ember.computed(function() {\n    return this.length > 0 ? this[0] : undefined;\n  }).property().cacheable(),\n\n  /** @private - more optimized version */\n  lastObject: Ember.computed(function() {\n    return this.length > 0 ? this[this.length-1] : undefined;\n  }).property().cacheable(),\n\n  /** @private (nodoc) - implements Ember.MutableEnumerable */\n  addObject: function(obj) {\n    if (get(this, 'isFrozen')) throw new Error(Ember.FROZEN_ERROR);\n    if (none(obj)) return this; // nothing to do\n\n    var guid = guidFor(obj),\n        idx  = this[guid],\n        len  = get(this, 'length'),\n        added ;\n\n    if (idx>=0 && idx<len && (this[idx] === obj)) return this; // added\n\n    added = [obj];\n\n    this.enumerableContentWillChange(null, added);\n    Ember.propertyWillChange(this, 'lastObject');\n\n    len = get(this, 'length');\n    this[guid] = len;\n    this[len] = obj;\n    set(this, 'length', len+1);\n\n    Ember.propertyDidChange(this, 'lastObject');\n    this.enumerableContentDidChange(null, added);\n\n    return this;\n  },\n\n  /** @private (nodoc) - implements Ember.MutableEnumerable */\n  removeObject: function(obj) {\n    if (get(this, 'isFrozen')) throw new Error(Ember.FROZEN_ERROR);\n    if (none(obj)) return this; // nothing to do\n\n    var guid = guidFor(obj),\n        idx  = this[guid],\n        len = get(this, 'length'),\n        isFirst = idx === 0,\n        isLast = idx === len-1,\n        last, removed;\n\n\n    if (idx>=0 && idx<len && (this[idx] === obj)) {\n      removed = [obj];\n\n      this.enumerableContentWillChange(removed, null);\n      if (isFirst) { Ember.propertyWillChange(this, 'firstObject'); }\n      if (isLast)  { Ember.propertyWillChange(this, 'lastObject'); }\n\n      // swap items - basically move the item to the end so it can be removed\n      if (idx < len-1) {\n        last = this[len-1];\n        this[idx] = last;\n        this[guidFor(last)] = idx;\n      }\n\n      delete this[guid];\n      delete this[len-1];\n      set(this, 'length', len-1);\n\n      if (isFirst) { Ember.propertyDidChange(this, 'firstObject'); }\n      if (isLast)  { Ember.propertyDidChange(this, 'lastObject'); }\n      this.enumerableContentDidChange(removed, null);\n    }\n\n    return this;\n  },\n\n  /** @private (nodoc) - optimized version */\n  contains: function(obj) {\n    return this[guidFor(obj)]>=0;\n  },\n\n  /** @private (nodoc) */\n  copy: function() {\n    var C = this.constructor, ret = new C(), loc = get(this, 'length');\n    set(ret, 'length', loc);\n    while(--loc>=0) {\n      ret[loc] = this[loc];\n      ret[guidFor(this[loc])] = loc;\n    }\n    return ret;\n  },\n\n  /** @private */\n  toString: function() {\n    var len = this.length, idx, array = [];\n    for(idx = 0; idx < len; idx++) {\n      array[idx] = this[idx];\n    }\n    return \"Ember.Set<%@>\".fmt(array.join(','));\n  }\n\n});\n\n})();\n//@ sourceURL=ember-runtime/system/set");