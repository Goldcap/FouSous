minispade.register('ember-runtime/system/core_object', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: Â©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n\n\n// NOTE: this object should never be included directly.  Instead use Ember.\n// Ember.Object.  We only define this separately so that Ember.Set can depend on it\n\n\nvar set = Ember.set, get = Ember.get,\n    o_create = Ember.create,\n    o_defineProperty = Ember.platform.defineProperty,\n    a_slice = Array.prototype.slice,\n    GUID_KEY = Ember.GUID_KEY,\n    guidFor = Ember.guidFor,\n    generateGuid = Ember.generateGuid,\n    meta = Ember.meta,\n    rewatch = Ember.rewatch,\n    finishChains = Ember.finishChains,\n    destroy = Ember.destroy,\n    schedule = Ember.run.schedule,\n    Mixin = Ember.Mixin,\n    applyMixin = Mixin._apply,\n    finishPartial = Mixin.finishPartial,\n    reopen = Mixin.prototype.reopen,\n    classToString = Mixin.prototype.toString;\n\nvar undefinedDescriptor = {\n  configurable: true,\n  writable: true,\n  enumerable: false,\n  value: undefined\n};\n\n/** @private */\nfunction makeCtor() {\n\n  // Note: avoid accessing any properties on the object since it makes the\n  // method a lot faster.  This is glue code so we want it to be as fast as\n  // possible.\n\n  var wasApplied = false, initMixins;\n\n  var Class = function() {\n    if (!wasApplied) {\n      Class.proto(); // prepare prototype...\n    }\n    o_defineProperty(this, GUID_KEY, undefinedDescriptor);\n    o_defineProperty(this, '_super', undefinedDescriptor);\n    var m = meta(this);\n    m.proto = this;\n    if (initMixins) {\n      this.reopen.apply(this, initMixins);\n      initMixins = null;\n    }\n    finishPartial(this, m);\n    delete m.proto;\n    finishChains(this);\n    this.init.apply(this, arguments);\n  };\n\n  Class.toString = classToString;\n  Class.willReopen = function() {\n    if (wasApplied) {\n      Class.PrototypeMixin = Mixin.create(Class.PrototypeMixin);\n    }\n\n    wasApplied = false;\n  };\n  Class._initMixins = function(args) { initMixins = args; };\n\n  Class.proto = function() {\n    var superclass = Class.superclass;\n    if (superclass) { superclass.proto(); }\n\n    if (!wasApplied) {\n      wasApplied = true;\n      Class.PrototypeMixin.applyPartial(Class.prototype);\n      rewatch(Class.prototype);\n    }\n\n    return this.prototype;\n  };\n\n  return Class;\n\n}\n\nvar CoreObject = makeCtor();\n\nCoreObject.PrototypeMixin = Mixin.create(\n/** @scope Ember.CoreObject.prototype */ {\n\n  reopen: function() {\n    applyMixin(this, arguments, true);\n    return this;\n  },\n\n  isInstance: true,\n\n  /** @private */\n  init: function() {},\n\n  /** @field */\n  isDestroyed: false,\n\n  /** @field */\n  isDestroying: false,\n\n  /**\n    Destroys an object by setting the isDestroyed flag and removing its\n    metadata, which effectively destroys observers and bindings.\n\n    If you try to set a property on a destroyed object, an exception will be\n    raised.\n\n    Note that destruction is scheduled for the end of the run loop and does not\n    happen immediately.\n\n    @returns {Ember.Object} receiver\n  */\n  destroy: function() {\n    if (this.isDestroying) { return; }\n\n    this.isDestroying = true;\n\n    if (this.willDestroy) { this.willDestroy(); }\n\n    set(this, 'isDestroyed', true);\n    schedule('destroy', this, this._scheduledDestroy);\n    return this;\n  },\n\n  /**\n    Invoked by the run loop to actually destroy the object. This is\n    scheduled for execution by the `destroy` method.\n\n    @private\n  */\n  _scheduledDestroy: function() {\n    destroy(this);\n    if (this.didDestroy) { this.didDestroy(); }\n  },\n\n  bind: function(to, from) {\n    if (!(from instanceof Ember.Binding)) { from = Ember.Binding.from(from); }\n    from.to(to).connect(this);\n    return from;\n  },\n\n  toString: function() {\n    return '<'+this.constructor.toString()+':'+guidFor(this)+'>';\n  }\n});\n\nif (Ember.config.overridePrototypeMixin) {\n  Ember.config.overridePrototypeMixin(CoreObject.PrototypeMixin);\n}\n\nCoreObject.__super__ = null;\n\nvar ClassMixin = Mixin.create(\n/** @scope Ember.ClassMixin.prototype */ {\n\n  ClassMixin: Ember.required(),\n\n  PrototypeMixin: Ember.required(),\n\n  isClass: true,\n\n  isMethod: false,\n\n  extend: function() {\n    var Class = makeCtor(), proto;\n    Class.ClassMixin = Mixin.create(this.ClassMixin);\n    Class.PrototypeMixin = Mixin.create(this.PrototypeMixin);\n\n    Class.ClassMixin.ownerConstructor = Class;\n    Class.PrototypeMixin.ownerConstructor = Class;\n\n    reopen.apply(Class.PrototypeMixin, arguments);\n\n    Class.superclass = this;\n    Class.__super__  = this.prototype;\n\n    proto = Class.prototype = o_create(this.prototype);\n    proto.constructor = Class;\n    generateGuid(proto, 'ember');\n    meta(proto).proto = proto; // this will disable observers on prototype\n\n    Class.ClassMixin.apply(Class);\n    return Class;\n  },\n\n  create: function() {\n    var C = this;\n    if (arguments.length>0) { this._initMixins(arguments); }\n    return new C();\n  },\n\n  reopen: function() {\n    this.willReopen();\n    reopen.apply(this.PrototypeMixin, arguments);\n    return this;\n  },\n\n  reopenClass: function() {\n    reopen.apply(this.ClassMixin, arguments);\n    applyMixin(this, arguments, false);\n    return this;\n  },\n\n  detect: function(obj) {\n    if ('function' !== typeof obj) { return false; }\n    while(obj) {\n      if (obj===this) { return true; }\n      obj = obj.superclass;\n    }\n    return false;\n  },\n\n  detectInstance: function(obj) {\n    return obj instanceof this;\n  },\n\n  /**\n    In some cases, you may want to annotate computed properties with additional\n    metadata about how they function or what values they operate on. For example,\n    computed property functions may close over variables that are then no longer\n    available for introspection.\n\n    You can pass a hash of these values to a computed property like this:\n\n        person: function() {\n          var personId = this.get('personId');\n          return App.Person.create({ id: personId });\n        }.property().meta({ type: App.Person })\n\n    Once you've done this, you can retrieve the values saved to the computed\n    property from your class like this:\n\n        MyClass.metaForProperty('person');\n\n    This will return the original hash that was passed to `meta()`.\n  */\n  metaForProperty: function(key) {\n    var desc = meta(this.proto(), false).descs[key];\n\n    Ember.assert(\"metaForProperty() could not find a computed property with key '\"+key+\"'.\", !!desc && desc instanceof Ember.ComputedProperty);\n    return desc._meta || {};\n  },\n\n  /**\n    Iterate over each computed property for the class, passing its name\n    and any associated metadata (see `metaForProperty`) to the callback.\n  */\n  eachComputedProperty: function(callback, binding) {\n    var proto = this.proto(),\n        descs = meta(proto).descs,\n        empty = {},\n        property;\n\n    for (var name in descs) {\n      property = descs[name];\n\n      if (property instanceof Ember.ComputedProperty) {\n        callback.call(binding || this, name, property._meta || empty);\n      }\n    }\n  }\n\n});\n\nif (Ember.config.overrideClassMixin) {\n  Ember.config.overrideClassMixin(ClassMixin);\n}\n\nCoreObject.ClassMixin = ClassMixin;\nClassMixin.apply(CoreObject);\n\n/**\n  @class\n*/\nEmber.CoreObject = CoreObject;\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/system/core_object");