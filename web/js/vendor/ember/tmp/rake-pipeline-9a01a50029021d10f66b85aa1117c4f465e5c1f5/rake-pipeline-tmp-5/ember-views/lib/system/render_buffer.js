minispade.register('ember-views/system/render_buffer', "(function() {// ==========================================================================\n// Project:   Ember - JavaScript Application Framework\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            Portions ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar get = Ember.get, set = Ember.set;\nvar indexOf = Ember.ArrayPolyfills.indexOf;\n\n/** @private */\nvar ClassSet = function() {\n  this.seen = {};\n  this.list = [];\n};\n\nClassSet.prototype = {\n  add: function(string) {\n    if (string in this.seen) { return; }\n    this.seen[string] = true;\n\n    this.list.push(string);\n  },\n\n  toDOM: function() {\n    return this.list.join(\" \");\n  }\n};\n\n/**\n  @class\n\n  Ember.RenderBuffer gathers information regarding the a view and generates the\n  final representation. Ember.RenderBuffer will generate HTML which can be pushed\n  to the DOM.\n\n  @extends Ember.Object\n*/\nEmber.RenderBuffer = function(tagName) {\n  return new Ember._RenderBuffer(tagName);\n};\n\nEmber._RenderBuffer = function(tagName) {\n  this.elementTag = tagName;\n  this.childBuffers = [];\n};\n\nEmber._RenderBuffer.prototype =\n/** @scope Ember.RenderBuffer.prototype */ {\n\n  /**\n    Array of class-names which will be applied in the class=\"\" attribute\n\n    You should not maintain this array yourself, rather, you should use\n    the addClass() method of Ember.RenderBuffer.\n\n    @type Array\n    @default []\n  */\n  elementClasses: null,\n\n  /**\n    The id in of the element, to be applied in the id=\"\" attribute\n\n    You should not set this property yourself, rather, you should use\n    the id() method of Ember.RenderBuffer.\n\n    @type String\n    @default null\n  */\n  elementId: null,\n\n  /**\n    A hash keyed on the name of the attribute and whose value will be\n    applied to that attribute. For example, if you wanted to apply a\n    data-view=\"Foo.bar\" property to an element, you would set the\n    elementAttributes hash to {'data-view':'Foo.bar'}\n\n    You should not maintain this hash yourself, rather, you should use\n    the attr() method of Ember.RenderBuffer.\n\n    @type Hash\n    @default {}\n  */\n  elementAttributes: null,\n\n  /**\n    The tagname of the element an instance of Ember.RenderBuffer represents.\n\n    Usually, this gets set as the first parameter to Ember.RenderBuffer. For\n    example, if you wanted to create a `p` tag, then you would call\n\n      Ember.RenderBuffer('p')\n\n    @type String\n    @default null\n  */\n  elementTag: null,\n\n  /**\n    A hash keyed on the name of the style attribute and whose value will\n    be applied to that attribute. For example, if you wanted to apply a\n    background-color:black;\" style to an element, you would set the\n    elementStyle hash to {'background-color':'black'}\n\n    You should not maintain this hash yourself, rather, you should use\n    the style() method of Ember.RenderBuffer.\n\n    @type Hash\n    @default {}\n  */\n  elementStyle: null,\n\n  /**\n    Nested RenderBuffers will set this to their parent RenderBuffer\n    instance.\n\n    @type Ember._RenderBuffer\n  */\n  parentBuffer: null,\n\n  /**\n    Adds a string of HTML to the RenderBuffer.\n\n    @param {String} string HTML to push into the buffer\n    @returns {Ember.RenderBuffer} this\n  */\n  push: function(string) {\n    this.childBuffers.push(String(string));\n    return this;\n  },\n\n  /**\n    Adds a class to the buffer, which will be rendered to the class attribute.\n\n    @param {String} className Class name to add to the buffer\n    @returns {Ember.RenderBuffer} this\n  */\n  addClass: function(className) {\n    // lazily create elementClasses\n    var elementClasses = this.elementClasses = (this.elementClasses || new ClassSet());\n    this.elementClasses.add(className);\n\n    return this;\n  },\n\n  /**\n    Sets the elementID to be used for the element.\n\n    @param {String} id\n    @returns {Ember.RenderBuffer} this\n  */\n  id: function(id) {\n    this.elementId = id;\n    return this;\n  },\n\n  // duck type attribute functionality like jQuery so a render buffer\n  // can be used like a jQuery object in attribute binding scenarios.\n\n  /**\n    Adds an attribute which will be rendered to the element.\n\n    @param {String} name The name of the attribute\n    @param {String} value The value to add to the attribute\n    @returns {Ember.RenderBuffer|String} this or the current attribute value\n  */\n  attr: function(name, value) {\n    var attributes = this.elementAttributes = (this.elementAttributes || {});\n\n    if (arguments.length === 1) {\n      return attributes[name];\n    } else {\n      attributes[name] = value;\n    }\n\n    return this;\n  },\n\n  /**\n    Remove an attribute from the list of attributes to render.\n\n    @param {String} name The name of the attribute\n    @returns {Ember.RenderBuffer} this\n  */\n  removeAttr: function(name) {\n    var attributes = this.elementAttributes;\n    if (attributes) { delete attributes[name]; }\n\n    return this;\n  },\n\n  /**\n    Adds a style to the style attribute which will be rendered to the element.\n\n    @param {String} name Name of the style\n    @param {String} value\n    @returns {Ember.RenderBuffer} this\n  */\n  style: function(name, value) {\n    var style = this.elementStyle = (this.elementStyle || {});\n\n    this.elementStyle[name] = value;\n    return this;\n  },\n\n  /**\n    Create a new child render buffer from a parent buffer. Optionally set\n    additional properties on the buffer. Optionally invoke a callback\n    with the newly created buffer.\n\n    This is a primitive method used by other public methods: `begin`,\n    `prepend`, `replaceWith`, `insertAfter`.\n\n    @private\n    @param {String} tagName Tag name to use for the child buffer's element\n    @param {Ember._RenderBuffer} parent The parent render buffer that this\n      buffer should be appended to.\n    @param {Function} fn A callback to invoke with the newly created buffer.\n    @param {Object} other Additional properties to add to the newly created\n      buffer.\n  */\n  newBuffer: function(tagName, parent, fn, other) {\n    var buffer = new Ember._RenderBuffer(tagName);\n    buffer.parentBuffer = parent;\n\n    if (other) { Ember.$.extend(buffer, other); }\n    if (fn) { fn.call(this, buffer); }\n\n    return buffer;\n  },\n\n  /**\n    Replace the current buffer with a new buffer. This is a primitive\n    used by `remove`, which passes `null` for `newBuffer`, and `replaceWith`,\n    which passes the new buffer it created.\n\n    @private\n    @param {Ember._RenderBuffer} buffer The buffer to insert in place of\n      the existing buffer.\n  */\n  replaceWithBuffer: function(newBuffer) {\n    var parent = this.parentBuffer;\n    if (!parent) { return; }\n\n    var childBuffers = parent.childBuffers;\n\n    var index = indexOf.call(childBuffers, this);\n\n    if (newBuffer) {\n      childBuffers.splice(index, 1, newBuffer);\n    } else {\n      childBuffers.splice(index, 1);\n    }\n  },\n\n  /**\n    Creates a new Ember.RenderBuffer object with the provided tagName as\n    the element tag and with its parentBuffer property set to the current\n    Ember.RenderBuffer.\n\n    @param {String} tagName Tag name to use for the child buffer's element\n    @returns {Ember.RenderBuffer} A new RenderBuffer object\n  */\n  begin: function(tagName) {\n    return this.newBuffer(tagName, this, function(buffer) {\n      this.childBuffers.push(buffer);\n    });\n  },\n\n  /**\n    Prepend a new child buffer to the current render buffer.\n\n    @param {String} tagName Tag name to use for the child buffer's element\n  */\n  prepend: function(tagName) {\n    return this.newBuffer(tagName, this, function(buffer) {\n      this.childBuffers.splice(0, 0, buffer);\n    });\n  },\n\n  /**\n    Replace the current buffer with a new render buffer.\n\n    @param {String} tagName Tag name to use for the new buffer's element\n  */\n  replaceWith: function(tagName) {\n    var parentBuffer = this.parentBuffer;\n\n    return this.newBuffer(tagName, parentBuffer, function(buffer) {\n      this.replaceWithBuffer(buffer);\n    });\n  },\n\n  /**\n    Insert a new render buffer after the current render buffer.\n\n    @param {String} tagName Tag name to use for the new buffer's element\n  */\n  insertAfter: function(tagName) {\n    var parentBuffer = get(this, 'parentBuffer');\n\n    return this.newBuffer(tagName, parentBuffer, function(buffer) {\n      var siblings = parentBuffer.childBuffers;\n      var index = indexOf.call(siblings, this);\n      siblings.splice(index + 1, 0, buffer);\n    });\n  },\n\n  /**\n    Closes the current buffer and adds its content to the parentBuffer.\n\n    @returns {Ember.RenderBuffer} The parentBuffer, if one exists. Otherwise, this\n  */\n  end: function() {\n    var parent = this.parentBuffer;\n    return parent || this;\n  },\n\n  remove: function() {\n    this.replaceWithBuffer(null);\n  },\n\n  /**\n    @returns {DOMElement} The element corresponding to the generated HTML\n      of this buffer\n  */\n  element: function() {\n    return Ember.$(this.string())[0];\n  },\n\n  /**\n    Generates the HTML content for this buffer.\n\n    @returns {String} The generated HTMl\n  */\n  string: function() {\n    var content = '', tag = this.elementTag, openTag;\n\n    if (tag) {\n      var id = this.elementId,\n          classes = this.elementClasses,\n          attrs = this.elementAttributes,\n          style = this.elementStyle,\n          styleBuffer = '', prop;\n\n      openTag = [\"<\" + tag];\n\n      if (id) { openTag.push('id=\"' + this._escapeAttribute(id) + '\"'); }\n      if (classes) { openTag.push('class=\"' + this._escapeAttribute(classes.toDOM()) + '\"'); }\n\n      if (style) {\n        for (prop in style) {\n          if (style.hasOwnProperty(prop)) {\n            styleBuffer += (prop + ':' + this._escapeAttribute(style[prop]) + ';');\n          }\n        }\n\n        openTag.push('style=\"' + styleBuffer + '\"');\n      }\n\n      if (attrs) {\n        for (prop in attrs) {\n          if (attrs.hasOwnProperty(prop)) {\n            openTag.push(prop + '=\"' + this._escapeAttribute(attrs[prop]) + '\"');\n          }\n        }\n      }\n\n      openTag = openTag.join(\" \") + '>';\n    }\n\n    var childBuffers = this.childBuffers;\n\n    Ember.ArrayPolyfills.forEach.call(childBuffers, function(buffer) {\n      var stringy = typeof buffer === 'string';\n      content += (stringy ? buffer : buffer.string());\n    });\n\n    if (tag) {\n      return openTag + content + \"</\" + tag + \">\";\n    } else {\n      return content;\n    }\n  },\n\n  _escapeAttribute: function(value) {\n    // Stolen shamelessly from Handlebars\n\n    var escape = {\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&#x27;\",\n      \"`\": \"&#x60;\"\n    };\n\n    var badChars = /&(?!\\w+;)|[<>\"'`]/g;\n    var possible = /[&<>\"'`]/;\n\n    var escapeChar = function(chr) {\n      return escape[chr] || \"&amp;\";\n    };\n\n    var string = value.toString();\n\n    if(!possible.test(string)) { return string; }\n    return string.replace(badChars, escapeChar);\n  }\n\n};\n\n})();\n//@ sourceURL=ember-views/system/render_buffer");