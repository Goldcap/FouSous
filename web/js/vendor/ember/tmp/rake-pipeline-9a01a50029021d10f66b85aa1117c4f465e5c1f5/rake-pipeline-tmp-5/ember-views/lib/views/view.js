minispade.register('ember-views/views/view', "(function() {// ==========================================================================\n// Project:   Ember - JavaScript Application Framework\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            Portions ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require(\"ember-views/system/render_buffer\");\nvar get = Ember.get, set = Ember.set, addObserver = Ember.addObserver;\nvar meta = Ember.meta, fmt = Ember.String.fmt;\nvar a_slice = [].slice;\nvar a_forEach = Ember.EnumerableUtils.forEach;\n\nvar childViewsProperty = Ember.computed(function() {\n  var childViews = this._childViews;\n\n  var ret = Ember.A();\n\n  a_forEach(childViews, function(view) {\n    if (view.isVirtual) {\n      ret.pushObjects(get(view, 'childViews'));\n    } else {\n      ret.push(view);\n    }\n  });\n\n  return ret;\n}).property().cacheable();\n\nvar VIEW_PRESERVES_CONTEXT = Ember.VIEW_PRESERVES_CONTEXT;\nEmber.warn(\"The way that the {{view}} helper affects templates is about to change. Previously, templates inside child views would use the new view as the context. Soon, views will preserve their parent context when rendering their template. You can opt-in early to the new behavior by setting `ENV.VIEW_PRESERVES_CONTEXT = true`. For more information, see https://gist.github.com/2494968. You should update your templates as soon as possible; this default will change soon, and the option will be eliminated entirely before the 1.0 release.\", VIEW_PRESERVES_CONTEXT);\n\n/**\n  @static\n\n  Global hash of shared templates. This will automatically be populated\n  by the build tools so that you can store your Handlebars templates in\n  separate files that get loaded into JavaScript at buildtime.\n\n  @type Hash\n*/\nEmber.TEMPLATES = {};\n\nvar invokeForState = {\n  preRender: {},\n  inBuffer: {},\n  hasElement: {},\n  inDOM: {},\n  destroyed: {}\n};\n\n/**\n  @class\n\n  `Ember.View` is the class in Ember responsible for encapsulating templates of HTML\n  content, combining templates with data to render as sections of a page's DOM, and\n  registering and responding to user-initiated events.\n  \n  ## HTML Tag\n  The default HTML tag name used for a view's DOM representation is `div`. This can be\n  customized by setting the `tagName` property. The following view class:\n\n      ParagraphView = Ember.View.extend({\n        tagName: 'em'\n      })\n\n  Would result in instances with the following HTML:\n\n      <em id=\"ember1\" class=\"ember-view\"></em>\n\n  ## HTML `class` Attribute\n  The HTML `class` attribute of a view's tag can be set by providing a `classNames` property\n  that is set to an array of strings:\n\n      MyView = Ember.View.extend({\n        classNames: ['my-class', 'my-other-class']\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view my-class my-other-class\"></div>\n\n  `class` attribute values can also be set by providing a `classNameBindings` property\n  set to an array of properties names for the view. The return value of these properties \n  will be added as part of the value for the view's `class` attribute. These properties\n  can be computed properties:\n\n      MyView = Ember.View.extend({\n        classNameBindings: ['propertyA', 'propertyB'],\n        propertyA: 'from-a',\n        propertyB: function(){\n          if(someLogic){ return 'from-b'; }\n        }.property()\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view from-a from-b\"></div>\n\n  If the value of a class name binding returns a boolean the property name itself\n  will be used as the class name if the property is true. The class name will\n  not be added if the value is `false` or `undefined`.\n\n      MyView = Ember.View.extend({\n        classNameBindings: ['hovered'],\n        hovered: true\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view hovered\"></div>\n\n  When using boolean class name bindings you can supply a string value other than the \n  property name for use as the `class` HTML attribute by appending the preferred value after\n  a \":\" character when defining the binding:\n\n      MyView = Ember.View.extend({\n        classNameBindings: ['awesome:so-very-cool'],\n        awesome: true\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view so-very-cool\"></div>\n\n\n  Boolean value class name bindings whose property names are in a camelCase-style\n  format will be converted to a dasherized format:\n\n      MyView = Ember.View.extend({\n        classNameBindings: ['isUrgent'],\n        isUrgent: true\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view is-urgent\"></div>\n\n\n  Class name bindings can also refer to object values that are found by\n  traversing a path relative to the view itself:\n\n      MyView = Ember.View.extend({\n        classNameBindings: ['messages.empty']\n        messages: Ember.Object.create({\n          empty: true\n        })\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view empty\"></div>\n\n\n  If you want to add a class name for a property which evaluates to true and\n  and a different class name if it evaluates to false, you can pass a binding\n  like this:\n\n    // Applies 'enabled' class when isEnabled is true and 'disabled' when isEnabled is false\n    Ember.View.create({\n      classNameBindings: ['isEnabled:enabled:disabled']\n      isEnabled: true\n    });\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view enabled\"></div>\n\n  When isEnabled is `false`, the resulting HTML reprensentation looks like this:\n\n      <div id=\"ember1\" class=\"ember-view disabled\"></div>\n\n  This syntax offers the convenience to add a class if a property is `false`:\n\n    // Applies no class when isEnabled is true and class 'disabled' when isEnabled is false\n    Ember.View.create({\n      classNameBindings: ['isEnabled::disabled']\n      isEnabled: true\n    });\n\n  Will result in view instances with an HTML representation of:\n\n    <div id=\"ember1\" class=\"ember-view\"></div>\n\n  When the `isEnabled` property on the view is set to `false`, it will result\n  in view instances with an HTML representation of:\n\n    <div id=\"ember1\" class=\"ember-view disabled\"></div>\n\n\n  Updates to the the value of a class name binding will result in automatic update \n  of the  HTML `class` attribute in the view's rendered HTML representation.\n  If the value becomes  `false` or `undefined` the class name will be removed.\n\n  Both `classNames` and `classNameBindings` are concatenated properties. \n  See `Ember.Object` documentation for more information about concatenated properties.\n\n  ## HTML Attributes\n  The HTML attribute section of a view's tag can be set by providing an `attributeBindings`\n  property set to an array of property names on the view. The return value of these properties\n  will be used as the value of the view's HTML associated attribute:\n\n      AnchorView = Ember.View.extend({\n        tagName: 'a',\n        attributeBindings: ['href'],\n        href: 'http://google.com'\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <a id=\"ember1\" class=\"ember-view\" href=\"http://google.com\"></a>\n\n  If the return value of an `attributeBindings` monitored property is a boolean\n  the property will follow HTML's pattern of repeating the attribute's name as\n  its value:\n\n      MyTextInput = Ember.View.extend({\n        tagName: 'input',\n        attributeBindings: ['disabled'],\n        disabled: true\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <input id=\"ember1\" class=\"ember-view\" disabled=\"disabled\" />\n\n  `attributeBindings` can refer to computed properties:\n\n      MyTextInput = Ember.View.extend({\n        tagName: 'input',\n        attributeBindings: ['disabled'],\n        disabled: function(){\n          if (someLogic) {\n            return true;\n          } else {\n            return false;\n          }\n        }.property()\n      })\n\n  Updates to the the property of an attribute binding will result in automatic update \n  of the  HTML attribute in the view's rendered HTML representation.\n\n  `attributeBindings` is a concatenated property. See `Ember.Object` documentation\n  for more information about concatenated properties.\n\n  ## Templates\n  The HTML contents of a view's rendered representation are determined by its template.\n  Templates can be any function that accepts an optional context parameter and returns\n  a string of HTML that will be inserted within the view's tag. Most\n  typically in Ember this function will be a compiled Ember.Handlebars template.\n\n      AView = Ember.View.extend({\n        template: Ember.Handlebars.compile('I am the template')\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view\">I am the template</div>\n\n  The default context of the compiled template will be the view instance itself:\n\n      AView = Ember.View.extend({\n        template: Ember.Handlebars.compile('Hello {{excitedGreeting}}')\n      })\n\n      aView = AView.create({\n        content: Ember.Object.create({\n          firstName: 'Barry'\n        })\n        excitedGreeting: function(){\n          return this.get(\"content.firstName\") + \"!!!\"\n        }\n      })\n\n  Will result in an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view\">Hello Barry!!!</div>\n\n  Within an Ember application is more common to define a Handlebars templates as\n  part of a page:\n\n      <script type='text/x-handlebars' data-template-name='some-template'>\n        Hello\n      </script>\n\n  And associate it by name using a view's `templateName` property:\n\n      AView = Ember.View.extend({\n        templateName: 'some-template'\n      })\n\n  Using a value for `templateName` that does not have a Handlebars template with a\n  matching `data-template-name` attribute will throw an error.\n\n  Assigning a value to both `template` and `templateName` properties will throw an error.\n\n  For views classes that may have a template later defined (e.g. as the block portion of a `{{view}}`\n  Handlebars helper call in another template or in a subclass), you can provide a `defaultTemplate`\n  property set to compiled template function. If a template is not later provided for the view\n  instance the `defaultTemplate` value will be used:\n\n      AView = Ember.View.extend({\n        defaultTemplate: Ember.Handlebars.compile('I was the default'),\n        template: null,\n        templateName: null\n      })\n\n  Will result in instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view\">I was the default</div>\n\n  If a `template` or `templateName` is provided it will take precedence over `defaultTemplate`:\n\n      AView = Ember.View.extend({\n        defaultTemplate: Ember.Handlebars.compile('I was the default')\n      })\n\n      aView = AView.create({\n        template: Ember.Handlebars.compile('I was the template, not default')\n      })\n\n  Will result in the following HTML representation when rendered:\n\n      <div id=\"ember1\" class=\"ember-view\">I was the template, not default</div>\n\n  ## Layouts\n  Views can have a secondary template that wraps their main template. Like\n  primary templates, layouts can be any function that  accepts an optional context\n  parameter and returns a string of HTML that will be inserted inside view's tag. Views whose HTML\n  element is self closing (e.g. `<input />`) cannot have a layout and this property will be ignored.\n  \n  Most typically in Ember a layout will be a compiled Ember.Handlebars template.\n\n  A view's layout can be set directly with the `layout` property or reference an\n  existing Handlebars template by name with the `layoutName` property.\n\n  A template used as a layout must contain a single use of the Handlebars `{{yield}}`\n  helper. The HTML contents of a view's rendered `template` will be inserted at this location:\n\n      AViewWithLayout = Ember.View.extend({\n        layout: Ember.Handlebars.compile(\"<div class='my-decorative-class'>{{yield}}</div>\")\n        template: Ember.Handlebars.compile(\"I got wrapped\"),\n      })\n\n  Will result in view instances with an HTML representation of:\n\n      <div id=\"ember1\" class=\"ember-view\">\n        <div class=\"my-decorative-class\">\n          I got wrapped\n        </div>\n      </div>\n\n  See `Handlebars.helpers.yield` for more information.\n\n  ## Responding to Browser Events\n  Views can respond to user-initiated events in one of three ways: method implementation, \n  through an event manager, and through `{{action}}` helper use in their template or layout.\n\n  ### Method Implementation\n  Views can respond to user-initiated events by implementing a method that matches the\n  event name. A `jQuery.Event` object will be passed as the argument to this method.\n\n      AView = Ember.View.extend({\n        click: function(event){\n          // will be called when when an instance's\n          // rendered element is clicked\n        }\n      })\n\n  ### Event Managers\n  Views can define an object as their `eventManager` property. This object can then\n  implement methods that match the desired event names. Matching events that occur\n  on the view's rendered HTML or the rendered HTML of any of its DOM descendants \n  will trigger this method.  A `jQuery.Event` object will be passed as the first \n  argument to the method and an  `Ember.View` object as the second. The `Ember.View`\n  will be the view whose rendered HTML was interacted with. This may be the view with\n  the `eventManager` property or one of its descendent views.\n\n      AView = Ember.View.extend({\n        eventManager: Ember.Object.create({\n          doubleClick: function(event, view){\n            // will be called when when an instance's\n            // rendered element or any rendering\n            // of this views's descendent\n            // elements is clicked\n          }\n        })\n      })\n\n\n  An event defined for an event manager takes precedence over events of the same\n  name handled through methods on the view.\n\n\n      AView = Ember.View.extend({\n        mouseEnter: function(event){\n          // will never trigger.\n        },\n        eventManager: Ember.Object.create({\n          mouseEnter: function(event, view){\n            // takes presedence over AView#mouseEnter\n          }\n        })\n      })\n\n  Similarly a view's event manager will take precedence for events of any views\n  rendered as a descendent. A method name that matches an event name will not be called\n  if the view instance was rendered inside the HTML representation of a view that has \n  an `eventManager` property defined that handles events of the name.  Events not handled\n  by the event manager will still trigger method calls on the descendent.\n\n      OuterView = Ember.View.extend({\n        template: Ember.Handlebars.compile(\"outer {{#view InnerView}}inner{{/view}} outer\"),\n        eventManager: Ember.Object.create({\n          mouseEnter: function(event, view){\n            // view might be instance of either\n            // OutsideView or InnerView depending on\n            // where on the page the user interaction occured\n          }\n        })\n      })\n\n      InnerView = Ember.View.extend({\n        click: function(event){\n          // will be called if rendered inside\n          // an OuterView because OuterView's\n          // eventManager doesn't handle click events\n        },\n        mouseEnter: function(event){\n          // will never be called if rendered inside \n          // an OuterView.\n        }\n      })\n\n  ### Handlebars `{{action}}` Helper\n  See `Handlebars.helpers.action`.\n\n  ### Event Names\n  Possible events names for any of the responding approaches described above are:\n\n  Touch events: 'touchStart', 'touchMove', 'touchEnd', 'touchCancel'\n\n  Keyboard events: 'keyDown', 'keyUp', 'keyPress'\n\n  Mouse events: 'mouseDown', 'mouseUp', 'contextMenu', 'click', 'doubleClick', 'mouseMove',\n  'focusIn', 'focusOut', 'mouseEnter', 'mouseLeave'\n\n  Form events: 'submit', 'change', 'focusIn', 'focusOut', 'input'\n\n  HTML5 drag and drop events: 'dragStart', 'drag', 'dragEnter', 'dragLeave', 'drop', 'dragEnd'\n  \n  ## Handlebars `{{view}}` Helper\n  Other `Ember.View` instances can be included as part of a view's template by using the `{{view}}`\n  Handlebars helper. See `Handlebars.helpers.view` for additional information.\n\n  @extends Ember.Object\n  @extends Ember.Evented\n*/\nEmber.View = Ember.Object.extend(Ember.Evented,\n/** @scope Ember.View.prototype */ {\n\n  /** @private */\n  concatenatedProperties: ['classNames', 'classNameBindings', 'attributeBindings'],\n\n  /**\n    @type Boolean\n    @default true\n    @constant\n  */\n  isView: true,\n\n  // ..........................................................\n  // TEMPLATE SUPPORT\n  //\n\n  /**\n    The name of the template to lookup if no template is provided.\n\n    Ember.View will look for a template with this name in this view's\n    `templates` object. By default, this will be a global object\n    shared in `Ember.TEMPLATES`.\n\n    @type String\n    @default null\n  */\n  templateName: null,\n\n  /**\n    The name of the layout to lookup if no layout is provided.\n\n    Ember.View will look for a template with this name in this view's\n    `templates` object. By default, this will be a global object\n    shared in `Ember.TEMPLATES`.\n\n    @type String\n    @default null\n  */\n  layoutName: null,\n\n  /**\n    The hash in which to look for `templateName`.\n\n    @type Ember.Object\n    @default Ember.TEMPLATES\n  */\n  templates: Ember.TEMPLATES,\n\n  /**\n    The template used to render the view. This should be a function that\n    accepts an optional context parameter and returns a string of HTML that\n    will be inserted into the DOM relative to its parent view.\n\n    In general, you should set the `templateName` property instead of setting\n    the template yourself.\n\n    @field\n    @type Function\n  */\n  template: Ember.computed(function(key, value) {\n    if (value !== undefined) { return value; }\n\n    var templateName = get(this, 'templateName'),\n        template = this.templateForName(templateName, 'template');\n\n    return template || get(this, 'defaultTemplate');\n  }).property('templateName').cacheable(),\n\n  /**\n    The controller managing this view. If this property is set, it will be\n    made available for use by the template.\n\n    @type Object\n  */\n  controller: Ember.computed(function(key, value) {\n    var parentView;\n\n    if (arguments.length === 2) {\n      return value;\n    } else {\n      parentView = get(this, 'parentView');\n      return parentView ? get(parentView, 'controller') : null;\n    }\n  }).property().cacheable(),\n\n  /**\n    A view may contain a layout. A layout is a regular template but\n    supersedes the `template` property during rendering. It is the\n    responsibility of the layout template to retrieve the `template`\n    property from the view (or alternatively, call `Handlebars.helpers.yield`,\n    `{{yield}}`) to render it in the correct location.\n\n    This is useful for a view that has a shared wrapper, but which delegates\n    the rendering of the contents of the wrapper to the `template` property\n    on a subclass.\n\n    @field\n    @type Function\n  */\n  layout: Ember.computed(function(key, value) {\n    if (arguments.length === 2) { return value; }\n\n    var layoutName = get(this, 'layoutName'),\n        layout = this.templateForName(layoutName, 'layout');\n\n    return layout || get(this, 'defaultLayout');\n  }).property('layoutName').cacheable(),\n\n  templateForName: function(name, type) {\n    if (!name) { return; }\n\n    var templates = get(this, 'templates'),\n        template = get(templates, name);\n\n    if (!template) {\n     throw new Ember.Error(fmt('%@ - Unable to find %@ \"%@\".', [this, type, name]));\n    }\n\n    return template;\n  },\n\n  /**\n    The object from which templates should access properties.\n\n    This object will be passed to the template function each time the render\n    method is called, but it is up to the individual function to decide what\n    to do with it.\n\n    By default, this will be the view itself.\n\n    @type Object\n  */\n  context: Ember.computed(function(key, value) {\n    if (arguments.length === 2) {\n      set(this, '_context', value);\n      return value;\n    } else {\n      return get(this, '_context');\n    }\n  }).volatile(),\n\n  /**\n    @private\n\n    Private copy of the view's template context. This can be set directly\n    by Handlebars without triggering the observer that causes the view\n    to be re-rendered.\n\n    The context of a view is looked up as follows:\n\n    1. Specified controller\n    2. Supplied context (usually by Handlebars)\n    3. `parentView`'s context (for a child of a ContainerView)\n\n    The code in Handlebars that overrides the `_context` property first\n    checks to see whether the view has a specified controller. This is\n    something of a hack and should be revisited.\n  */\n  _context: Ember.computed(function(key, value) {\n    var parentView, controller, context;\n\n    if (arguments.length === 2) {\n      return value;\n    }\n\n    if (VIEW_PRESERVES_CONTEXT) {\n      if (controller = get(this, 'controller')) {\n        return controller;\n      }\n\n      parentView = get(this, '_parentView');\n      if (parentView) {\n        return get(parentView, '_context');\n      }\n    }\n\n    return this;\n  }).cacheable(),\n\n  /**\n    If a value that affects template rendering changes, the view should be\n    re-rendered to reflect the new value.\n\n    @private\n  */\n  _displayPropertyDidChange: Ember.observer(function() {\n    this.rerender();\n  }, 'context', 'controller'),\n\n  /**\n    If the view is currently inserted into the DOM of a parent view, this\n    property will point to the parent of the view.\n\n    @type Ember.View\n    @default null\n  */\n  parentView: Ember.computed(function() {\n    var parent = get(this, '_parentView');\n\n    if (parent && parent.isVirtual) {\n      return get(parent, 'parentView');\n    } else {\n      return parent;\n    }\n  }).property('_parentView').volatile(),\n\n  _parentView: null,\n\n  // return the current view, not including virtual views\n  concreteView: Ember.computed(function() {\n    if (!this.isVirtual) { return this; }\n    else { return get(this, 'parentView'); }\n  }).property('_parentView').volatile(),\n\n  /**\n    If false, the view will appear hidden in DOM.\n\n    @type Boolean\n    @default null\n  */\n  isVisible: true,\n\n  /**\n    Array of child views. You should never edit this array directly.\n    Instead, use appendChild and removeFromParent.\n\n    @private\n    @type Array\n    @default []\n  */\n  childViews: childViewsProperty,\n\n  _childViews: [],\n\n  /**\n    When it's a virtual view, we need to notify the parent that their\n    childViews will change.\n  */\n  _childViewsWillChange: Ember.beforeObserver(function() {\n    if (this.isVirtual) {\n      var parentView = get(this, 'parentView');\n      if (parentView) { Ember.propertyWillChange(parentView, 'childViews'); }\n    }\n  }, 'childViews'),\n\n  /**\n    When it's a virtual view, we need to notify the parent that their\n    childViews did change.\n  */\n  _childViewsDidChange: Ember.observer(function() {\n    if (this.isVirtual) {\n      var parentView = get(this, 'parentView');\n      if (parentView) { Ember.propertyDidChange(parentView, 'childViews'); }\n    }\n  }, 'childViews'),\n\n  /**\n    Return the nearest ancestor that is an instance of the provided\n    class.\n\n    @param {Class} klass Subclass of Ember.View (or Ember.View itself)\n    @returns Ember.View\n  */\n  nearestInstanceOf: function(klass) {\n    var view = get(this, 'parentView');\n\n    while (view) {\n      if(view instanceof klass) { return view; }\n      view = get(view, 'parentView');\n    }\n  },\n\n  /**\n    Return the nearest ancestor that has a given property.\n\n    @param {String} property A property name\n    @returns Ember.View\n  */\n  nearestWithProperty: function(property) {\n    var view = get(this, 'parentView');\n\n    while (view) {\n      if (property in view) { return view; }\n      view = get(view, 'parentView');\n    }\n  },\n\n  /**\n    Return the nearest ancestor whose parent is an instance of\n    `klass`.\n\n    @param {Class} klass Subclass of Ember.View (or Ember.View itself)\n    @returns Ember.View\n  */\n  nearestChildOf: function(klass) {\n    var view = get(this, 'parentView');\n\n    while (view) {\n      if(get(view, 'parentView') instanceof klass) { return view; }\n      view = get(view, 'parentView');\n    }\n  },\n\n  /**\n    Return the nearest ancestor that is an Ember.CollectionView\n\n    @returns Ember.CollectionView\n  */\n  collectionView: Ember.computed(function() {\n    return this.nearestInstanceOf(Ember.CollectionView);\n  }).cacheable(),\n\n  /**\n    Return the nearest ancestor that is a direct child of\n    an Ember.CollectionView\n\n    @returns Ember.View\n  */\n  itemView: Ember.computed(function() {\n    return this.nearestChildOf(Ember.CollectionView);\n  }).cacheable(),\n\n  /**\n    Return the nearest ancestor that has the property\n    `content`.\n\n    @returns Ember.View\n  */\n  contentView: Ember.computed(function() {\n    return this.nearestWithProperty('content');\n  }).cacheable(),\n\n  /**\n    @private\n\n    When the parent view changes, recursively invalidate\n    collectionView, itemView, and contentView\n  */\n  _parentViewDidChange: Ember.observer(function() {\n    if (this.isDestroying) { return; }\n\n    this.invokeRecursively(function(view) {\n      view.propertyDidChange('collectionView');\n      view.propertyDidChange('itemView');\n      view.propertyDidChange('contentView');\n    });\n\n    if (get(this, 'parentView.controller') && !get(this, 'controller')) {\n      this.notifyPropertyChange('controller');\n    }\n  }, '_parentView'),\n\n  _controllerDidChange: Ember.observer(function() {\n    if (this.isDestroying) { return; }\n\n    this.forEachChildView(function(view) {\n      view.propertyDidChange('controller');\n    });\n  }, 'controller'),\n\n  cloneKeywords: function() {\n    var templateData = get(this, 'templateData');\n\n    var keywords = templateData ? Ember.copy(templateData.keywords) : {};\n    set(keywords, 'view', get(this, 'concreteView'));\n    set(keywords, 'controller', get(this, 'controller'));\n\n    return keywords;\n  },\n\n  /**\n    Called on your view when it should push strings of HTML into a\n    Ember.RenderBuffer. Most users will want to override the `template`\n    or `templateName` properties instead of this method.\n\n    By default, Ember.View will look for a function in the `template`\n    property and invoke it with the value of `context`. The value of\n    `context` will be the view's controller unless you override it.\n\n    @param {Ember.RenderBuffer} buffer The render buffer\n  */\n  render: function(buffer) {\n    // If this view has a layout, it is the responsibility of the\n    // the layout to render the view's template. Otherwise, render the template\n    // directly.\n    var template = get(this, 'layout') || get(this, 'template');\n\n    if (template) {\n      var context = get(this, 'context');\n      var keywords = this.cloneKeywords();\n\n      var data = {\n        view: this,\n        buffer: buffer,\n        isRenderData: true,\n        keywords: keywords\n      };\n\n      // Invoke the template with the provided template context, which\n      // is the view by default. A hash of data is also passed that provides\n      // the template with access to the view and render buffer.\n\n      Ember.assert('template must be a function. Did you mean to call Ember.Handlebars.compile(\"...\") or specify templateName instead?', typeof template === 'function');\n      // The template should write directly to the render buffer instead\n      // of returning a string.\n      var output = template(context, { data: data });\n\n      // If the template returned a string instead of writing to the buffer,\n      // push the string onto the buffer.\n      if (output !== undefined) { buffer.push(output); }\n    }\n  },\n\n  invokeForState: function(name) {\n    var stateName = this.state, args, fn;\n\n    // try to find the function for the state in the cache\n    if (fn = invokeForState[stateName][name]) {\n      args = a_slice.call(arguments);\n      args[0] = this;\n\n      return fn.apply(this, args);\n    }\n\n    // otherwise, find and cache the function for this state\n    var parent = this, states = parent.states, state;\n\n    while (states) {\n      state = states[stateName];\n\n      while (state) {\n        fn = state[name];\n\n        if (fn) {\n          invokeForState[stateName][name] = fn;\n\n          args = a_slice.call(arguments, 1);\n          args.unshift(this);\n\n          return fn.apply(this, args);\n        }\n\n        state = state.parentState;\n      }\n\n      states = states.parent;\n    }\n  },\n\n  /**\n    Renders the view again. This will work regardless of whether the\n    view is already in the DOM or not. If the view is in the DOM, the\n    rendering process will be deferred to give bindings a chance\n    to synchronize.\n\n    If children were added during the rendering process using `appendChild`,\n    `rerender` will remove them, because they will be added again\n    if needed by the next `render`.\n\n    In general, if the display of your view changes, you should modify\n    the DOM element directly instead of manually calling `rerender`, which can\n    be slow.\n  */\n  rerender: function() {\n    return this.invokeForState('rerender');\n  },\n\n  clearRenderedChildren: function() {\n    var lengthBefore = this.lengthBeforeRender,\n        lengthAfter  = this.lengthAfterRender;\n\n    // If there were child views created during the last call to render(),\n    // remove them under the assumption that they will be re-created when\n    // we re-render.\n\n    // VIEW-TODO: Unit test this path.\n    var childViews = this._childViews;\n    for (var i=lengthAfter-1; i>=lengthBefore; i--) {\n      if (childViews[i]) { childViews[i].destroy(); }\n    }\n  },\n\n  /**\n    @private\n\n    Iterates over the view's `classNameBindings` array, inserts the value\n    of the specified property into the `classNames` array, then creates an\n    observer to update the view's element if the bound property ever changes\n    in the future.\n  */\n  _applyClassNameBindings: function() {\n    var classBindings = get(this, 'classNameBindings'),\n        classNames = get(this, 'classNames'),\n        elem, newClass, dasherizedClass;\n\n    if (!classBindings) { return; }\n\n    // Loop through all of the configured bindings. These will be either\n    // property names ('isUrgent') or property paths relative to the view\n    // ('content.isUrgent')\n    a_forEach(classBindings, function(binding) {\n\n      // Variable in which the old class value is saved. The observer function\n      // closes over this variable, so it knows which string to remove when\n      // the property changes.\n      var oldClass;\n\n      // Set up an observer on the context. If the property changes, toggle the\n      // class name.\n      var observer = function() {\n        // Get the current value of the property\n        newClass = this._classStringForProperty(binding);\n        elem = this.$();\n\n        // If we had previously added a class to the element, remove it.\n        if (oldClass) {\n          elem.removeClass(oldClass);\n          // Also remove from classNames so that if the view gets rerendered,\n          // the class doesn't get added back to the DOM.\n          classNames.removeObject(oldClass);\n        }\n\n        // If necessary, add a new class. Make sure we keep track of it so\n        // it can be removed in the future.\n        if (newClass) {\n          elem.addClass(newClass);\n          oldClass = newClass;\n        } else {\n          oldClass = null;\n        }\n      };\n\n      // Get the class name for the property at its current value\n      dasherizedClass = this._classStringForProperty(binding);\n\n      if (dasherizedClass) {\n        // Ensure that it gets into the classNames array\n        // so it is displayed when we render.\n        classNames.push(dasherizedClass);\n\n        // Save a reference to the class name so we can remove it\n        // if the observer fires. Remember that this variable has\n        // been closed over by the observer.\n        oldClass = dasherizedClass;\n      }\n\n      // Extract just the property name from bindings like 'foo:bar'\n      var parsedPath = Ember.View._parsePropertyPath(binding);\n      addObserver(this, parsedPath.path, observer);\n    }, this);\n  },\n\n  /**\n    Iterates through the view's attribute bindings, sets up observers for each,\n    then applies the current value of the attributes to the passed render buffer.\n\n    @param {Ember.RenderBuffer} buffer\n  */\n  _applyAttributeBindings: function(buffer) {\n    var attributeBindings = get(this, 'attributeBindings'),\n        attributeValue, elem, type;\n\n    if (!attributeBindings) { return; }\n\n    a_forEach(attributeBindings, function(binding) {\n      var split = binding.split(':'),\n          property = split[0],\n          attributeName = split[1] || property;\n\n      // Create an observer to add/remove/change the attribute if the\n      // JavaScript property changes.\n      var observer = function() {\n        elem = this.$();\n        if (!elem) { return; }\n\n        attributeValue = get(this, property);\n\n        Ember.View.applyAttributeBindings(elem, attributeName, attributeValue);\n      };\n\n      addObserver(this, property, observer);\n\n      // Determine the current value and add it to the render buffer\n      // if necessary.\n      attributeValue = get(this, property);\n      Ember.View.applyAttributeBindings(buffer, attributeName, attributeValue);\n    }, this);\n  },\n\n  /**\n    @private\n\n    Given a property name, returns a dasherized version of that\n    property name if the property evaluates to a non-falsy value.\n\n    For example, if the view has property `isUrgent` that evaluates to true,\n    passing `isUrgent` to this method will return `\"is-urgent\"`.\n  */\n  _classStringForProperty: function(property) {\n    var parsedPath = Ember.View._parsePropertyPath(property);\n    var path = parsedPath.path;\n\n    var val = get(this, path);\n    if (val === undefined && Ember.isGlobalPath(path)) {\n      val = get(window, path);\n    }\n\n    return Ember.View._classStringForValue(path, val, parsedPath.className, parsedPath.falsyClassName);\n  },\n\n  // ..........................................................\n  // ELEMENT SUPPORT\n  //\n\n  /**\n    Returns the current DOM element for the view.\n\n    @field\n    @type DOMElement\n  */\n  element: Ember.computed(function(key, value) {\n    if (value !== undefined) {\n      return this.invokeForState('setElement', value);\n    } else {\n      return this.invokeForState('getElement');\n    }\n  }).property('_parentView').cacheable(),\n\n  /**\n    Returns a jQuery object for this view's element. If you pass in a selector\n    string, this method will return a jQuery object, using the current element\n    as its buffer.\n\n    For example, calling `view.$('li')` will return a jQuery object containing\n    all of the `li` elements inside the DOM element of this view.\n\n    @param {String} [selector] a jQuery-compatible selector string\n    @returns {Ember.CoreQuery} the CoreQuery object for the DOM node\n  */\n  $: function(sel) {\n    return this.invokeForState('$', sel);\n  },\n\n  /** @private */\n  mutateChildViews: function(callback) {\n    var childViews = this._childViews,\n        idx = childViews.length,\n        view;\n\n    while(--idx >= 0) {\n      view = childViews[idx];\n      callback.call(this, view, idx);\n    }\n\n    return this;\n  },\n\n  /** @private */\n  forEachChildView: function(callback) {\n    var childViews = this._childViews;\n\n    if (!childViews) { return this; }\n\n    var len = childViews.length,\n        view, idx;\n\n    for(idx = 0; idx < len; idx++) {\n      view = childViews[idx];\n      callback.call(this, view);\n    }\n\n    return this;\n  },\n\n  /**\n    Appends the view's element to the specified parent element.\n\n    If the view does not have an HTML representation yet, `createElement()`\n    will be called automatically.\n\n    Note that this method just schedules the view to be appended; the DOM\n    element will not be appended to the given element until all bindings have\n    finished synchronizing.\n\n    This is not typically a function that you will need to call directly\n    when building your application. You might consider using Ember.ContainerView\n    instead. If you do need to use appendTo, be sure that the target element you\n    are providing is associated with an Ember.Application and does not have an\n    ancestor element that is associated with an Ember view.\n\n    @param {String|DOMElement|jQuery} A selector, element, HTML string, or jQuery object\n    @returns {Ember.View} receiver\n  */\n  appendTo: function(target) {\n    // Schedule the DOM element to be created and appended to the given\n    // element after bindings have synchronized.\n    this._insertElementLater(function() {\n      Ember.assert(\"You cannot append to an existing Ember.View. Consider using Ember.ContainerView instead.\", !Ember.$(target).is('.ember-view') && !Ember.$(target).parents().is('.ember-view'));\n      this.$().appendTo(target);\n    });\n\n    return this;\n  },\n\n  /**\n    Replaces the content of the specified parent element with this view's element.\n    If the view does not have an HTML representation yet, `createElement()`\n    will be called automatically.\n\n    Note that this method just schedules the view to be appended; the DOM\n    element will not be appended to the given element until all bindings have\n    finished synchronizing\n\n    @param {String|DOMElement|jQuery} A selector, element, HTML string, or jQuery object\n    @returns {Ember.View} received\n  */\n  replaceIn: function(target) {\n    Ember.assert(\"You cannot replace an existing Ember.View. Consider using Ember.ContainerView instead.\", !Ember.$(target).is('.ember-view') && !Ember.$(target).parents().is('.ember-view'));\n\n    this._insertElementLater(function() {\n      Ember.$(target).empty();\n      this.$().appendTo(target);\n    });\n\n    return this;\n  },\n\n  /**\n    @private\n\n    Schedules a DOM operation to occur during the next render phase. This\n    ensures that all bindings have finished synchronizing before the view is\n    rendered.\n\n    To use, pass a function that performs a DOM operation..\n\n    Before your function is called, this view and all child views will receive\n    the `willInsertElement` event. After your function is invoked, this view\n    and all of its child views will receive the `didInsertElement` event.\n\n        view._insertElementLater(function() {\n          this.createElement();\n          this.$().appendTo('body');\n        });\n\n    @param {Function} fn the function that inserts the element into the DOM\n  */\n  _insertElementLater: function(fn) {\n    this._lastInsert = Ember.guidFor(fn);\n    Ember.run.schedule('render', this, this.invokeForState, 'insertElement', fn);\n  },\n\n  /**\n    Appends the view's element to the document body. If the view does\n    not have an HTML representation yet, `createElement()` will be called\n    automatically.\n\n    Note that this method just schedules the view to be appended; the DOM\n    element will not be appended to the document body until all bindings have\n    finished synchronizing.\n\n    @returns {Ember.View} receiver\n  */\n  append: function() {\n    return this.appendTo(document.body);\n  },\n\n  /**\n    Removes the view's element from the element to which it is attached.\n\n    @returns {Ember.View} receiver\n  */\n  remove: function() {\n    // What we should really do here is wait until the end of the run loop\n    // to determine if the element has been re-appended to a different\n    // element.\n    // In the interim, we will just re-render if that happens. It is more\n    // important than elements get garbage collected.\n    this.destroyElement();\n    this.invokeRecursively(function(view) {\n      view.clearRenderedChildren();\n    });\n  },\n\n  /**\n    The ID to use when trying to locate the element in the DOM. If you do not\n    set the elementId explicitly, then the view's GUID will be used instead.\n    This ID must be set at the time the view is created.\n\n    @type String\n    @readOnly\n  */\n  elementId: Ember.computed(function(key, value) {\n    return value !== undefined ? value : Ember.guidFor(this);\n  }).cacheable(),\n\n  /**\n    @private\n\n    TODO: Perhaps this should be removed from the production build somehow.\n  */\n  _elementIdDidChange: Ember.beforeObserver(function() {\n    throw \"Changing a view's elementId after creation is not allowed.\";\n  }, 'elementId'),\n\n  /**\n    Attempts to discover the element in the parent element. The default\n    implementation looks for an element with an ID of elementId (or the view's\n    guid if elementId is null). You can override this method to provide your\n    own form of lookup. For example, if you want to discover your element\n    using a CSS class name instead of an ID.\n\n    @param {DOMElement} parentElement The parent's DOM element\n    @returns {DOMElement} The discovered element\n  */\n  findElementInParentElement: function(parentElem) {\n    var id = \"#\" + get(this, 'elementId');\n    return Ember.$(id)[0] || Ember.$(id, parentElem)[0];\n  },\n\n  /**\n    Creates a new renderBuffer with the passed tagName. You can override this\n    method to provide further customization to the buffer if needed. Normally\n    you will not need to call or override this method.\n\n    @returns {Ember.RenderBuffer}\n  */\n  renderBuffer: function(tagName) {\n    tagName = tagName || get(this, 'tagName');\n\n    // Explicitly check for null or undefined, as tagName\n    // may be an empty string, which would evaluate to false.\n    if (tagName === null || tagName === undefined) {\n      tagName = 'div';\n    }\n\n    return Ember.RenderBuffer(tagName);\n  },\n\n  /**\n    Creates a DOM representation of the view and all of its\n    child views by recursively calling the `render()` method.\n\n    After the element has been created, `didInsertElement` will\n    be called on this view and all of its child views.\n\n    @returns {Ember.View} receiver\n  */\n  createElement: function() {\n    if (get(this, 'element')) { return this; }\n\n    var buffer = this.renderToBuffer();\n    set(this, 'element', buffer.element());\n\n    return this;\n  },\n\n  /**\n    Called when a view is going to insert an element into the DOM.\n  */\n  willInsertElement: Ember.K,\n\n  /**\n    Called when the element of the view has been inserted into the DOM.\n    Override this function to do any set up that requires an element in the\n    document body.\n  */\n  didInsertElement: Ember.K,\n\n  /**\n    Called when the view is about to rerender, but before anything has\n    been torn down. This is a good opportunity to tear down any manual\n    observers you have installed based on the DOM state\n  */\n  willRerender: Ember.K,\n\n  /**\n    Run this callback on the current view and recursively on child views.\n\n    @private\n  */\n  invokeRecursively: function(fn) {\n    fn.call(this, this);\n\n    this.forEachChildView(function(view) {\n      view.invokeRecursively(fn);\n    });\n  },\n\n  /**\n    Invalidates the cache for a property on all child views.\n  */\n  invalidateRecursively: function(key) {\n    this.forEachChildView(function(view) {\n      view.propertyDidChange(key);\n    });\n  },\n\n  /**\n    @private\n\n    Invokes the receiver's willInsertElement() method if it exists and then\n    invokes the same on all child views.\n\n    NOTE: In some cases this was called when the element existed. This no longer\n    works so we let people know. We can remove this warning code later.\n  */\n  _notifyWillInsertElement: function() {\n    this.invokeRecursively(function(view) {\n      view.trigger('willInsertElement');\n    });\n  },\n\n  /**\n    @private\n\n    Invokes the receiver's didInsertElement() method if it exists and then\n    invokes the same on all child views.\n  */\n  _notifyDidInsertElement: function() {\n    this.invokeRecursively(function(view) {\n      view.trigger('didInsertElement');\n    });\n  },\n\n  /**\n    @private\n\n    Invokes the receiver's willRerender() method if it exists and then\n    invokes the same on all child views.\n  */\n  _notifyWillRerender: function() {\n    this.invokeRecursively(function(view) {\n      view.trigger('willRerender');\n    });\n  },\n\n  /**\n    Destroys any existing element along with the element for any child views\n    as well. If the view does not currently have a element, then this method\n    will do nothing.\n\n    If you implement willDestroyElement() on your view, then this method will\n    be invoked on your view before your element is destroyed to give you a\n    chance to clean up any event handlers, etc.\n\n    If you write a willDestroyElement() handler, you can assume that your\n    didInsertElement() handler was called earlier for the same element.\n\n    Normally you will not call or override this method yourself, but you may\n    want to implement the above callbacks when it is run.\n\n    @returns {Ember.View} receiver\n  */\n  destroyElement: function() {\n    return this.invokeForState('destroyElement');\n  },\n\n  /**\n    Called when the element of the view is going to be destroyed. Override\n    this function to do any teardown that requires an element, like removing\n    event listeners.\n  */\n  willDestroyElement: function() {},\n\n  /**\n    @private\n\n    Invokes the `willDestroyElement` callback on the view and child views.\n  */\n  _notifyWillDestroyElement: function() {\n    this.invokeRecursively(function(view) {\n      view.trigger('willDestroyElement');\n    });\n  },\n\n  /** @private (nodoc) */\n  _elementWillChange: Ember.beforeObserver(function() {\n    this.forEachChildView(function(view) {\n      Ember.propertyWillChange(view, 'element');\n    });\n  }, 'element'),\n\n  /**\n    @private\n\n    If this view's element changes, we need to invalidate the caches of our\n    child views so that we do not retain references to DOM elements that are\n    no longer needed.\n\n    @observes element\n  */\n  _elementDidChange: Ember.observer(function() {\n    this.forEachChildView(function(view) {\n      Ember.propertyDidChange(view, 'element');\n    });\n  }, 'element'),\n\n  /**\n    Called when the parentView property has changed.\n\n    @function\n  */\n  parentViewDidChange: Ember.K,\n\n  /**\n    @private\n\n    Invoked by the view system when this view needs to produce an HTML\n    representation. This method will create a new render buffer, if needed,\n    then apply any default attributes, such as class names and visibility.\n    Finally, the `render()` method is invoked, which is responsible for\n    doing the bulk of the rendering.\n\n    You should not need to override this method; instead, implement the\n    `template` property, or if you need more control, override the `render`\n    method.\n\n    @param {Ember.RenderBuffer} buffer the render buffer. If no buffer is\n      passed, a default buffer, using the current view's `tagName`, will\n      be used.\n  */\n  renderToBuffer: function(parentBuffer, bufferOperation) {\n    var buffer;\n\n    Ember.run.sync();\n\n    // Determine where in the parent buffer to start the new buffer.\n    // By default, a new buffer will be appended to the parent buffer.\n    // The buffer operation may be changed if the child views array is\n    // mutated by Ember.ContainerView.\n    bufferOperation = bufferOperation || 'begin';\n\n    // If this is the top-most view, start a new buffer. Otherwise,\n    // create a new buffer relative to the original using the\n    // provided buffer operation (for example, `insertAfter` will\n    // insert a new buffer after the \"parent buffer\").\n    if (parentBuffer) {\n      var tagName = get(this, 'tagName');\n      if (tagName === null || tagName === undefined) {\n        tagName = 'div';\n      }\n\n      buffer = parentBuffer[bufferOperation](tagName);\n    } else {\n      buffer = this.renderBuffer();\n    }\n\n    this.buffer = buffer;\n    this.transitionTo('inBuffer', false);\n\n    this.lengthBeforeRender = this._childViews.length;\n\n    this.beforeRender(buffer);\n    this.render(buffer);\n    this.afterRender(buffer);\n\n    this.lengthAfterRender = this._childViews.length;\n\n    return buffer;\n  },\n\n  renderToBufferIfNeeded: function () {\n    return this.invokeForState('renderToBufferIfNeeded', this);\n  },\n\n  beforeRender: function(buffer) {\n    this.applyAttributesToBuffer(buffer);\n  },\n\n  afterRender: Ember.K,\n\n  /**\n    @private\n  */\n  applyAttributesToBuffer: function(buffer) {\n    // Creates observers for all registered class name and attribute bindings,\n    // then adds them to the element.\n    this._applyClassNameBindings();\n\n    // Pass the render buffer so the method can apply attributes directly.\n    // This isn't needed for class name bindings because they use the\n    // existing classNames infrastructure.\n    this._applyAttributeBindings(buffer);\n\n\n    a_forEach(get(this, 'classNames'), function(name){ buffer.addClass(name); });\n    buffer.id(get(this, 'elementId'));\n\n    var role = get(this, 'ariaRole');\n    if (role) {\n      buffer.attr('role', role);\n    }\n\n    if (get(this, 'isVisible') === false) {\n      buffer.style('display', 'none');\n    }\n  },\n\n  // ..........................................................\n  // STANDARD RENDER PROPERTIES\n  //\n\n  /**\n    Tag name for the view's outer element. The tag name is only used when\n    an element is first created. If you change the tagName for an element, you\n    must destroy and recreate the view element.\n\n    By default, the render buffer will use a `<div>` tag for views.\n\n    @type String\n    @default null\n  */\n\n  // We leave this null by default so we can tell the difference between\n  // the default case and a user-specified tag.\n  tagName: null,\n\n  /**\n    The WAI-ARIA role of the control represented by this view. For example, a\n    button may have a role of type 'button', or a pane may have a role of\n    type 'alertdialog'. This property is used by assistive software to help\n    visually challenged users navigate rich web applications.\n\n    The full list of valid WAI-ARIA roles is available at:\n    http://www.w3.org/TR/wai-aria/roles#roles_categorization\n\n    @type String\n    @default null\n  */\n  ariaRole: null,\n\n  /**\n    Standard CSS class names to apply to the view's outer element. This\n    property automatically inherits any class names defined by the view's\n    superclasses as well.\n\n    @type Array\n    @default ['ember-view']\n  */\n  classNames: ['ember-view'],\n\n  /**\n    A list of properties of the view to apply as class names. If the property\n    is a string value, the value of that string will be applied as a class\n    name.\n\n        // Applies the 'high' class to the view element\n        Ember.View.create({\n          classNameBindings: ['priority']\n          priority: 'high'\n        });\n\n    If the value of the property is a Boolean, the name of that property is\n    added as a dasherized class name.\n\n        // Applies the 'is-urgent' class to the view element\n        Ember.View.create({\n          classNameBindings: ['isUrgent']\n          isUrgent: true\n        });\n\n    If you would prefer to use a custom value instead of the dasherized\n    property name, you can pass a binding like this:\n\n        // Applies the 'urgent' class to the view element\n        Ember.View.create({\n          classNameBindings: ['isUrgent:urgent']\n          isUrgent: true\n        });\n\n    This list of properties is inherited from the view's superclasses as well.\n\n    @type Array\n    @default []\n  */\n  classNameBindings: [],\n\n  /**\n    A list of properties of the view to apply as attributes. If the property is\n    a string value, the value of that string will be applied as the attribute.\n\n        // Applies the type attribute to the element\n        // with the value \"button\", like <div type=\"button\">\n        Ember.View.create({\n          attributeBindings: ['type'],\n          type: 'button'\n        });\n\n    If the value of the property is a Boolean, the name of that property is\n    added as an attribute.\n\n        // Renders something like <div enabled=\"enabled\">\n        Ember.View.create({\n          attributeBindings: ['enabled'],\n          enabled: true\n        });\n  */\n  attributeBindings: [],\n\n  state: 'preRender',\n\n  // .......................................................\n  // CORE DISPLAY METHODS\n  //\n\n  /**\n    @private\n\n    Setup a view, but do not finish waking it up.\n    - configure childViews\n    - register the view with the global views hash, which is used for event\n      dispatch\n  */\n  init: function() {\n    this._super();\n\n    // Register the view for event handling. This hash is used by\n    // Ember.EventDispatcher to dispatch incoming events.\n    if (!this.isVirtual) Ember.View.views[get(this, 'elementId')] = this;\n\n    // setup child views. be sure to clone the child views array first\n    this._childViews = this._childViews.slice();\n\n    Ember.assert(\"Only arrays are allowed for 'classNameBindings'\", Ember.typeOf(this.classNameBindings) === 'array');\n    this.classNameBindings = Ember.A(this.classNameBindings.slice());\n\n    Ember.assert(\"Only arrays are allowed for 'classNames'\", Ember.typeOf(this.classNames) === 'array');\n    this.classNames = Ember.A(this.classNames.slice());\n\n    var viewController = get(this, 'viewController');\n    if (viewController) {\n      viewController = get(viewController);\n      if (viewController) {\n        set(viewController, 'view', this);\n      }\n    }\n  },\n\n  appendChild: function(view, options) {\n    return this.invokeForState('appendChild', view, options);\n  },\n\n  /**\n    Removes the child view from the parent view.\n\n    @param {Ember.View} view\n    @returns {Ember.View} receiver\n  */\n  removeChild: function(view) {\n    // If we're destroying, the entire subtree will be\n    // freed, and the DOM will be handled separately,\n    // so no need to mess with childViews.\n    if (this.isDestroying) { return; }\n\n    // update parent node\n    set(view, '_parentView', null);\n\n    // remove view from childViews array.\n    var childViews = this._childViews;\n\n    Ember.EnumerableUtils.removeObject(childViews, view);\n\n    this.propertyDidChange('childViews'); // HUH?! what happened to will change?\n\n    return this;\n  },\n\n  /**\n    Removes all children from the parentView.\n\n    @returns {Ember.View} receiver\n  */\n  removeAllChildren: function() {\n    return this.mutateChildViews(function(view) {\n      this.removeChild(view);\n    });\n  },\n\n  destroyAllChildren: function() {\n    return this.mutateChildViews(function(view) {\n      view.destroy();\n    });\n  },\n\n  /**\n    Removes the view from its parentView, if one is found. Otherwise\n    does nothing.\n\n    @returns {Ember.View} receiver\n  */\n  removeFromParent: function() {\n    var parent = get(this, '_parentView');\n\n    // Remove DOM element from parent\n    this.remove();\n\n    if (parent) { parent.removeChild(this); }\n    return this;\n  },\n\n  /**\n    You must call `destroy` on a view to destroy the view (and all of its\n    child views). This will remove the view from any parent node, then make\n    sure that the DOM element managed by the view can be released by the\n    memory manager.\n  */\n  willDestroy: function() {\n    // calling this._super() will nuke computed properties and observers,\n    // so collect any information we need before calling super.\n    var childViews = this._childViews,\n        parent     = get(this, '_parentView'),\n        childLen;\n\n    // destroy the element -- this will avoid each child view destroying\n    // the element over and over again...\n    if (!this.removedFromDOM) { this.destroyElement(); }\n\n    // remove from non-virtual parent view if viewName was specified\n    if (this.viewName) {\n      var nonVirtualParentView = get(this, 'parentView');\n      if (nonVirtualParentView) {\n        set(nonVirtualParentView, this.viewName, null);\n      }\n    }\n\n    // remove from parent if found. Don't call removeFromParent,\n    // as removeFromParent will try to remove the element from\n    // the DOM again.\n    if (parent) { parent.removeChild(this); }\n\n    this.state = 'destroyed';\n\n    childLen = childViews.length;\n    for (var i=childLen-1; i>=0; i--) {\n      childViews[i].removedFromDOM = true;\n      childViews[i].destroy();\n    }\n\n    // next remove view from global hash\n    if (!this.isVirtual) delete Ember.View.views[get(this, 'elementId')];\n  },\n\n  /**\n    Instantiates a view to be added to the childViews array during view\n    initialization. You generally will not call this method directly unless\n    you are overriding createChildViews(). Note that this method will\n    automatically configure the correct settings on the new view instance to\n    act as a child of the parent.\n\n    @param {Class} viewClass\n    @param {Hash} [attrs] Attributes to add\n    @returns {Ember.View} new instance\n    @test in createChildViews\n  */\n  createChildView: function(view, attrs) {\n    if (Ember.View.detect(view)) {\n      attrs = attrs || {};\n      attrs._parentView = this;\n      attrs.templateData = attrs.templateData || get(this, 'templateData');\n\n      view = view.create(attrs);\n\n      // don't set the property on a virtual view, as they are invisible to\n      // consumers of the view API\n      if (view.viewName) { set(get(this, 'concreteView'), view.viewName, view); }\n    } else {\n      Ember.assert('You must pass instance or subclass of View', view instanceof Ember.View);\n      Ember.assert(\"You can only pass attributes when a class is provided\", !attrs);\n\n      if (!get(view, 'templateData')) {\n        set(view, 'templateData', get(this, 'templateData'));\n      }\n\n      set(view, '_parentView', this);\n    }\n\n    return view;\n  },\n\n  becameVisible: Ember.K,\n  becameHidden: Ember.K,\n\n  /**\n    @private\n\n    When the view's `isVisible` property changes, toggle the visibility\n    element of the actual DOM element.\n  */\n  _isVisibleDidChange: Ember.observer(function() {\n    var $el = this.$();\n    if (!$el) { return; }\n\n    var isVisible = get(this, 'isVisible');\n\n    $el.toggle(isVisible);\n\n    if (this._isAncestorHidden()) { return; }\n\n    if (isVisible) {\n      this._notifyBecameVisible();\n    } else {\n      this._notifyBecameHidden();\n    }\n  }, 'isVisible'),\n\n  _notifyBecameVisible: function() {\n    this.trigger('becameVisible');\n\n    this.forEachChildView(function(view) {\n      var isVisible = get(view, 'isVisible');\n\n      if (isVisible || isVisible === null) {\n        view._notifyBecameVisible();\n      }\n    });\n  },\n\n  _notifyBecameHidden: function() {\n    this.trigger('becameHidden');\n    this.forEachChildView(function(view) {\n      var isVisible = get(view, 'isVisible');\n\n      if (isVisible || isVisible === null) {\n        view._notifyBecameHidden();\n      }\n    });\n  },\n\n  _isAncestorHidden: function() {\n    var parent = get(this, 'parentView');\n\n    while (parent) {\n      if (get(parent, 'isVisible') === false) { return true; }\n\n      parent = get(parent, 'parentView');\n    }\n\n    return false;\n  },\n\n  clearBuffer: function() {\n    this.invokeRecursively(function(view) {\n      this.buffer = null;\n    });\n  },\n\n  transitionTo: function(state, children) {\n    this.state = state;\n\n    if (children !== false) {\n      this.forEachChildView(function(view) {\n        view.transitionTo(state);\n      });\n    }\n  },\n\n  /**\n    @private\n\n    Override the default event firing from Ember.Evented to\n    also call methods with the given name.\n  */\n  trigger: function(name) {\n    this._super.apply(this, arguments);\n    var method = this[name];\n    if (method) {\n      var args = [], i, l;\n      for (i = 1, l = arguments.length; i < l; i++) {\n        args.push(arguments[i]);\n      }\n      return method.apply(this, args);\n    }\n  },\n\n  has: function(name) {\n    return Ember.typeOf(this[name]) === 'function' || this._super(name);\n  },\n\n  // .......................................................\n  // EVENT HANDLING\n  //\n\n  /**\n    @private\n\n    Handle events from `Ember.EventDispatcher`\n  */\n  handleEvent: function(eventName, evt) {\n    return this.invokeForState('handleEvent', eventName, evt);\n  }\n\n});\n\n/**\n  Describe how the specified actions should behave in the various\n  states that a view can exist in. Possible states:\n\n  * preRender: when a view is first instantiated, and after its\n    element was destroyed, it is in the preRender state\n  * inBuffer: once a view has been rendered, but before it has\n    been inserted into the DOM, it is in the inBuffer state\n  * inDOM: once a view has been inserted into the DOM it is in\n    the inDOM state. A view spends the vast majority of its\n    existence in this state.\n  * destroyed: once a view has been destroyed (using the destroy\n    method), it is in this state. No further actions can be invoked\n    on a destroyed view.\n*/\n\n  // in the destroyed state, everything is illegal\n\n  // before rendering has begun, all legal manipulations are noops.\n\n  // inside the buffer, legal manipulations are done on the buffer\n\n  // once the view has been inserted into the DOM, legal manipulations\n  // are done on the DOM element.\n\n/** @private */\nvar DOMManager = {\n  prepend: function(view, html) {\n    view.$().prepend(html);\n  },\n\n  after: function(view, html) {\n    view.$().after(html);\n  },\n\n  html: function(view, html) {\n    view.$().html(html);\n  },\n\n  replace: function(view) {\n    var element = get(view, 'element');\n\n    set(view, 'element', null);\n\n    view._insertElementLater(function() {\n      Ember.$(element).replaceWith(get(view, 'element'));\n    });\n  },\n\n  remove: function(view) {\n    view.$().remove();\n  },\n\n  empty: function(view) {\n    view.$().empty();\n  }\n};\n\nEmber.View.reopen({\n  states: Ember.View.states,\n  domManager: DOMManager\n});\n\nEmber.View.reopenClass({\n\n  /**\n    @private\n\n    Parse a path and return an object which holds the parsed properties.\n\n    For example a path like \"content.isEnabled:enabled:disabled\" wil return the\n    following object:\n\n        {\n          path: \"content.isEnabled\",\n          className: \"enabled\",\n          falsyClassName: \"disabled\",\n          classNames: \":enabled:disabled\"\n        }\n\n  */\n  _parsePropertyPath: function(path) {\n    var split = path.split(/:/),\n        propertyPath = split[0],\n        classNames = \"\",\n        className,\n        falsyClassName;\n\n    // check if the property is defined as prop:class or prop:trueClass:falseClass\n    if (split.length > 1) {\n      className = split[1];\n      if (split.length === 3) { falsyClassName = split[2]; }\n\n      classNames = ':' + className;\n      if (falsyClassName) { classNames += \":\" + falsyClassName; }\n    }\n\n    return {\n      path: propertyPath,\n      classNames: classNames,\n      className: (className === '') ? undefined : className,\n      falsyClassName: falsyClassName\n    };\n  },\n\n  /**\n    @private\n\n    Get the class name for a given value, based on the path, optional className\n    and optional falsyClassName.\n\n    - if the value is truthy and a className is defined, the className is returned\n    - if the value is true, the dasherized last part of the supplied path is returned\n    - if the value is false and a falsyClassName is supplied, the falsyClassName is returned\n    - if the value is truthy, the value is returned\n    - if none of the above rules apply, null is returned\n\n  */\n  _classStringForValue: function(path, val, className, falsyClassName) {\n    // If the value is truthy and we're using the colon syntax,\n    // we should return the className directly\n    if (!!val && className) {\n      return className;\n\n    // If value is a Boolean and true, return the dasherized property\n    // name.\n    } else if (val === true) {\n      // catch syntax like isEnabled::not-enabled\n      if (val === true && !className && falsyClassName) { return null; }\n\n      // Normalize property path to be suitable for use\n      // as a class name. For exaple, content.foo.barBaz\n      // becomes bar-baz.\n      var parts = path.split('.');\n      return Ember.String.dasherize(parts[parts.length-1]);\n\n    // If the value is false and a falsyClassName is specified, return it\n    } else if (val === false && falsyClassName) {\n      return falsyClassName;\n\n    // If the value is not false, undefined, or null, return the current\n    // value of the property.\n    } else if (val !== false && val !== undefined && val !== null) {\n      return val;\n\n    // Nothing to display. Return null so that the old class is removed\n    // but no new class is added.\n    } else {\n      return null;\n    }\n  }\n});\n\n// Create a global view hash.\nEmber.View.views = {};\n\n// If someone overrides the child views computed property when\n// defining their class, we want to be able to process the user's\n// supplied childViews and then restore the original computed property\n// at view initialization time. This happens in Ember.ContainerView's init\n// method.\nEmber.View.childViewsProperty = childViewsProperty;\n\nEmber.View.applyAttributeBindings = function(elem, name, value) {\n  var type = Ember.typeOf(value);\n  var currentValue = elem.attr(name);\n\n  // if this changes, also change the logic in ember-handlebars/lib/helpers/binding.js\n  if ((type === 'string' || (type === 'number' && !isNaN(value))) && value !== currentValue) {\n    elem.attr(name, value);\n  } else if (value && type === 'boolean') {\n    elem.attr(name, name);\n  } else if (!value) {\n    elem.removeAttr(name);\n  }\n};\n\n})();\n//@ sourceURL=ember-views/views/view");