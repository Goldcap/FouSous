minispade.register('ember-views/views/collection_view', "(function() {// ==========================================================================\n// Project:   Ember - JavaScript Application Framework\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            Portions ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\nminispade.require('ember-views/views/container_view');\nminispade.require('ember-runtime/system/string');\n\nvar get = Ember.get, set = Ember.set, fmt = Ember.String.fmt;\n\n/**\n  @class\n\n  `Ember.CollectionView` is an `Ember.View` descendent responsible for managing a\n  collection (an array or array-like object) by maintaing a child view object and \n  associated DOM representation for each item in the array and ensuring that child\n  views and their associated rendered HTML are updated when items in the array\n  are added, removed, or replaced.\n\n  ## Setting content\n  The managed collection of objects is referenced as the `Ember.CollectionView` instance's\n  `content` property.\n\n      someItemsView = Ember.CollectionView.create({\n        content: ['A', 'B','C']\n      })\n\n  The view for each item in the collection will have its `content` property set\n  to the item.\n\n  ## Specifying itemViewClass\n  By default the view class for each item in the managed collection will be an instance\n  of `Ember.View`. You can supply a different class by setting the `CollectionView`'s\n  `itemViewClass` property.\n\n  Given an empty `<body>` and the following code:\n\n\n        someItemsView = Ember.CollectionView.create({\n          classNames: ['a-collection'],\n          content: ['A','B','C'],\n          itemViewClass: Ember.View.extend({\n            template: Ember.Handlebars.compile(\"the letter: {{view.content}}\")\n          })\n        })\n\n        someItemsView.appendTo('body')\n\n  Will result in the following HTML structure\n\n        <div class=\"ember-view a-collection\">\n          <div class=\"ember-view\">the letter: A</div>\n          <div class=\"ember-view\">the letter: B</div>\n          <div class=\"ember-view\">the letter: C</div>\n        </div>\n\n  ## Automatic matching of parent/child tagNames\n\n  Setting the `tagName` property of a `CollectionView` to any of \n  \"ul\", \"ol\", \"table\", \"thead\", \"tbody\", \"tfoot\", \"tr\", or \"select\" will result\n  in the item views receiving an appropriately matched `tagName` property.\n\n\n  Given an empty `<body>` and the following code:\n\n        anUndorderedListView = Ember.CollectionView.create({\n          tagName: 'ul',\n          content: ['A','B','C'],\n          itemViewClass: Ember.View.extend({\n            template: Ember.Handlebars.compile(\"the letter: {{view.content}}\")\n          })\n        })\n\n        anUndorderedListView.appendTo('body')\n\n  Will result in the following HTML structure\n\n        <ul class=\"ember-view a-collection\">\n          <li class=\"ember-view\">the letter: A</li>\n          <li class=\"ember-view\">the letter: B</li>\n          <li class=\"ember-view\">the letter: C</li>\n        </ul>\n\n  Additional tagName pairs can be provided by adding to `Ember.CollectionView.CONTAINER_MAP `\n\n        Ember.CollectionView.CONTAINER_MAP['article'] = 'section'\n\n\n  ## Empty View\n  You can provide an `Ember.View` subclass to the `Ember.CollectionView` instance as its\n  `emptyView` property. If the `content` property of a `CollectionView` is set to `null`\n  or an empty array, an instance of this view will be the `CollectionView`s only child.\n\n        aListWithNothing = Ember.CollectionView.create({\n          classNames: ['nothing']\n          content: null,\n          emptyView: Ember.View.extend({\n            template: Ember.Handlebars.compile(\"The collection is empty\")\n          })\n        })\n\n        aListWithNothing.appendTo('body')\n\n  Will result in the following HTML structure\n\n        <div class=\"ember-view nothing\">\n          <div class=\"ember-view\">\n            The collection is empty\n          </div>\n        </div>\n\n  ## Adding and Removing items\n  The `childViews` property of a `CollectionView` should not be directly manipulated. Instead,\n  add, remove, replace items from its `content` property. This will trigger\n  appropriate changes to its rendered HTML.\n\n  ## Use in templates via the `{{collection}}` Ember.Handlebars helper\n  Ember.Handlebars provides a helper specifically for adding `CollectionView`s to templates.\n  See `Ember.Handlebars.collection` for more details\n\n  @since Ember 0.9\n  @extends Ember.ContainerView\n*/\nEmber.CollectionView = Ember.ContainerView.extend(\n/** @scope Ember.CollectionView.prototype */ {\n\n  /**\n    A list of items to be displayed by the Ember.CollectionView.\n\n    @type Ember.Array\n    @default null\n  */\n  content: null,\n\n  /**\n    @private\n\n    This provides metadata about what kind of empty view class this\n    collection would like if it is being instantiated from another\n    system (like Handlebars)\n  */\n  emptyViewClass: Ember.View,\n\n  /**\n    An optional view to display if content is set to an empty array.\n\n    @type Ember.View\n    @default null\n  */\n  emptyView: null,\n\n  /**\n    @type Ember.View\n    @default Ember.View\n  */\n  itemViewClass: Ember.View,\n\n  /** @private */\n  init: function() {\n    var ret = this._super();\n    this._contentDidChange();\n    return ret;\n  },\n\n  _contentWillChange: Ember.beforeObserver(function() {\n    var content = this.get('content');\n\n    if (content) { content.removeArrayObserver(this); }\n    var len = content ? get(content, 'length') : 0;\n    this.arrayWillChange(content, 0, len);\n  }, 'content'),\n\n  /**\n    @private\n\n    Check to make sure that the content has changed, and if so,\n    update the children directly. This is always scheduled\n    asynchronously, to allow the element to be created before\n    bindings have synchronized and vice versa.\n  */\n  _contentDidChange: Ember.observer(function() {\n    var content = get(this, 'content');\n\n    if (content) {\n      Ember.assert(fmt(\"an Ember.CollectionView's content must implement Ember.Array. You passed %@\", [content]), Ember.Array.detect(content));\n      content.addArrayObserver(this);\n    }\n\n    var len = content ? get(content, 'length') : 0;\n    this.arrayDidChange(content, 0, null, len);\n  }, 'content'),\n\n  willDestroy: function() {\n    var content = get(this, 'content');\n    if (content) { content.removeArrayObserver(this); }\n\n    this._super();\n  },\n\n  arrayWillChange: function(content, start, removedCount) {\n    // If the contents were empty before and this template collection has an\n    // empty view remove it now.\n    var emptyView = get(this, 'emptyView');\n    if (emptyView && emptyView instanceof Ember.View) {\n      emptyView.removeFromParent();\n    }\n\n    // Loop through child views that correspond with the removed items.\n    // Note that we loop from the end of the array to the beginning because\n    // we are mutating it as we go.\n    var childViews = get(this, 'childViews'), childView, idx, len;\n\n    len = get(childViews, 'length');\n\n    var removingAll = removedCount === len;\n\n    if (removingAll) {\n      this.invokeForState('empty');\n    }\n\n    for (idx = start + removedCount - 1; idx >= start; idx--) {\n      childView = childViews[idx];\n      if (removingAll) { childView.removedFromDOM = true; }\n      childView.destroy();\n    }\n  },\n\n  /**\n    Called when a mutation to the underlying content array occurs.\n\n    This method will replay that mutation against the views that compose the\n    Ember.CollectionView, ensuring that the view reflects the model.\n\n    This array observer is added in contentDidChange.\n\n    @param {Array} addedObjects\n      the objects that were added to the content\n\n    @param {Array} removedObjects\n      the objects that were removed from the content\n\n    @param {Number} changeIndex\n      the index at which the changes occurred\n  */\n  arrayDidChange: function(content, start, removed, added) {\n    var itemViewClass = get(this, 'itemViewClass'),\n        childViews = get(this, 'childViews'),\n        addedViews = [], view, item, idx, len, itemTagName;\n\n    if ('string' === typeof itemViewClass) {\n      itemViewClass = get(itemViewClass);\n    }\n\n    Ember.assert(fmt(\"itemViewClass must be a subclass of Ember.View, not %@\", [itemViewClass]), Ember.View.detect(itemViewClass));\n\n    len = content ? get(content, 'length') : 0;\n    if (len) {\n      for (idx = start; idx < start+added; idx++) {\n        item = content.objectAt(idx);\n\n        view = this.createChildView(itemViewClass, {\n          content: item,\n          contentIndex: idx\n        });\n\n        addedViews.push(view);\n      }\n    } else {\n      var emptyView = get(this, 'emptyView');\n      if (!emptyView) { return; }\n\n      emptyView = this.createChildView(emptyView);\n      addedViews.push(emptyView);\n      set(this, 'emptyView', emptyView);\n    }\n    childViews.replace(start, 0, addedViews);\n  },\n\n  createChildView: function(view, attrs) {\n    view = this._super(view, attrs);\n\n    var itemTagName = get(view, 'tagName');\n    var tagName = (itemTagName === null || itemTagName === undefined) ? Ember.CollectionView.CONTAINER_MAP[get(this, 'tagName')] : itemTagName;\n\n    set(view, 'tagName', tagName);\n\n    return view;\n  }\n});\n\n/**\n  @static\n\n  A map of parent tags to their default child tags. You can add\n  additional parent tags if you want collection views that use\n  a particular parent tag to default to a child tag.\n\n  @type Hash\n  @constant\n*/\nEmber.CollectionView.CONTAINER_MAP = {\n  ul: 'li',\n  ol: 'li',\n  table: 'tr',\n  thead: 'tr',\n  tbody: 'tr',\n  tfoot: 'tr',\n  tr: 'td',\n  select: 'option'\n};\n\n})();\n//@ sourceURL=ember-views/views/collection_view");