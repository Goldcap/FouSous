minispade.register('ember-routing/routable', "(function() {minispade.require('ember-routing/resolved_state');\n\nvar get = Ember.get;\n\n// The Ember Routable mixin assumes the existance of a simple\n// routing shim that supports the following three behaviors:\n//\n// * .getURL() - this is called when the page loads\n// * .setURL(newURL) - this is called from within the state\n//   manager when the state changes to a routable state\n// * .onURLChange(callback) - this happens when the user presses\n//   the back or forward button\n\nvar paramForClass = function(classObject) {\n  var className = classObject.toString(),\n      parts = className.split(\".\"),\n      last = parts[parts.length - 1];\n\n  return Ember.String.underscore(last) + \"_id\";\n};\n\nvar merge = function(original, hash) {\n  for (var prop in hash) {\n    if (!hash.hasOwnProperty(prop)) { continue; }\n    if (original.hasOwnProperty(prop)) { continue; }\n\n    original[prop] = hash[prop];\n  }\n};\n\n/**\n  @class\n  @extends Ember.Mixin\n*/\nEmber.Routable = Ember.Mixin.create({\n  init: function() {\n    var redirection;\n    this.on('connectOutlets', this, this.stashContext);\n\n    if (redirection = get(this, 'redirectsTo')) {\n      Ember.assert(\"You cannot use `redirectsTo` if you already have a `connectOutlets` method\", this.connectOutlets === Ember.K);\n\n      this.connectOutlets = function(router) {\n        router.transitionTo(redirection);\n      };\n    }\n\n    // normalize empty route to '/'\n    var route = get(this, 'route');\n    if (route === '') {\n      route = '/';\n    }\n\n    this._super();\n\n    Ember.assert(\"You cannot use `redirectsTo` on a state that has child states\", !redirection || (!!redirection && !!get(this, 'isLeaf')));\n  },\n\n  /**\n    @private\n\n    Whenever a routable state is entered, the context it was entered with\n    is stashed so that we can regenerate the state's `absoluteURL` on\n    demand.\n  */\n  stashContext: function(manager, context) {\n    var serialized = this.serialize(manager, context);\n    Ember.assert('serialize must return a hash', !serialized || typeof serialized === 'object');\n\n    manager.setStateMeta(this, 'context', context);\n    manager.setStateMeta(this, 'serialized', serialized);\n\n    if (get(this, 'isRoutable') && !get(manager, 'isRouting')) {\n      this.updateRoute(manager, get(manager, 'location'));\n    }\n  },\n\n  /**\n    @private\n\n    Whenever a routable state is entered, the router's location object\n    is notified to set the URL to the current absolute path.\n\n    In general, this will update the browser's URL.\n  */\n  updateRoute: function(manager, location) {\n    if (get(this, 'isLeafRoute')) {\n      var path = this.absoluteRoute(manager);\n      location.setURL(path);\n    }\n  },\n\n  /**\n    @private\n\n    Get the absolute route for the current state and a given\n    hash.\n\n    This method is private, as it expects a serialized hash,\n    not the original context object.\n  */\n  absoluteRoute: function(manager, hash) {\n    var parentState = get(this, 'parentState');\n    var path = '', generated;\n\n    // If the parent state is routable, use its current path\n    // as this route's prefix.\n    if (get(parentState, 'isRoutable')) {\n      path = parentState.absoluteRoute(manager, hash);\n    }\n\n    var matcher = get(this, 'routeMatcher'),\n        serialized = manager.getStateMeta(this, 'serialized');\n\n    // merge the existing serialized object in with the passed\n    // in hash.\n    hash = hash || {};\n    merge(hash, serialized);\n\n    generated = matcher && matcher.generate(hash);\n\n    if (generated) {\n      path = path + '/' + generated;\n    }\n\n    return path;\n  },\n\n  /**\n    @private\n\n    At the moment, a state is routable if it has a string `route`\n    property. This heuristic may change.\n  */\n  isRoutable: Ember.computed(function() {\n    return typeof get(this, 'route') === 'string';\n  }).cacheable(),\n\n  /**\n    @private\n\n    Determine if this is the last routeable state\n  */\n  isLeafRoute: Ember.computed(function() {\n    if (get(this, 'isLeaf')) { return true; }\n    return !get(this, 'childStates').findProperty('isRoutable');\n  }).cacheable(),\n\n  /**\n    @private\n\n    A _RouteMatcher object generated from the current route's `route`\n    string property.\n  */\n  routeMatcher: Ember.computed(function() {\n    var route = get(this, 'route');\n    if (route) {\n      return Ember._RouteMatcher.create({ route: route });\n    }\n  }).cacheable(),\n\n  /**\n    @private\n\n    Check whether the route has dynamic segments and therefore takes\n    a context.\n  */\n  hasContext: Ember.computed(function() {\n    var routeMatcher = get(this, 'routeMatcher');\n    if (routeMatcher) {\n      return routeMatcher.identifiers.length > 0;\n    }\n  }).cacheable(),\n\n  /**\n    @private\n\n    The model class associated with the current state. This property\n    uses the `modelType` property, in order to allow it to be\n    specified as a String.\n  */\n  modelClass: Ember.computed(function() {\n    var modelType = get(this, 'modelType');\n\n    if (typeof modelType === 'string') {\n      return Ember.get(window, modelType);\n    } else {\n      return modelType;\n    }\n  }).cacheable(),\n\n  /**\n    @private\n\n    Get the model class for the state. The heuristic is:\n\n    * The state must have a single dynamic segment\n    * The dynamic segment must end in `_id`\n    * A dynamic segment like `blog_post_id` is converted into `BlogPost`\n    * The name is then looked up on the passed in namespace\n\n    The process of initializing an application with a router will\n    pass the application's namespace into the router, which will be\n    used here.\n  */\n  modelClassFor: function(namespace) {\n    var modelClass, routeMatcher, identifiers, match, className;\n\n    // if an explicit modelType was specified, use that\n    if (modelClass = get(this, 'modelClass')) { return modelClass; }\n\n    // if the router has no lookup namespace, we won't be able to guess\n    // the modelType\n    if (!namespace) { return; }\n\n    // make sure this state is actually a routable state\n    routeMatcher = get(this, 'routeMatcher');\n    if (!routeMatcher) { return; }\n\n    // only guess modelType for states with a single dynamic segment\n    // (no more, no fewer)\n    identifiers = routeMatcher.identifiers;\n    if (identifiers.length !== 2) { return; }\n\n    // extract the `_id` from the end of the dynamic segment; if the\n    // dynamic segment does not end in `_id`, we can't guess the\n    // modelType\n    match = identifiers[1].match(/^(.*)_id$/);\n    if (!match) { return; }\n\n    // convert the underscored type into a class form and look it up\n    // on the router's namespace\n    className = Ember.String.classify(match[1]);\n    return get(namespace, className);\n  },\n\n  /**\n    The default method that takes a `params` object and converts\n    it into an object.\n\n    By default, a params hash that looks like `{ post_id: 1 }`\n    will be looked up as `namespace.Post.find(1)`. This is\n    designed to work seamlessly with Ember Data, but will work\n    fine with any class that has a `find` method.\n  */\n  deserialize: function(manager, params) {\n    var modelClass, routeMatcher, param;\n\n    if (modelClass = this.modelClassFor(get(manager, 'namespace'))) {\n      Ember.assert(\"Expected \"+modelClass.toString()+\" to implement `find` for use in '\"+this.get('path')+\"' `deserialize`. Please implement the `find` method or overwrite `deserialize`.\", modelClass.find);\n      return modelClass.find(params[paramForClass(modelClass)]);\n    }\n\n    return params;\n  },\n\n  /**\n    The default method that takes an object and converts it into\n    a params hash.\n\n    By default, if there is a single dynamic segment named\n    `blog_post_id` and the object is a `BlogPost` with an\n    `id` of `12`, the serialize method will produce:\n\n        { blog_post_id: 12 }\n  */\n  serialize: function(manager, context) {\n    var modelClass, routeMatcher, namespace, param, id;\n\n    if (Ember.empty(context)) { return ''; }\n\n    if (modelClass = this.modelClassFor(get(manager, 'namespace'))) {\n      param = paramForClass(modelClass);\n      id = get(context, 'id');\n      context = {};\n      context[param] = id;\n    }\n\n    return context;\n  },\n\n  /**\n    @private\n  */\n  resolvePath: function(manager, path) {\n    if (get(this, 'isLeafRoute')) { return Ember.A(); }\n\n    var childStates = get(this, 'childStates'), match;\n\n    childStates = Ember.A(childStates.filterProperty('isRoutable'));\n\n    childStates = childStates.sort(function(a, b) {\n      var aDynamicSegments = get(a, 'routeMatcher.identifiers.length'),\n          bDynamicSegments = get(b, 'routeMatcher.identifiers.length'),\n          aRoute = get(a, 'route'),\n          bRoute = get(b, 'route');\n\n      if (aRoute.indexOf(bRoute) === 0) {\n        return -1;\n      } else if (bRoute.indexOf(aRoute) === 0) {\n        return 1;\n      }\n\n      if (aDynamicSegments !== bDynamicSegments) {\n        return aDynamicSegments - bDynamicSegments;\n      }\n\n      return get(b, 'route.length') - get(a, 'route.length');\n    });\n\n    var state = childStates.find(function(state) {\n      var matcher = get(state, 'routeMatcher');\n      if (match = matcher.match(path)) { return true; }\n    });\n\n    Ember.assert(\"Could not find state for path \" + path, !!state);\n\n    var resolvedState = Ember._ResolvedState.create({\n      manager: manager,\n      state: state,\n      match: match\n    });\n\n    var states = state.resolvePath(manager, match.remaining);\n\n    return Ember.A([resolvedState]).pushObjects(states);\n  },\n\n  /**\n    @private\n\n    Once `unroute` has finished unwinding, `routePath` will be called\n    with the remainder of the route.\n\n    For example, if you were in the /posts/1/comments state, and you\n    moved into the /posts/2/comments state, `routePath` will be called\n    on the state whose path is `/posts` with the path `/2/comments`.\n  */\n  routePath: function(manager, path) {\n    if (get(this, 'isLeafRoute')) { return; }\n\n    var resolvedStates = this.resolvePath(manager, path),\n        hasPromises = resolvedStates.some(function(s) { return get(s, 'hasPromise'); });\n\n    function runTransition() {\n      resolvedStates.forEach(function(rs) { rs.transition(); });\n    }\n\n    if (hasPromises) {\n      manager.transitionTo('loading');\n\n      Ember.assert('Loading state should be the child of a route', Ember.Routable.detect(get(manager, 'currentState.parentState')));\n      Ember.assert('Loading state should not be a route', !Ember.Routable.detect(get(manager, 'currentState')));\n\n      manager.handleStatePromises(resolvedStates, runTransition);\n    } else {\n      runTransition();\n    }\n  },\n\n  /**\n    @private\n\n    When you move to a new route by pressing the back\n    or forward button, this method is called first.\n\n    Its job is to move the state manager into a parent\n    state of the state it will eventually move into.\n  */\n  unroutePath: function(router, path) {\n    var parentState = get(this, 'parentState');\n\n    // If we're at the root state, we're done\n    if (parentState === router) {\n      return;\n    }\n\n    path = path.replace(/^(?=[^\\/])/, \"/\");\n    var absolutePath = this.absoluteRoute(router);\n\n    var route = get(this, 'route');\n\n    // If the current path is empty, move up one state,\n    // because the index ('/') state must be a leaf node.\n    if (route !== '/') {\n      // If the current path is a prefix of the path we're trying\n      // to go to, we're done.\n      var index = path.indexOf(absolutePath),\n          next = path.charAt(absolutePath.length);\n\n      if (index === 0 && (next === \"/\" || next === \"\")) {\n        return;\n      }\n    }\n\n    // Transition to the parent and call unroute again.\n    router.enterState({\n      exitStates: [this],\n      enterStates: [],\n      finalState: parentState\n    });\n\n    router.send('unroutePath', path);\n  },\n\n  /**\n    The `connectOutlets` event will be triggered once a\n    state has been entered. It will be called with the\n    route's context.\n  */\n  connectOutlets: Ember.K,\n\n  /**\n   The `navigateAway` event will be triggered when the\n   URL changes due to the back/forward button\n  */\n  navigateAway: Ember.K\n});\n\n})();\n//@ sourceURL=ember-routing/routable");