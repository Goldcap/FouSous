minispade.register('ember-routing/location/none_location', "(function() {var get = Ember.get, set = Ember.set;\n\n/**\n  @class\n\n  Ember.NoneLocation does not interact with the browser. It is useful for\n  testing, or when you need to manage state with your Router, but temporarily\n  don't want it to muck with the URL (for example when you embed your\n  application in a larger page).\n\n  @extends Ember.Object\n*/\nEmber.NoneLocation = Ember.Object.extend(\n/** @scope Ember.NoneLocation.prototype */ {\n  path: '',\n\n  getURL: function() {\n    return get(this, 'path');\n  },\n\n  setURL: function(path) {\n    set(this, 'path', path);\n  },\n\n  onUpdateURL: function(callback) {\n    // We are not wired up to the browser, so we'll never trigger the callback.\n  },\n\n  formatURL: function(url) {\n    // The return value is not overly meaningful, but we do not want to throw\n    // errors when test code renders templates containing {{action href=true}}\n    // helpers.\n    return url;\n  }\n});\n\nEmber.Location.registerImplementation('none', Ember.NoneLocation);\n\n})();\n//@ sourceURL=ember-routing/location/none_location");