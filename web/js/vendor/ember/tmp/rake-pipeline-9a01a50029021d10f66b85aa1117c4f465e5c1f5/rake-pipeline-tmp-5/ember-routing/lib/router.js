minispade.register('ember-routing/router', "(function() {minispade.require('ember-routing/route_matcher');\nminispade.require('ember-routing/routable');\nminispade.require('ember-routing/location');\n\nvar get = Ember.get, set = Ember.set;\n\nvar merge = function(original, hash) {\n  for (var prop in hash) {\n    if (!hash.hasOwnProperty(prop)) { continue; }\n    if (original.hasOwnProperty(prop)) { continue; }\n\n    original[prop] = hash[prop];\n  }\n};\n\n/**\n  @class\n\n  `Ember.Router` is the subclass of `Ember.StateManager` responsible for providing URL-based\n  application state detection. The `Ember.Router` instance of an application detects the browser URL\n  at application load time and attempts to match it to a specific application state. Additionally\n  the router will update the URL to reflect an application's state changes over time.\n\n  ## Adding a Router Instance to Your Application\n  An instance of Ember.Router can be associated with an instance of Ember.Application in one of two ways:\n\n  You can provide a subclass of Ember.Router as the `Router` property of your application. An instance\n  of this Router class will be instantiated and route detection will be enabled when the application's\n  `initialize` method is called. The Router instance will be available as the `router` property\n  of the application:\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({ ... })\n      });\n\n      App.initialize();\n      App.get('router') // an instance of App.Router\n\n  If you want to define a Router instance elsewhere, you can pass the instance to the application's\n  `initialize` method:\n\n      App = Ember.Application.create();\n      aRouter = Ember.Router.create({ ... });\n\n      App.initialize(aRouter);\n      App.get('router') // aRouter\n\n  ## Adding Routes to a Router\n  The `initialState` property of Ember.Router instances is named `root`. The state stored in this\n  property must be a subclass of Ember.Route. The `root` route acts as the container for the\n  set of routable states but is not routable itself. It should have states that are also subclasses\n  of Ember.Route which each have a `route` property describing the URL pattern you would like to detect.\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            index: Ember.Route.extend({\n              route: '/'\n            }),\n            ... additional Ember.Routes ...\n          })\n        })\n      });\n      App.initialize();\n\n\n  When an application loads, Ember will parse the URL and attempt to find an Ember.Route within\n  the application's states that matches. (The example URL-matching below will use the default\n  'hash syntax' provided by `Ember.HashLocation`.)\n\n  In the following route structure:\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/'\n            }),\n            bRoute: Ember.Route.extend({\n              route: '/alphabeta'\n            })\n          })\n        })\n      });\n      App.initialize();\n\n  Loading the page at the URL '#/' will detect the route property of 'root.aRoute' ('/') and\n  transition the router first to the state named 'root' and then to the substate 'aRoute'.\n\n  Respectively, loading the page at the URL '#/alphabeta' would detect the route property of\n  'root.bRoute' ('/alphabeta') and transition the router first to the state named 'root' and\n  then to the substate 'bRoute'.\n\n  ## Adding Nested Routes to a Router\n  Routes can contain nested subroutes each with their own `route` property describing the nested\n  portion of the URL they would like to detect and handle. Router, like all instances of StateManager,\n  cannot call `transitonTo` with an intermediary state. To avoid transitioning the Router into an\n  intermediary state when detecting URLs, a Route with nested routes must define both a base `route`\n  property for itself and a child Route with a `route` property of `'/'` which will be transitioned\n  to when the base route is detected in the URL:\n\n  Given the following application code:\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/theBaseRouteForThisSet',\n\n              indexSubRoute: Ember.Route.extend({\n                route: '/'\n              }),\n\n              subRouteOne: Ember.Route.extend({\n                route: '/subroute1'\n              }),\n\n              subRouteTwo: Ember.Route.extend({\n                route: '/subRoute2'\n              })\n\n            })\n          })\n        })\n      });\n      App.initialize();\n\n  When the application is loaded at '/theBaseRouteForThisSet' the Router will transition to the route\n  at path 'root.aRoute' and then transition to state 'indexSubRoute'.\n\n  When the application is loaded at '/theBaseRouteForThisSet/subRoute1' the Router will transition to\n  the route at path 'root.aRoute' and then transition to state 'subRouteOne'.\n\n  ## Route Transition Events\n  Transitioning between Ember.Route instances (including the transition into the detected\n  route when loading the application)  triggers the same transition events as state transitions for\n  base `Ember.State`s. However, the default `setup` transition event is named `connectOutlets` on\n  Ember.Router instances (see 'Changing View Hierarchy in Response To State Change').\n\n  The following route structure when loaded with the URL \"#/\"\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/',\n              enter: function(router) {\n                console.log(\"entering root.aRoute from\", router.get('currentState.name'));\n              },\n              connectOutlets: function(router) {\n                console.log(\"entered root.aRoute, fully transitioned to\", router.get('currentState.path'));\n              }\n            })\n          })\n        })\n      });\n      App.initialize();\n\n  Will result in console output of:\n\n      'entering root.aRoute from root'\n      'entered root.aRoute, fully transitioned to root.aRoute '\n\n  Ember.Route has two additional callbacks for handling URL serialization and deserialization. See\n  'Serializing/Deserializing URLs'\n\n  ## Routes With Dynamic Segments\n  An Ember.Route's `route` property can reference dynamic sections of the URL by prefacing a URL segment\n  with the ':' character.  The values of these dynamic segments will be passed as a hash to the\n  `deserialize` method of the matching Route (see 'Serializing/Deserializing URLs').\n\n  ## Serializing/Deserializing URLs\n  Ember.Route has two callbacks for associating a particular object context with a URL: `serialize`\n  for converting an object into a parameters hash to fill dynamic segments of a URL and `deserialize`\n  for converting a hash of dynamic segments from the URL into the appropriate object.\n\n  ### Deserializing A URL's Dynamic Segments\n  When an application is first loaded or the URL is changed manually (e.g. through the browser's\n  back button) the `deserialize` method of the URL's matching Ember.Route will be called with\n  the application's router as its first argument and a hash of the URLs dynamic segments and values\n  as its second argument.\n\n  The following route structure when loaded with the URL \"#/fixed/thefirstvalue/anotherFixed/thesecondvalue\":\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/fixed/:dynamicSectionA/anotherFixed/:dynamicSectionB',\n              deserialize: function(router, params) {}\n            })\n          })\n        })\n      });\n      App.initialize();\n\n  Will call the 'deserialize' method of the Route instance at the path 'root.aRoute' with the\n  following hash as its second argument:\n\n      {\n        dynamicSectionA: 'thefirstvalue',\n        dynamicSectionB: 'thesecondvalue'\n      }\n\n  Within `deserialize` you should use this information to retrieve or create an appropriate context\n  object for the given URL (e.g. by loading from a remote API or accessing the browser's\n  `localStorage`). This object must be the `return` value of `deserialize` and will be\n  passed to the Route's `connectOutlets` and `serialize` methods.\n\n  When an application's state is changed from within the application itself, the context provided for\n  the transition will be passed and `deserialize` is not called (see 'Transitions Between States').\n\n  ### Serializing An Object For URLs with Dynamic Segments\n  When transitioning into a Route whose `route` property contains dynamic segments the Route's\n  `serialize` method is called with the Route's router as the first argument and the Route's\n  context as the second argument.  The return value of `serialize` will be use to populate the\n  dynamic segments and should be a object with keys that match the names of the dynamic sections.\n\n  Given the following route structure:\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/'\n            }),\n            bRoute: Ember.Route.extend({\n              route: '/staticSection/:someDynamicSegment',\n              serialize: function(router, context) {\n                return {\n                  someDynamicSegment: context.get('name')\n                }\n              }\n            })\n          })\n        })\n      });\n      App.initialize();\n\n\n  Transitioning to \"root.bRoute\" with a context of `Object.create({name: 'Yehuda'})` will call\n  the Route's `serialize` method with the context as its second argument and update the URL to\n  '#/staticSection/Yehuda'.\n\n  ## Transitions Between States\n  Once a routed application has initialized its state based on the entry URL, subsequent transitions to other\n  states will update the URL if the entered Route has a `route` property. Given the following route structure\n  loaded at the URL '#/':\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/',\n              moveElsewhere: Ember.Route.transitionTo('bRoute')\n            }),\n            bRoute: Ember.Route.extend({\n              route: '/someOtherLocation'\n            })\n          })\n        })\n      });\n      App.initialize();\n\n  And application code:\n\n      App.get('router').send('moveElsewhere');\n\n  Will transition the application's state to 'root.bRoute' and trigger an update of the URL to\n  '#/someOtherLocation'.\n\n  For URL patterns with dynamic segments a context can be supplied as the second argument to `send`.\n  The router will match dynamic segments names to keys on this object and fill in the URL with the\n  supplied values. Given the following state structure loaded at the URL '#/':\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/',\n              moveElsewhere: Ember.Route.transitionTo('bRoute')\n            }),\n            bRoute: Ember.Route.extend({\n              route: '/a/route/:dynamicSection/:anotherDynamicSection',\n              connectOutlets: function(router, context) {},\n            })\n          })\n        })\n      });\n      App.initialize();\n\n  And application code:\n\n      App.get('router').send('moveElsewhere', {\n        dynamicSection: '42',\n        anotherDynamicSection: 'Life'\n      });\n\n  Will transition the application's state to 'root.bRoute' and trigger an update of the URL to\n  '#/a/route/42/Life'.\n\n  The context argument will also be passed as the second argument to the `serialize` method call.\n\n  ## Injection of Controller Singletons\n  During application initialization Ember will detect properties of the application ending in 'Controller',\n  create singleton instances of each class, and assign them as a properties on the router.  The property name\n  will be the UpperCamel name converted to lowerCamel format. These controller classes should be subclasses\n  of Ember.ObjectController, Ember.ArrayController, Ember.Controller, or a custom Ember.Object that includes the\n  Ember.ControllerMixin mixin.\n\n      App = Ember.Application.create({\n        FooController: Ember.Object.create(Ember.ControllerMixin),\n        Router: Ember.Router.extend({ ... })\n      });\n\n      App.get('router.fooController'); // instance of App.FooController\n\n  The controller singletons will have their `namespace` property set to the application and their `target`\n  property set to the application's router singleton for easy integration with Ember's user event system.\n  See 'Changing View Hierarchy in Response To State Change' and 'Responding to User-initiated Events'\n\n  ## Responding to User-initiated Events\n  Controller instances injected into the router at application initialization have their `target` property\n  set to the application's router instance. These controllers will also be the default `context` for their\n  associated views.  Uses of the `{{action}}` helper will automatically target the application's router.\n\n  Given the following application entered at the URL '#/':\n\n      App = Ember.Application.create({\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/',\n              anActionOnTheRouter: function(router, context) {\n                router.transitionTo('anotherState', context);\n              }\n            })\n            anotherState: Ember.Route.extend({\n              route: '/differentUrl',\n              connectOutlets: function(router, context) {\n\n              }\n            })\n          })\n        })\n      });\n      App.initialize();\n\n  The following template:\n\n      <script type=\"text/x-handlebars\" data-template-name=\"aView\">\n          <h1><a {{action anActionOnTheRouter}}>{{title}}</a></h1>\n      </script>\n\n  Will delegate `click` events on the rendered `h1` to the application's router instance. In this case the\n  `anActionOnTheRouter` method of the state at 'root.aRoute' will be called with the view's controller\n  as the context argument. This context will be passed to the `connectOutlets` as its second argument.\n\n  Different `context` can be supplied from within the `{{action}}` helper, allowing specific context passing\n  between application states:\n\n      <script type=\"text/x-handlebars\" data-template-name=\"photos\">\n        {{#each photo in controller}}\n          <h1><a {{action showPhoto photo}}>{{title}}</a></h1>\n        {{/each}}\n      </script>\n\n  See Handlebars.helpers.action for additional usage examples.\n\n\n  ## Changing View Hierarchy in Response To State Change\n  Changes in application state that change the URL should be accompanied by associated changes in view\n  hierarchy.  This can be accomplished by calling 'connectOutlet' on the injected controller singletons from\n  within the 'connectOutlets' event of an Ember.Route:\n\n      App = Ember.Application.create({\n        OneController: Ember.ObjectController.extend(),\n        OneView: Ember.View.extend(),\n\n        AnotherController: Ember.ObjectController.extend(),\n        AnotherView: Ember.View.extend(),\n\n        Router: Ember.Router.extend({\n          root: Ember.Route.extend({\n            aRoute: Ember.Route.extend({\n              route: '/',\n              connectOutlets: function(router, context) {\n                router.get('oneController').connectOutlet('another');\n              },\n            })\n          })\n        })\n      });\n      App.initialize();\n\n\n  This will detect the '{{outlet}}' portion of `oneController`'s view (an instance of `App.OneView`) and\n  fill it with a rendered instance of `App.AnotherView` whose `context` will be the single instance of\n  `App.AnotherController` stored on the router in the `anotherController` property.\n\n  For more information about Outlets, see `Ember.Handlebars.helpers.outlet`. For additional information on\n  the `connectOutlet` method, see `Ember.Controller.connectOutlet`. For more information on\n  controller injections, see `Ember.Application#initialize()`. For additional information about view context,\n  see `Ember.View`.\n\n  @extends Ember.StateManager\n*/\nEmber.Router = Ember.StateManager.extend(\n/** @scope Ember.Router.prototype */ {\n\n  /**\n    @property {String}\n    @default 'root'\n  */\n  initialState: 'root',\n\n  /**\n    The `Ember.Location` implementation to be used to manage the application\n    URL state. The following values are supported:\n\n    * 'hash': Uses URL fragment identifiers (like #/blog/1) for routing.\n    * 'none': Does not read or set the browser URL, but still allows for\n      routing to happen. Useful for testing.\n\n    @type String\n    @default 'hash'\n  */\n  location: 'hash',\n\n  /**\n    This is only used when a history location is used so that applications that\n    don't live at the root of the domain can append paths to their root.\n\n    @type String\n    @default '/'\n  */\n\n  rootURL: '/',\n\n  /**\n    On router, transitionEvent should be called connectOutlets\n\n    @property {String}\n    @default 'connectOutlets'\n  */\n  transitionEvent: 'connectOutlets',\n\n  transitionTo: function() {\n    this.abortRoutingPromises();\n    this._super.apply(this, arguments);\n  },\n\n  route: function(path) {\n    this.abortRoutingPromises();\n\n    set(this, 'isRouting', true);\n\n    var routableState;\n\n    try {\n      path = path.replace(/^(?=[^\\/])/, \"/\");\n\n      this.send('navigateAway');\n      this.send('unroutePath', path);\n\n      routableState = get(this, 'currentState');\n      while (routableState && !routableState.get('isRoutable')) {\n        routableState = get(routableState, 'parentState');\n      }\n      var currentURL = routableState ? routableState.absoluteRoute(this) : '';\n      var rest = path.substr(currentURL.length);\n\n      this.send('routePath', rest);\n    } finally {\n      set(this, 'isRouting', false);\n    }\n\n    routableState = get(this, 'currentState');\n    while (routableState && !routableState.get('isRoutable')) {\n      routableState = get(routableState, 'parentState');\n    }\n\n    if (routableState) {\n      routableState.updateRoute(this, get(this, 'location'));\n    }\n  },\n\n  urlFor: function(path, hash) {\n    var currentState = get(this, 'currentState') || this,\n        state = this.findStateByPath(currentState, path);\n\n    Ember.assert(Ember.String.fmt(\"Could not find route with path '%@'\", [path]), !!state);\n    Ember.assert(\"To get a URL for a state, it must have a `route` property.\", !!get(state, 'routeMatcher'));\n\n    var location = get(this, 'location'),\n        absoluteRoute = state.absoluteRoute(this, hash);\n\n    return location.formatURL(absoluteRoute);\n  },\n\n  urlForEvent: function(eventName) {\n    var contexts = Array.prototype.slice.call(arguments, 1);\n    var currentState = get(this, 'currentState');\n    var targetStateName = currentState.lookupEventTransition(eventName);\n\n    Ember.assert(Ember.String.fmt(\"You must specify a target state for event '%@' in order to link to it in the current state '%@'.\", [eventName, get(currentState, 'path')]), !!targetStateName);\n\n    var targetState = this.findStateByPath(currentState, targetStateName);\n\n    Ember.assert(\"Your target state name \" + targetStateName + \" for event \" + eventName + \" did not resolve to a state\", !!targetState);\n\n    var hash = this.serializeRecursively(targetState, contexts, {});\n\n    return this.urlFor(targetStateName, hash);\n  },\n\n  /** @private */\n  serializeRecursively: function(state, contexts, hash) {\n    var parentState,\n        context = get(state, 'hasContext') ? contexts.pop() : null;\n    merge(hash, state.serialize(this, context));\n    parentState = state.get(\"parentState\");\n    if (parentState && parentState instanceof Ember.Route) {\n      return this.serializeRecursively(parentState, contexts, hash);\n    } else {\n      return hash;\n    }\n  },\n\n  abortRoutingPromises: function() {\n    if (this._routingPromises) {\n      this._routingPromises.abort();\n      this._routingPromises = null;\n    }\n  },\n\n  /**\n    @private\n  */\n  handleStatePromises: function(states, complete) {\n    this.abortRoutingPromises();\n\n    this.set('isLocked', true);\n\n    var manager = this;\n\n    this._routingPromises = Ember._PromiseChain.create({\n      promises: states.slice(),\n\n      successCallback: function() {\n        manager.set('isLocked', false);\n        complete();\n      },\n\n      failureCallback: function() {\n        throw \"Unable to load object\";\n      },\n\n      promiseSuccessCallback: function(item, args) {\n        set(item, 'object', args[0]);\n      },\n\n      abortCallback: function() {\n        manager.set('isLocked', false);\n      }\n    }).start();\n  },\n\n  /** @private */\n  init: function() {\n    this._super();\n\n    var location = get(this, 'location'),\n        rootURL = get(this, 'rootURL');\n\n    if ('string' === typeof location) {\n      set(this, 'location', Ember.Location.create({\n        implementation: location,\n        rootURL: rootURL\n      }));\n    }\n  },\n\n  /** @private */\n  willDestroy: function() {\n    get(this, 'location').destroy();\n  }\n});\n\n})();\n//@ sourceURL=ember-routing/router");