minispade.register('metamorph', "(function() {// ==========================================================================\n// Project:   metamorph\n// Copyright: Â©2011 My Company Inc. All rights reserved.\n// ==========================================================================\n\n(function(window) {\n\n  var K = function(){},\n      guid = 0,\n      document = window.document,\n\n      // Feature-detect the W3C range API, the extended check is for IE9 which only partially supports ranges\n      supportsRange = ('createRange' in document) && (typeof Range !== 'undefined') && Range.prototype.createContextualFragment,\n\n      // Internet Explorer prior to 9 does not allow setting innerHTML if the first element\n      // is a \"zero-scope\" element. This problem can be worked around by making\n      // the first node an invisible text node. We, like Modernizr, use &shy;\n      needsShy = (function(){\n        var testEl = document.createElement('div');\n        testEl.innerHTML = \"<div></div>\";\n        testEl.firstChild.innerHTML = \"<script></script>\";\n        return testEl.firstChild.innerHTML === '';\n      })();\n\n  // Constructor that supports either Metamorph('foo') or new\n  // Metamorph('foo');\n  //\n  // Takes a string of HTML as the argument.\n\n  var Metamorph = function(html) {\n    var self;\n\n    if (this instanceof Metamorph) {\n      self = this;\n    } else {\n      self = new K();\n    }\n\n    self.innerHTML = html;\n    var myGuid = 'metamorph-'+(guid++);\n    self.start = myGuid + '-start';\n    self.end = myGuid + '-end';\n\n    return self;\n  };\n\n  K.prototype = Metamorph.prototype;\n\n  var rangeFor, htmlFunc, removeFunc, outerHTMLFunc, appendToFunc, afterFunc, prependFunc, startTagFunc, endTagFunc;\n\n  outerHTMLFunc = function() {\n    return this.startTag() + this.innerHTML + this.endTag();\n  };\n\n  startTagFunc = function() {\n    return \"<script id='\" + this.start + \"' type='text/x-placeholder'></script>\";\n  };\n\n  endTagFunc = function() {\n    return \"<script id='\" + this.end + \"' type='text/x-placeholder'></script>\";\n  };\n\n  // If we have the W3C range API, this process is relatively straight forward.\n  if (supportsRange) {\n\n    // Get a range for the current morph. Optionally include the starting and\n    // ending placeholders.\n    rangeFor = function(morph, outerToo) {\n      var range = document.createRange();\n      var before = document.getElementById(morph.start);\n      var after = document.getElementById(morph.end);\n\n      if (outerToo) {\n        range.setStartBefore(before);\n        range.setEndAfter(after);\n      } else {\n        range.setStartAfter(before);\n        range.setEndBefore(after);\n      }\n\n      return range;\n    };\n\n    htmlFunc = function(html, outerToo) {\n      // get a range for the current metamorph object\n      var range = rangeFor(this, outerToo);\n\n      // delete the contents of the range, which will be the\n      // nodes between the starting and ending placeholder.\n      range.deleteContents();\n\n      // create a new document fragment for the HTML\n      var fragment = range.createContextualFragment(html);\n\n      // insert the fragment into the range\n      range.insertNode(fragment);\n    };\n\n    removeFunc = function() {\n      // get a range for the current metamorph object including\n      // the starting and ending placeholders.\n      var range = rangeFor(this, true);\n\n      // delete the entire range.\n      range.deleteContents();\n    };\n\n    appendToFunc = function(node) {\n      var range = document.createRange();\n      range.setStart(node);\n      range.collapse(false);\n      var frag = range.createContextualFragment(this.outerHTML());\n      node.appendChild(frag);\n    };\n\n    afterFunc = function(html) {\n      var range = document.createRange();\n      var after = document.getElementById(this.end);\n\n      range.setStartAfter(after);\n      range.setEndAfter(after);\n\n      var fragment = range.createContextualFragment(html);\n      range.insertNode(fragment);\n    };\n\n    prependFunc = function(html) {\n      var range = document.createRange();\n      var start = document.getElementById(this.start);\n\n      range.setStartAfter(start);\n      range.setEndAfter(start);\n\n      var fragment = range.createContextualFragment(html);\n      range.insertNode(fragment);\n    };\n\n  } else {\n    /**\n     * This code is mostly taken from jQuery, with one exception. In jQuery's case, we\n     * have some HTML and we need to figure out how to convert it into some nodes.\n     *\n     * In this case, jQuery needs to scan the HTML looking for an opening tag and use\n     * that as the key for the wrap map. In our case, we know the parent node, and\n     * can use its type as the key for the wrap map.\n     **/\n    var wrapMap = {\n      select: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n      fieldset: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n      table: [ 1, \"<table>\", \"</table>\" ],\n      tbody: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n      tr: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n      colgroup: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n      map: [ 1, \"<map>\", \"</map>\" ],\n      _default: [ 0, \"\", \"\" ]\n    };\n\n    /**\n     * Given a parent node and some HTML, generate a set of nodes. Return the first\n     * node, which will allow us to traverse the rest using nextSibling.\n     *\n     * We need to do this because innerHTML in IE does not really parse the nodes.\n     **/\n    var firstNodeFor = function(parentNode, html) {\n      var arr = wrapMap[parentNode.tagName.toLowerCase()] || wrapMap._default;\n      var depth = arr[0], start = arr[1], end = arr[2];\n\n      if (needsShy) { html = '&shy;'+html; }\n\n      var element = document.createElement('div');\n      element.innerHTML = start + html + end;\n\n      for (var i=0; i<=depth; i++) {\n        element = element.firstChild;\n      }\n\n      // Look for &shy; to remove it.\n      if (needsShy) {\n        var shyElement = element;\n\n        // Sometimes we get nameless elements with the shy inside\n        while (shyElement.nodeType === 1 && !shyElement.nodeName) {\n          shyElement = shyElement.firstChild;\n        }\n\n        // At this point it's the actual unicode character.\n        if (shyElement.nodeType === 3 && shyElement.nodeValue.charAt(0) === \"\\u00AD\") {\n          shyElement.nodeValue = shyElement.nodeValue.slice(1);\n        }\n      }\n\n      return element;\n    };\n\n    /**\n     * In some cases, Internet Explorer can create an anonymous node in\n     * the hierarchy with no tagName. You can create this scenario via:\n     *\n     *     div = document.createElement(\"div\");\n     *     div.innerHTML = \"<table>&shy<script></script><tr><td>hi</td></tr></table>\";\n     *     div.firstChild.firstChild.tagName //=> \"\"\n     *\n     * If our script markers are inside such a node, we need to find that\n     * node and use *it* as the marker.\n     **/\n    var realNode = function(start) {\n      while (start.parentNode.tagName === \"\") {\n        start = start.parentNode;\n      }\n\n      return start;\n    };\n\n    /**\n     * When automatically adding a tbody, Internet Explorer inserts the\n     * tbody immediately before the first <tr>. Other browsers create it\n     * before the first node, no matter what.\n     *\n     * This means the the following code:\n     *\n     *     div = document.createElement(\"div\");\n     *     div.innerHTML = \"<table><script id='first'></script><tr><td>hi</td></tr><script id='last'></script></table>\n     *\n     * Generates the following DOM in IE:\n     *\n     *     + div\n     *       + table\n     *         - script id='first'\n     *         + tbody\n     *           + tr\n     *             + td\n     *               - \"hi\"\n     *           - script id='last'\n     *\n     * Which means that the two script tags, even though they were\n     * inserted at the same point in the hierarchy in the original\n     * HTML, now have different parents.\n     *\n     * This code reparents the first script tag by making it the tbody's\n     * first child.\n     **/\n    var fixParentage = function(start, end) {\n      if (start.parentNode !== end.parentNode) {\n        end.parentNode.insertBefore(start, end.parentNode.firstChild);\n      }\n    };\n\n    htmlFunc = function(html, outerToo) {\n      // get the real starting node. see realNode for details.\n      var start = realNode(document.getElementById(this.start));\n      var end = document.getElementById(this.end);\n      var parentNode = end.parentNode;\n      var node, nextSibling, last;\n\n      // make sure that the start and end nodes share the same\n      // parent. If not, fix it.\n      fixParentage(start, end);\n\n      // remove all of the nodes after the starting placeholder and\n      // before the ending placeholder.\n      node = start.nextSibling;\n      while (node) {\n        nextSibling = node.nextSibling;\n        last = node === end;\n\n        // if this is the last node, and we want to remove it as well,\n        // set the `end` node to the next sibling. This is because\n        // for the rest of the function, we insert the new nodes\n        // before the end (note that insertBefore(node, null) is\n        // the same as appendChild(node)).\n        //\n        // if we do not want to remove it, just break.\n        if (last) {\n          if (outerToo) { end = node.nextSibling; } else { break; }\n        }\n\n        node.parentNode.removeChild(node);\n\n        // if this is the last node and we didn't break before\n        // (because we wanted to remove the outer nodes), break\n        // now.\n        if (last) { break; }\n\n        node = nextSibling;\n      }\n\n      // get the first node for the HTML string, even in cases like\n      // tables and lists where a simple innerHTML on a div would\n      // swallow some of the content.\n      node = firstNodeFor(start.parentNode, html);\n\n      // copy the nodes for the HTML between the starting and ending\n      // placeholder.\n      while (node) {\n        nextSibling = node.nextSibling;\n        parentNode.insertBefore(node, end);\n        node = nextSibling;\n      }\n    };\n\n    // remove the nodes in the DOM representing this metamorph.\n    //\n    // this includes the starting and ending placeholders.\n    removeFunc = function() {\n      var start = realNode(document.getElementById(this.start));\n      var end = document.getElementById(this.end);\n\n      this.html('');\n      start.parentNode.removeChild(start);\n      end.parentNode.removeChild(end);\n    };\n\n    appendToFunc = function(parentNode) {\n      var node = firstNodeFor(parentNode, this.outerHTML());\n\n      while (node) {\n        nextSibling = node.nextSibling;\n        parentNode.appendChild(node);\n        node = nextSibling;\n      }\n    };\n\n    afterFunc = function(html) {\n      // get the real starting node. see realNode for details.\n      var end = document.getElementById(this.end);\n      var insertBefore = end.nextSibling;\n      var parentNode = end.parentNode;\n      var nextSibling;\n      var node;\n\n      // get the first node for the HTML string, even in cases like\n      // tables and lists where a simple innerHTML on a div would\n      // swallow some of the content.\n      node = firstNodeFor(parentNode, html);\n\n      // copy the nodes for the HTML between the starting and ending\n      // placeholder.\n      while (node) {\n        nextSibling = node.nextSibling;\n        parentNode.insertBefore(node, insertBefore);\n        node = nextSibling;\n      }\n    };\n\n    prependFunc = function(html) {\n      var start = document.getElementById(this.start);\n      var parentNode = start.parentNode;\n      var nextSibling;\n      var node;\n\n      node = firstNodeFor(parentNode, html);\n      var insertBefore = start.nextSibling;\n\n      while (node) {\n        nextSibling = node.nextSibling;\n        parentNode.insertBefore(node, insertBefore);\n        node = nextSibling;\n      }\n    }\n  }\n\n  Metamorph.prototype.html = function(html) {\n    this.checkRemoved();\n    if (html === undefined) { return this.innerHTML; }\n\n    htmlFunc.call(this, html);\n\n    this.innerHTML = html;\n  };\n\n  Metamorph.prototype.replaceWith = function(html) {\n    this.checkRemoved();\n    htmlFunc.call(this, html, true);\n  };\n\n  Metamorph.prototype.remove = removeFunc;\n  Metamorph.prototype.outerHTML = outerHTMLFunc;\n  Metamorph.prototype.appendTo = appendToFunc;\n  Metamorph.prototype.after = afterFunc;\n  Metamorph.prototype.prepend = prependFunc;\n  Metamorph.prototype.startTag = startTagFunc;\n  Metamorph.prototype.endTag = endTagFunc;\n\n  Metamorph.prototype.isRemoved = function() {\n    var before = document.getElementById(this.start);\n    var after = document.getElementById(this.end);\n\n    return !before || !after;\n  };\n\n  Metamorph.prototype.checkRemoved = function() {\n    if (this.isRemoved()) {\n      throw new Error(\"Cannot perform operations on a Metamorph that is not in the DOM.\");\n    }\n  };\n\n  window.Metamorph = Metamorph;\n})(this);\n\n\n})();\n//@ sourceURL=metamorph");